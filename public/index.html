<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>LearningHub ‚Äî Lessons (Improved Tests v2)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>

    :root{ --accent:#0b5cff; --bg:#f6f7fb; --card:#ffffff; --muted:#6b7280; }
    *{box-sizing:border-box}

    :root {
  --danger: #ef4444;
}


/* Modern balance modal style (updated colors + buttons) */
.balance-modal {
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  max-width: 520px;
  padding: 18px;
  border-radius: 12px;
  background: linear-gradient(180deg, #ffffff, #fbfdff);
  box-shadow: 0 12px 40px rgba(8,20,50,0.08);
  color: #0f1724;
  line-height: 1.3;
}
.balance-modal h3 { margin: 0 0 10px; font-size: 20px; }
.balance-user { display:flex; align-items:center; gap:12px; }
.balance-avatar {
  width:44px; height:44px; border-radius:10px; background: linear-gradient(135deg,#eef2ff,#e6f7ff);
  display:flex; align-items:center; justify-content:center; font-weight:700; color:#0b5cff;
}
.balance-row { margin-top:12px; display:flex; align-items:center; justify-content:space-between; }
.balance-col { flex:1; }
.counter { font-weight:700; font-size:20px; }
.counter-sub { font-size:12px; color:#475569; margin-top:6px; }

/* button group - improved primary blue */
.btn-row { margin-top:16px; display:flex; gap:8px; justify-content:flex-end; }
.btn {
  padding:8px 12px; border-radius:8px; border:0; cursor:pointer; font-weight:600;
  background: linear-gradient(180deg,#0b6cff,#0a58d6); color:white;
  box-shadow: 0 6px 18px rgba(10,86,214,0.14);
}
.btn-ghost {
  padding:8px 12px; border-radius:8px; border:1px solid #e6eefb; background:white; color:#0b5cff; cursor:pointer;
}
.small-muted { font-size:12px; color:#94a3b8; }

/* compact list for requests */
.requests-list { max-height:360px; overflow:auto; margin-top:10px; padding:6px; border-radius:8px; background:#fbfdff; border:1px solid #eef2ff; }
.request-item { padding:10px; border-bottom:1px solid #f1f5f9; display:flex; justify-content:space-between; gap:10px; align-items:center; }
.request-left { display:flex; flex-direction:column; gap:4px; }
.request-status { padding:6px 8px; border-radius:10px; font-weight:700; font-size:12px; }
.status-pending { background:#fff7ed; color:#b45309; border:1px solid rgba(245,158,11,0.08); }
.status-verified { background:#ecfdf5; color:#059669; border:1px solid rgba(16,185,129,0.08); }
.status-rejected { background:#fff1f2; color:#be123c; border:1px solid rgba(239,68,68,0.08); }
.small-cta { font-size:13px; padding:6px 8px; border-radius:8px; cursor:pointer; background:#f1f5f9; border:0; }
.toggle-row { display:flex; gap:8px; align-items:center; margin-top:8px; }

/* countdown display */
.countdown { font-weight:700; color:#0b5cff; }

/* responsive */
@media (max-width:520px){
  .balance-modal { width:calc(100vw - 32px); }
  .counter { font-size:18px; }
  .btn-row { flex-direction:column; align-items:stretch; }
}

/* Unopened (new) title highlight + small badge */
.ann-unopened .ann-title { color: var(--danger); }
.ann-new-badge {
  display:inline-block;
  background:var(--danger);
  color:#fff;
  font-size:12px;
  padding:2px 8px;
  border-radius:999px;
  margin-left:8px;
  vertical-align:middle;
  font-weight:700;
  line-height:1;
}

/* Preview text: make sure it doesn't push full height (JS will only insert first line) */
.ann-text { margin-top:8px; color:#111; font-size:14px; line-height:1.45; }

     /* small style improvements for the bell modal and list */
  .ann-unopened { background: linear-gradient(90deg, rgba(11,92,255,0.04), transparent); }
  .ann-row { padding:12px; border-bottom:1px solid #eef2f6; border-radius:8px; margin:6px 0; }
  .ann-title { font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-size:15px }
  .ann-meta { color:#6b7280; font-size:12px; margin-top:4px }
  .ann-text { margin-top:8px; white-space:pre-wrap; line-height:1.45; color:#111 } /* pre-wrap preserves newlines */
  .btn-ghost { background:#fff;border:1px solid #e6e6e6;padding:6px 10px;border-radius:8px;cursor:pointer }
  .btn-primary { background:#0b5cff;color:#fff;border:0;padding:8px 10px;border-radius:8px;cursor:pointer }
  .small-btn { padding:6px 8px;border-radius:8px;border:1px solid #e6e6e6;background:#fff }
    /* ---------- Icon-picker drop-in styles ---------- */
/* Put these near your existing modal styles */
.icon-picker {
  display:flex;
  gap:10px;
  align-items:center;
  width:100%;
  flex-wrap:wrap;
}
.icon-picker .picker-left {
  display:flex;
  gap:8px;
  align-items:center;
  min-width:250px;
  flex: 1 1 260px;
}
.icon-picker select,
.icon-picker input[type="text"] {
  padding:8px 10px;
  border-radius:8px;
  border:1px solid #e6e6e6;
  background:#fff;
  font-size:14px;
  box-shadow:0 2px 6px rgba(11,92,255,0.03);
}
.icon-picker .fldIconPreview {
  width:56px;
  height:56px;
  border-radius:10px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:26px;
  background:#fff;
  border:1px solid #eef2ff;
  box-shadow:0 6px 18px rgba(10,10,10,0.04);
  flex:0 0 56px;
  overflow:hidden;
}
.icon-picker .fldIconPreview img {
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}
/* small grid option (if you provide clickable emoji grid later) */
.icon-picker-grid {
  display:grid;
  grid-template-columns:repeat(auto-fit, minmax(44px, 1fr));
  gap:6px;
  padding-top:8px;
}
.icon-picker-grid button {
  background:#fff;border:1px solid #f0f0f3;padding:6px;border-radius:8px;font-size:18px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;
}
.icon-picker-grid button.selected { border-color: var(--accent); box-shadow: 0 6px 18px rgba(10,10,10,0.06); transform: translateY(-2px); }
@media (max-width:700px) {
  .icon-picker { gap:8px; }
  .icon-picker .picker-left { flex-basis:100%; }
}


    body{font-family:system-ui,Arial;background:var(--bg);margin:0;padding:0;color:#111}
    header{background:#fff;padding:12px 16px;display:flex;gap:12px;align-items:center;box-shadow:0 1px 0 rgba(0,0,0,0.06)}
    header .brand{font-weight:700}
    nav a{color:#333;text-decoration:none;margin-right:10px}
    .container{max-width:1100px;margin:20px auto;padding:16px}
    .topbar{display:flex;align-items:center;gap:12px}
    .card{background:var(--card);padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(10,10,10,0.04);margin-bottom:12px}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .muted{color:var(--muted)}
    .row{display:flex;gap:12px;align-items:center}
    .folders-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px}
    .folder-card{background:#fff;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(10,10,10,0.04);cursor:pointer;display:flex;flex-direction:column;gap:8px}
    .folder-icon{width:44px;height:44px;border-radius:8px;background:#eef2ff;display:inline-flex;align-items:center;justify-content:center;font-size:20px}
    .folder-actions{margin-left:auto;display:flex;gap:6px}
    .small-btn{background:#f3f4f6;color:#111;padding:6px 8px;border-radius:6px;border:none;cursor:pointer}
    .folder-header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
    .btn-ghost{background:transparent;border:1px solid #e6e6e6;padding:8px 10px;border-radius:8px;color:#333}
    .lessons-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px}
    .lesson-card{background:#fff;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(10,10,10,0.04);display:flex;flex-direction:column;justify-content:space-between;min-height:110px;cursor:pointer}
    .lesson-card h4{margin:0 0 6px 0}
    .lesson-card p{margin:0;color:var(--muted);font-size:13px}
    .lesson-card .card-actions{display:flex;gap:8px;margin-top:10px}
    .crumbs{font-size:14px;color:var(--muted);margin-bottom:8px}
    .crumbs a{color:var(--accent);cursor:pointer;text-decoration:underline;margin-right:6px}
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:999}
    .modal{background:#fff;border-radius:10px;padding:16px;max-width:900px;width:100%;max-height:90vh;overflow:auto}
    input, textarea, select{padding:8px;border-radius:6px;border:1px solid #e6e6e6;margin-top:6px}
    .modal input[type="text"], .modal textarea, .modal select { width:100%; box-sizing:border-box; }
    .opt-row { display:flex; gap:8px; align-items:center; margin-bottom:6px; }
    .opt-row input[type="text"] { flex:1; min-width:120px; width:auto; }
    label{display:block;margin-top:10px;font-weight:600}
    .muted-note{font-size:13px;color:var(--muted);margin-top:6px}
    .lang-btn { background: transparent; color: #333; border: 1px solid #e6e6e6; padding:6px 8px; border-radius:6px; cursor:pointer; margin-left:6px; }
    .lang-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }
    .lesson-view{background:#fff;padding:18px;border-radius:10px;box-shadow:0 6px 20px rgba(10,10,10,0.04)}
    .lesson-content{margin-top:12px;line-height:1.7}
    .test-question { border:1px solid #eef2ff; padding:12px; border-radius:10px; margin-bottom:10px; background:linear-gradient(180deg, #fff,#fbfeff); }
    .test-question h4 { margin:0 0 8px 0; font-size:16px; }
    .test-option { display:flex; align-items:center; gap:10px; padding:8px; border-radius:8px; margin-bottom:6px; background:#fff; border:1px solid #f3f4f6; }
    .test-option input[type="radio"], .test-option input[type="checkbox"] { transform: scale(1.2); margin:0; }
    .test-option label { flex:1; cursor:pointer; }
    .test-controls { display:flex; gap:8px; margin-top:12px; }
    .small-muted { font-size:13px; color:var(--muted); }
    .timer { font-weight:700; margin-left:10px; color:var(--accent); }
    .progress-wrap { width:100%; background:#eef2ff; height:12px; border-radius:12px; overflow:hidden; margin-top:8px }
    .progress-bar { height:100%; width:0%; background:linear-gradient(90deg,var(--accent),#4aa3ff); transition:width .25s ease }
    @media(max-width:700px){ .row{flex-wrap:wrap} .folder-header{flex-direction:column;align-items:flex-start} .modal{max-width:95%;} .container{padding:12px} }
  </style>
</head>
<body>
  <header id="site-header">
    <style>
      :root{
        --accent:#0b5cff;
        --bg:#f6f7fb;
        --card:#ffffff;
        --muted:#6b7280;
        --glass: rgba(255,255,255,0.9);
        --nav-hover-bg: rgba(11,92,255,0.06);
      }
  
      /* header layout */
      #site-header { background:var(--card); border-bottom:1px solid #eef2f6; position:relative; z-index:60; }
      .sh-top { max-width:1100px; margin:0 auto; display:flex; align-items:center; gap:12px; padding:10px 16px; }
      .sh-brand { font-weight:700; display:flex; gap:8px; align-items:center; color:#111; font-size:15px }
      .sh-brand .logo { font-size:18px }
  
      /* desktop nav */
      .sh-nav { display:flex; gap:6px; align-items:center; margin-left:12px; }
      .sh-nav a {
        color:#111;
        text-decoration:none;
        padding:8px 12px;
        border-radius:10px;
        font-size:14px;
        position:relative;
        transition: transform .18s ease, color .12s ease;
        -webkit-tap-highlight-color: transparent;
      }
      .sh-nav a::after {
        content: "";
        position: absolute;
        left: 12px;
        right: 12px;
        bottom: 6px;
        height: 2px;
        background: linear-gradient(90deg,var(--accent),#4aa3ff);
        transform-origin: left center;
        transform: scaleX(0);
        transition: transform .18s ease;
        border-radius:2px;
        opacity:0.95;
      }
      .sh-nav a:hover { color: var(--accent); transform: translateY(-2px); }
      .sh-nav a:hover::after { transform: scaleX(1); }
  
      .sh-right { margin-left:auto; display:flex; align-items:center; gap:8px; }
  
      /* buttons */
      .icon-btn { background:transparent; border:0; padding:8px; border-radius:8px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; transition: transform .12s ease, background .12s ease; }
      .icon-btn:active { transform: translateY(1px); }
      .small-btn { background:#fff; border:1px solid #e6e6e6; padding:6px 8px; border-radius:8px; cursor:pointer; font-size:13px; color:#111; transition: transform .12s ease, box-shadow .12s ease; }
      .small-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 18px rgba(11,92,255,0.06); }
      .badge { display:inline-flex; align-items:center; justify-content:center; min-width:18px; height:18px; padding:0 6px; border-radius:999px; background:#ef4444; color:#fff; font-size:11px }
  
      /* mobile panel (improved) */
      .hamburger { display:none; width:44px; height:44px; align-items:center; justify-content:center; border-radius:8px; }
      .mobile-panel {
        position:fixed; top:64px; right:12px; width:320px; max-width:92vw;
        background:linear-gradient(180deg, rgba(255,255,255,0.98), var(--card));
        border-radius:14px; box-shadow:0 24px 60px rgba(2,6,23,0.14);
        transform-origin:top right;
        transform: translateY(-10px) scale(.98);
        opacity:0; pointer-events:none;
        transition: transform .26s cubic-bezier(.2,.9,.28,1), opacity .22s ease;
        z-index:120;
      }
      .mobile-panel.open { transform: translateY(0) scale(1); opacity:1; pointer-events:auto; }
      .mobile-panel .inner { padding:14px; display:flex; flex-direction:column; gap:10px; }
      .mobile-panel .brand-row { display:flex;align-items:center;gap:10px;padding:8px 6px;border-bottom:1px solid #f1f5f9;margin-bottom:6px }
      .mobile-panel a {
        display:block;
        text-align:left; padding:12px 14px; border-radius:10px; background:transparent; border:0; color:#111; cursor:pointer; font-size:15px;
        transition: transform .14s ease, background .12s ease;
        text-decoration:none;
      }
      .mobile-panel a:hover { background: var(--nav-hover-bg); transform: translateX(6px); color: var(--accent); }
  
      .mobile-panel .section-title { font-weight:700; color:#111; padding:6px 6px; font-size:13px; opacity:.9; }
  
      /* settings dropdown */
      .settings-dropdown {
        position:absolute; top:54px; right:16px; width:320px; max-width:92vw;
        background:var(--card); border-radius:10px; box-shadow:0 20px 60px rgba(2,6,23,0.15);
        transform-origin:top right; transform:translateY(-8px) scale(.98);
        opacity:0; pointer-events:none; transition: transform .18s cubic-bezier(.2,.9,.28,1), opacity .14s ease; z-index:130;
      }
      .settings-dropdown.open { transform:translateY(0) scale(1); opacity:1; pointer-events:auto; }
      .settings-dropdown .inner { padding:10px; display:flex; flex-direction:column; gap:8px; }
      .settings-item { display:flex; align-items:center; gap:10px; padding:10px; border-radius:10px; cursor:pointer; color:#111; border:0; background:transparent; text-align:left; font-size:14px; transition: background .12s ease; }
      .settings-item:hover { background:#f6f9ff; color:var(--accent); }
      .settings-item .icon { width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; background:#fbfdff; border:1px solid #eef6ff; }
  
      .divider { height:1px; background:#f0f3f7; margin:6px 0; border-radius:2px; }
  
      /* responsive behavior */
      @media (max-width:900px) {
        .sh-nav { display:none; }           /* hide desktop nav on mobile */
        .hamburger { display:inline-flex; } /* show hamburger */
        /* show settings gear on mobile */
        #btnSettings { display:inline-flex !important; }
        /* hide wide-screen text buttons on mobile */
        #btn-login, #btn-register, #btn-logout, #btn-balance, #btn-convert, #btn-check-withdrawals, #btn-edit-profile,
        #btn-add-folder, #btn-recycle { display:none !important; }
        .sh-top { padding-right:12px; }
      }
  
      /* hide gear on desktop only */
      @media (min-width:901px) {
        .mobile-panel { display:none; }
        .settings-dropdown { right:18px; }
        #btnSettings { display:none !important; } /* hide on desktop */
      }
  
      /* accessibility / focus */
      .sh-nav a:focus, .mobile-panel a:focus, .settings-item:focus { outline: 3px solid rgba(11,92,255,0.12); outline-offset:4px; border-radius:10px; }
  
    </style>
  
    <div class="sh-top">
      <div class="sh-brand" aria-hidden="false">
        <span class="logo">üìö</span>
        <span>LearningHub</span>
      </div>
  
      <!-- Desktop nav (hidden on small screens) -->
      <nav class="sh-nav" aria-label="Main navigation">
        <a href="admin_dashboard.html" class="admin-link">Dashboard</a>
        <a href="index.html">Lessons</a>
        <a href="leaderboard.html">Leaderboard</a>
        <a href="history.html">History</a>
        <a href="story.html">Stories</a>

        <a href="games.html">Games</a>
        <a href="admin_users.html" class="admin-link">Users</a>
        <a href="helpCenter.html">Helper</a>
      </nav>
  
      <!-- Right controls -->
      <div class="sh-right" role="region" aria-label="User controls">
        <!-- auth text buttons (desktop only) -->
        <button id="btn-login" class="small-btn">Login</button>
        <button id="btn-register" class="small-btn">Register</button>
        <button id="btn-logout" class="small-btn" style="display:none">Logout</button>
  
        <!-- small action buttons (desktop only, visible via applyNavUI) -->
        <button id="btn-balance" class="small-btn" style="display:none">Balance</button>
        <button id="btn-convert" class="small-btn" style="display:none">Convert Points</button>
        <button id="btn-check-withdrawals" class="small-btn" style="display:none">Checking</button>
        <button id="btn-edit-profile" class="small-btn" style="display:none">Edit Profile</button>
  
        <!-- Add folder & recycle buttons (desktop) -->
        <button id="btn-add-folder" class="small-btn" style="display:none">+ Add Folder</button>
        <button id="btn-recycle" class="small-btn" style="display:none">Recycle</button>
  
        <!-- bell (desktop & mobile when applyNavUI shows it) -->
        <button id="btnBell" class="icon-btn" aria-haspopup="true" aria-expanded="false" title="Notifications" style="position:relative; display:none">
          <span style="font-size:18px">üîî</span>
          <span id="help_unread_badge" class="badge" style="display:none; position:absolute; top:-6px; right:-6px">0</span>
        </button>
  
        <!-- settings gear ‚Äî VISIBLE ON MOBILE/TABLET, HIDDEN ON DESKTOP via CSS above -->
        <button id="btnSettings" class="icon-btn" aria-haspopup="true" aria-expanded="false" title="Settings" style="display:none">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7z" stroke="#333" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06A2 2 0 1 1 3.28 16.9l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09c.7 0 1.3-.39 1.51-1a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06c.48.48 1.12.76 1.82.76H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09c0 .6.28 1.14.76 1.52l.06.06A2 2 0 1 1 18.7 8.28l-.06.06c-.48.48-.76 1.12-.76 1.82V11a1.65 1.65 0 0 0 1.51 1H21a2 2 0 1 1 0 4h-.09c-.6 0-1.14.28-1.52.76l-.06.06" stroke="#333" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
  
        <!-- mobile hamburger -->
        <button id="btnHamburger" class="icon-btn hamburger" aria-expanded="false" aria-label="Menu" title="Menu">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none"><path d="M3 6h18M3 12h18M3 18h18" stroke="#111" stroke-width="1.6" stroke-linecap="round"/></svg>
        </button>
      </div> <!-- sh-right -->
    </div> <!-- sh-top -->
  
    <!-- mobile panel: BRAND + NAV ONLY (no account actions here) -->
   
   
    <div id="mobileMenu" class="mobile-panel" aria-hidden="true">
      <div class="inner" role="menu" aria-label="Mobile navigation">
        <div class="brand-row">
          <span style="font-size:20px">üìö</span>
          <div style="font-weight:700">LearningHub</div>
        </div>
        <a href="admin_dashboard.html" class="mobile-nav-link admin-link">Dashboard</a>
        <a href="index.html" class="mobile-nav-link">Lessons</a>
        <a href="leaderboard.html" class="mobile-nav-link">Leaderboard</a>
        <a href="history.html" class="mobile-nav-link">History</a>
        <a href="story.html" class="mobile-nav-link ">Stories</a>
        <a href="games.html" class="mobile-nav-link">Games</a>
        <a href="admin_users.html" class="mobile-nav-link admin-link">Users</a>
        <a href="helpCenter.html" class="mobile-nav-link">Helper</a>
      </div>
    </div>
  
    <!-- settings dropdown (opened by the gear button; gear visible on mobile/tablet only) -->
    <div id="settingsDropdown" class="settings-dropdown" aria-hidden="true">
      <div class="inner" role="menu">
        <button id="sLogout" class="settings-item"><span class="icon">üö™</span> Logout</button>
        <button id="sBalance" class="settings-item"><span class="icon">üí∞</span> Balance</button>
        <button id="sConvert" class="settings-item"><span class="icon">üîÅ</span> Convert Points</button>
        <button id="sChecking" class="settings-item"><span class="icon">‚úÖ</span> Checking</button>
  
        <div class="divider"></div>
  
        <button id="sEditProfile" class="settings-item"><span class="icon">‚úèÔ∏è</span> Edit Profile</button>
        <div style="display:flex;gap:8px;padding:4px 4px;align-items:center">
          <button id="langEng" class="small-btn" style="flex:1">ENG</button>
          <button id="langSom" class="small-btn" style="flex:1">SOM</button>
        </div>
  
        <div class="divider"></div>
  
        <button id="sAddFolder" class="settings-item"><span class="icon">‚ûï</span> + Add Folder</button>
        <button id="sRecycle" class="settings-item"><span class="icon">üóëÔ∏è</span> Recycle Bin</button>
      </div>
    </div>
  </header>
  
  <!-- modal root used by fallback modals -->
  <div id="modalRoot" style="display:none"></div>


<main class="container">
  <div class="card">
    <div class="topbar">
      <div style="flex:1">
        <div class="crumbs" id="breadcrumbs">Home</div>
        <h2 id="pageTitle">Folders</h2>
      </div>
      <div style="width:260px;text-align:right" id="rightHeader"></div>
    </div>

    <div id="contentArea"></div>
  </div>
</main>


<script>
/* ===================== CONFIG & HELPERS ===================== */
const API_BASE = (window.Auth && window.Auth.apiBase) ? window.Auth.apiBase : 'http://localhost:4000';
const QUESTION_SECONDS = 20;

function getToken(){ return (window.Auth && window.Auth.getToken) ? window.Auth.getToken() : localStorage.getItem('token'); }
function getUser(){ return (window.Auth && window.Auth.getUser) ? window.Auth.getUser() : (()=>{ const s=localStorage.getItem('user'); return s?JSON.parse(s):null; })(); }
function isAdmin(){ const u=getUser(); return u && u.role==='admin'; }
function authHeaders(json=true){ const t=getToken(); const h = {}; if (t) h['Authorization']='Bearer '+t; if (json) h['Content-Type']='application/json'; return h; }

async function fetchJson(path, opts={}) {
  try {
    const url = path.startsWith('http') ? path : ( (typeof API_BASE === 'string' && API_BASE) ? API_BASE + path : path );
    const res = await fetch(url, opts);
    const text = await res.text();
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch(e) { data = null; }
    if (!res.ok) {
      return { ok:false, status: res.status, error: (data && (data.error||data.message)) ? (data.error||data.message) : res.statusText, data, rawText: text };
    }
    return { ok:true, status: res.status, data, rawText: text };
  } catch (err) {
    // network-level failure (connection refused, DNS, CORS preflight blocked)
    return { ok:false, error: err.message || 'Network error' };
  }
}


/* ===================== I18N ===================== */
function getLang(){ return localStorage.getItem('lang') || 'en'; }
function setLang(l){ localStorage.setItem('lang', l === 'som' ? 'som' : 'en'); applyNavUI(); renderAfterLangChange(); }
function tLocalized(obj){
  const lang = getLang();
  if (!obj) return '';
  if (typeof obj === 'string') return obj;
  if (typeof obj === 'object') return (lang === 'som' ? (obj.som || obj.en) : (obj.en || obj.som || ''));
  return '';
}

/* ===================== STATE ===================== */
let treeCache = [];
let currentFolderId = null;
let pathStack = [];

/* ===================== UI REFS ===================== */
const contentArea = document.getElementById('contentArea');
const breadcrumbsEl = document.getElementById('breadcrumbs');
const pageTitleEl = document.getElementById('pageTitle');
const rightHeaderEl = document.getElementById('rightHeader');
const modalRoot = document.getElementById('modalRoot');

/* ===================== MODAL HELPERS ===================== */
function showModal(html){
  modalRoot.innerHTML = `<div class="modal-backdrop" role="dialog" aria-modal="true"><div class="modal">${html}</div></div>`;
  modalRoot.style.display = 'block';
}
function closeModal(){ modalRoot.innerHTML = ''; modalRoot.style.display = 'none'; }

/* require login */
function requireLoginModal(message = 'Please log in to continue') {
  const html = `
    <h3>Login required</h3>
    <p class="muted-note">${escapeHtml(message)}</p>
    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="modalLoginBtn">Login</button>
      <button id="modalCloseBtn" class="btn-ghost">Close</button>
    </div>
  `;
  showModal(html);
  document.getElementById('modalCloseBtn').onclick = closeModal;
  document.getElementById('modalLoginBtn').onclick = async () => {
    closeModal();
    try { await document.getElementById('btn-login').onclick(); } catch(e){ if (e && e.message) alert('Login failed: '+e.message); }
  };
}


/* ===================== UTILITIES ===================== */
function escapeHtml(s){ if (s === 0) return '0'; if (!s) return ''; return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

function pickIconForName(name){
  if (!name) return 'üìÅ';
  const n = name.toLowerCase();
  if (n.includes('math') || n.includes('xisaab')) return 'üßÆ';
  if (n.includes('computer')||n.includes('cs')||n.includes('program')||n.includes('kombuter')) return 'üíª';
  if (n.includes('network')) return 'üåê';
  if (n.includes('basic')||n.includes('aas')) return 'üî∞';
  if (n.includes('advanced')||n.includes('mediate')||n.includes('horumarsan')) return 'üöÄ';
  if (n.includes('science')) return 'üî¨';
  if (n.includes('english')||n.includes('language')) return 'üìö';
  return 'üìÅ';
}

async function syncFavoritesFromServer(resp = null) {
  function extractFavs(obj) {
    if (!obj) return null;
    if (Array.isArray(obj.favorites)) return obj.favorites.map(String);
    if (obj.data && Array.isArray(obj.data.favorites)) return obj.data.favorites.map(String);
    if (obj.data && obj.data.user && Array.isArray(obj.data.user.favorites)) return obj.data.user.favorites.map(String);
    if (obj.user && Array.isArray(obj.user.favorites)) return obj.user.favorites.map(String);
    if (obj.data && obj.data.favorites && Array.isArray(obj.data.favorites)) return obj.data.favorites.map(String);
    return null;
  }

  window.userFavorites = window.userFavorites || [];

  try {
    const fromResp = extractFavs(resp);
    if (fromResp) {
      window.userFavorites = fromResp;
      // persist
      localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites));
      return window.userFavorites;
    }

    if (!getToken()) { 
      window.userFavorites = []; 
      localStorage.removeItem('userFavorites');
      return window.userFavorites; 
    }

    let ru = await fetchJson('/api/lessons/users/me', { headers: authHeaders(), method: 'GET' });
    if (!ru || !ru.ok) {
      ru = await fetchJson('/api/users/me', { headers: authHeaders(), method: 'GET' });
    }

    const favs = extractFavs(ru) || extractFavs((ru && ru.data) ? ru.data : null);
    if (favs) {
      window.userFavorites = favs;
    } else if (ru && ru.ok && ru.data && ru.data.user && Array.isArray(ru.data.user.favorites)) {
      window.userFavorites = ru.data.user.favorites.map(String);
    } else {
      window.userFavorites = window.userFavorites || [];
    }

    // persist the result (even if empty) as a fast local fallback
    localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites));

  } catch (e) {
    console.warn('syncFavoritesFromServer failed', e);
    window.userFavorites = window.userFavorites || [];
    // keep whatever local value existed
    localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites));
  }

  return window.userFavorites;
}


async function openFavoritesModal(){
  if (!getToken()) return requireLoginModal('Log in to view favorites.');

  try {
    // ensure we have up-to-date favorites
    await syncFavoritesFromServer();

    const favs = Array.isArray(window.userFavorites) ? window.userFavorites.map(String) : [];

    let html = `<h3>Your Favorites</h3>`;
    if (favs.length === 0) {
      html += `<div class="muted-note">You haven't favorited any lessons yet.</div>`;
      html += `<div style="margin-top:10px"><button id="closeFavs" class="btn-ghost">Close</button></div>`;
      showModal(html);
      document.getElementById('closeFavs').onclick = closeModal;
      return;
    }

    // fetch lesson details in parallel
    const fetches = favs.map(id => fetchJson('/api/lessons/' + encodeURIComponent(id), { headers: authHeaders(), method: 'GET' }));
    const results = await Promise.all(fetches);

    html += `<div style="max-height:55vh;overflow:auto">`;
    results.forEach((res) => {
      if (!res || !res.ok || !res.data || !res.data.lesson) return;
      const L = res.data.lesson;
      const title = (L.title && L.title.en) ? L.title.en : (typeof L.title === 'string' ? L.title : 'Untitled');
      html += `<div style="padding:8px;border-bottom:1px solid #eee">
        <strong>${escapeHtml(title)}</strong>
        <div class="muted-note" style="margin-top:6px">By: ${escapeHtml(L.author && L.author.fullName ? L.author.fullName : (L.authorId?String(L.authorId):'‚Äî'))} ¬∑ Views: ${L.viewsCount||0}</div>
        <div style="margin-top:6px">
          <button class="small-btn open-fav" data-id="${escapeHtml(L._id)}">Open</button>
          <button class="small-btn remove-fav" data-id="${escapeHtml(L._id)}">Remove</button>
        </div>
      </div>`;
    });
    html += `</div>`;
    html += `<div style="margin-top:10px"><button id="closeFavs" class="btn-ghost">Close</button></div>`;
    showModal(html);

    document.getElementById('closeFavs').onclick = closeModal;

    // handlers use event.currentTarget to avoid closure issues
    document.querySelectorAll('.open-fav').forEach(btn => {
      btn.addEventListener('click', async (ev) => {
        const id = ev.currentTarget.dataset.id;
        closeModal();
        await viewLesson(id);
      });
    });

  
        // ---- replace existing remove-fav handler with this robust version ----
        document.querySelectorAll('.remove-fav').forEach(btn => {
      btn.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        const id = ev.currentTarget.dataset.id;
        if (!id) return alert('Missing lesson id');

        // optimistic UI: disable button while request in-flight
        btn.disabled = true;
        try {
          const r = await fetchJson('/api/lessons/' + encodeURIComponent(id) + '/favorite', { method:'DELETE', headers: authHeaders() });
          console.log('remove favorite response', r);

          if (!r || !r.ok) {
            return alert('Remove failed: ' + (r && r.error ? r.error : 'Server error'));
          }

          // helper to extract favorites array from many possible shapes
          function extractFavs(o){
            if (!o) return null;
            if (Array.isArray(o.favorites)) return o.favorites.map(String);
            if (o.data && Array.isArray(o.data.favorites)) return o.data.favorites.map(String);
            if (o.data && o.data.user && Array.isArray(o.data.user.favorites)) return o.data.user.favorites.map(String);
            if (o.user && Array.isArray(o.user.favorites)) return o.user.favorites.map(String);
            return null;
          }

          // prefer server-returned favorites if present
          let favs = extractFavs(r) || extractFavs(r.data) || extractFavs(r.user);

          if (!favs) {
            // server didn't include favorites ‚Äî re-sync from server to be authoritative
            favs = await syncFavoritesFromServer(r);
          } else {
            // normalize to strings and write into window.userFavorites
            window.userFavorites = favs.map(String);
          }

          // persist locally so refresh/back keeps state
          try { localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites || [])); } catch(e){ console.warn('persist favs failed', e); }

          // refresh folder/lesson UI to reflect removed favorite
          await loadTree();

          // Re-open modal so user sees updated list (close then reopen)
          // closeModal might be your modal close function; ensure it exists
          closeModal();
          openFavoritesModal();

        } catch (err) {
          console.warn('remove-fav handler error', err);
          alert('Remove failed');
        } finally {
          btn.disabled = false;
        }
      });
    });

  } catch (e) {
    console.warn('openFavoritesModal error', e);
    alert('Failed to load favorites');
  }
}


/* ================= ICON OPTIONS (emoji / svg) ================ */
const ICON_OPTIONS = [
  { key:'computer', label:'Computer', icon:'üíª' },
  { key:'man', label:'Man', icon:'üë®' },
  { key:'woman', label:'Woman', icon:'üë©' },
  { key:'beginner', label:'Beginner', icon:'üî∞' },
  { key:'moderate', label:'Moderate', icon:'‚öñÔ∏è' },
  { key:'advanced', label:'Advanced', icon:'üöÄ' },
  { key:'mobile', label:'Mobile', icon:'üì±' },
  { key:'city', label:'City', icon:'üèôÔ∏è' },
  { key:'world', label:'World', icon:'üåç' },
  { key:'network', label:'Network', icon:'üåê' },
  { key:'geography', label:'Geography', icon:'üó∫Ô∏è' },
  { key:'tools', label:'Tools', icon:'üß∞' },
  { key:'code', label:'Code', icon:'üíª' },
  { key:'subjects', label:'Subjects', icon:'üìö' },
  { key:'language', label:'Language', icon:'üó£Ô∏è' },
  { key:'item', label:'Item', icon:'üì¶' },
  { key:'shop', label:'Shop', icon:'üè¨' },
  { key:'folder', label:'Folder', icon:'üìÅ' },
  { key:'gallery', label:'Gallery', icon:'üñºÔ∏è' },
  { key:'audio', label:'Audio', icon:'üîä' },
  { key:'video', label:'Video', icon:'üé¨' },
  { key:'window', label:'Window', icon:'ü™ü' }
];

/* Count lessons recursively inside a folder node */
function countLessonsRecursive(node){
  if (!node) return 0;
  let c = Array.isArray(node.lessons) ? node.lessons.length : 0;
  if (Array.isArray(node.children)) {
    node.children.forEach(child => { c += countLessonsRecursive(child); });
  }
  return c;
}

/* ===================== RENDERERS ===================== */

/* Breadcrumbs builder + clickable */
function renderBreadcrumbs(){
  const parts = [{ label:'Home', id: null }, ...pathStack.map(p => ({ label: tLocalized(p.name) || (typeof p.name === 'string' ? p.name : ''), id: p._id }))];
  // if we're viewing a lesson, pageTitle already is lesson; breadcrumbs built elsewhere on lesson view
  breadcrumbsEl.innerHTML = '';
  parts.forEach((p,i)=>{
    const a = document.createElement('a');
    a.innerText = p.label || 'Home';
    a.href = 'javascript:void(0)';
    a.onclick = async () => {
      if (!p.id) { currentFolderId = null; pathStack = []; await loadTree(); return; }
      currentFolderId = p.id;
      await loadTree();
    };
    breadcrumbsEl.appendChild(a);
    if (i < parts.length - 1) {
      const sep = document.createTextNode(' / ');
      breadcrumbsEl.appendChild(sep);
    }
  });
}

/* Header update includes Back button and Take Test when not admin */
function updateHeaderForFolder(folderNode){
  // build pathStack if not present
  renderBreadcrumbs();
  pageTitleEl.innerText = pathStack.length ? (tLocalized(pathStack[pathStack.length-1].name) || pathStack[pathStack.length-1].name) : 'Folders';
  rightHeaderEl.innerHTML = '';

  if (pathStack.length > 0) {
    const back = document.createElement('button');
    back.className = 'small-btn';
    back.innerText = 'Back';
    back.onclick = async () => {
      if (pathStack.length <= 1) {
        currentFolderId = null;
      } else {
        const parent = pathStack[pathStack.length - 2];
        currentFolderId = parent ? parent._id : null;
      }
      await loadTree();
    };
    rightHeaderEl.appendChild(back);
  }

  if (isAdmin()) {
    const addSub = document.createElement('button'); addSub.className='small-btn'; addSub.innerText = '+ Subfolder';
    addSub.onclick = ()=> openAddFolderModal(currentFolderId);
    const addLesson = document.createElement('button'); addLesson.className='small-btn'; addLesson.innerText = '+ Lesson';
    addLesson.onclick = ()=> openAddLessonModal(currentFolderId);
    const addTest = document.createElement('button'); addTest.className='small-btn'; addTest.innerText = '+ Test';
    addTest.onclick = ()=> openAddTestModal(currentFolderId, null);
    rightHeaderEl.appendChild(addSub);
    rightHeaderEl.appendChild(addLesson);
    rightHeaderEl.appendChild(addTest);
  } else {
    // Favorites button (for any logged-in user)
    const favBtnHeader = document.createElement('button');
    favBtnHeader.className = 'small-btn';
    favBtnHeader.innerText = '‚òÖ Favorites';
    favBtnHeader.onclick = () => {
      if (!getToken()) return requireLoginModal('Log in to view favorites.');
      openFavoritesModal();
    };
    rightHeaderEl.appendChild(favBtnHeader);

    // Take Test button
    const takeTestBtn = document.createElement('button'); takeTestBtn.className='small-btn'; takeTestBtn.innerText = 'Take Test';
    takeTestBtn.onclick = ()=> {
      if (!getToken()) return requireLoginModal('Log in to take tests.');
      openTakeTest(currentFolderId, null);
    };
    rightHeaderEl.appendChild(takeTestBtn);
  }

}

/* Root folders render: show recursive lesson count */
function renderRootFolders(folders){
  contentArea.innerHTML = '';

  // small toolbar: Favorites quick open (visible to logged-in users)
  const toolbar = document.createElement('div');
  toolbar.style.display = 'flex';
  toolbar.style.justifyContent = 'flex-end';
  toolbar.style.marginBottom = '8px';

  const favQuick = document.createElement('button');
  favQuick.className = 'small-btn';
  favQuick.innerText = '‚òÖ Favorites';
  favQuick.onclick = () => {
    if (!getToken()) return requireLoginModal('Log in to view favorites.');
    openFavoritesModal();
  };
  toolbar.appendChild(favQuick);
  contentArea.appendChild(toolbar);

  if (!folders || folders.length === 0){
    const empty = document.createElement('div');
    empty.className = 'muted';
    empty.innerText = 'No folders yet. Admins can add folders using "+ Add Folder".';
    contentArea.appendChild(empty);
    return;
  }

  const grid = document.createElement('div');
  grid.className = 'folders-grid';

  folders.forEach(folder => {
    const fc = document.createElement('div');
    fc.className = 'folder-card';
    // clicking card opens folder but ignore button clicks
    fc.onclick = (e) => { if (e.target.tagName === 'BUTTON') return; openFolder(folder._id); };

    // meta (icon + title)
    const meta = document.createElement('div');
    meta.className = 'meta';

    const icon = document.createElement('div');
    icon.className = 'folder-icon';
    icon.innerText = (folder.icon && folder.icon.length <= 2) ? folder.icon : pickIconForName(tLocalized(folder.name) || (typeof folder.name === 'string' ? folder.name : ''));

    const displayName = tLocalized(folder.name) || (typeof folder.name === 'string' ? folder.name : '');
    const totalLessons = countLessonsRecursive(folder);
    const tit = document.createElement('div');
    tit.innerHTML = `<div style="font-weight:700">${escapeHtml(displayName)}</div><div class="muted-note">${totalLessons} lessons ¬∑ ${ (folder.children||[]).length } subfolders</div>`;

    meta.append(icon, tit);

    // actions
    const actionsWrap = document.createElement('div');
    actionsWrap.style.display = 'flex';
    actionsWrap.style.gap = '6px';

    if (isAdmin()){
      const editBtn = document.createElement('button');
      editBtn.className = 'small-btn';
      editBtn.innerText = 'Edit';
      editBtn.onclick = (ev) => { ev.stopPropagation(); openEditFolderModal(folder); };

      const delBtn = document.createElement('button');
      delBtn.className = 'small-btn';
      delBtn.innerText = folder.isDeleted ? 'Permanently Delete' : 'Delete';
      delBtn.onclick = async (ev) => {
        ev.stopPropagation();
        if (folder.isDeleted) {
          if (!confirm('Perm delete?')) return;
          await fetchJson('/api/lessons/folders/' + folder._id + '?permanent=1', { method:'DELETE', headers: authHeaders() });
        } else {
          if (!confirm('Soft-delete folder?')) return;
          await fetchJson('/api/lessons/folders/' + folder._id, { method:'DELETE', headers: authHeaders() });
        }
        await loadTree();
      };

      actionsWrap.append(editBtn, delBtn);
    } else {
      // non-admin: Open + Take Test + (Favorites quick access is in toolbar)
      const openBtn = document.createElement('button');
      openBtn.className = 'small-btn';
      openBtn.innerText = 'Open';
      openBtn.onclick = (ev) => { ev.stopPropagation(); openFolder(folder._id); };

      const takeBtn = document.createElement('button');
      takeBtn.className = 'small-btn';
      takeBtn.innerText = 'Take Test';
      takeBtn.onclick = (ev) => { ev.stopPropagation(); if (!getToken()) return requireLoginModal('Log in to take tests.'); openTakeTest(folder._id, null); };

      actionsWrap.append(openBtn, takeBtn);
    }

    const bottom = document.createElement('div');
    bottom.style.display = 'flex';
    bottom.style.justifyContent = 'space-between';
    bottom.style.alignItems = 'center';
    bottom.append(meta, actionsWrap);

    fc.appendChild(bottom);
    grid.appendChild(fc);
  });

  contentArea.appendChild(grid);
}



/* Folder view includes children and lessons. Subfolder cards show recursive lesson counts; removed test buttons for non-admins */
function renderFolderView(folderNode){
  contentArea.innerHTML = '';

  const subHeader = document.createElement('div'); subHeader.style.marginBottom='10px';
  const subLabel = document.createElement('div'); subLabel.className='muted'; subLabel.innerText = 'Subfolders';
  subHeader.appendChild(subLabel);
  contentArea.appendChild(subHeader);

  const subGrid = document.createElement('div'); subGrid.className='folders-grid';
  (folderNode.children || []).forEach(child=>{
    const fc = document.createElement('div'); fc.className='folder-card';
    fc.onclick = ()=> openFolder(child._id);
    const childIcon = child.icon && child.icon.length<=2 ? child.icon : pickIconForName(tLocalized(child.name) || (typeof child.name === 'string' ? child.name : ''));
    const childName = tLocalized(child.name) || (typeof child.name === 'string' ? child.name : '');
    const totalLessons = countLessonsRecursive(child);
    fc.innerHTML = `<div style="display:flex;align-items:center;gap:10px"><div class="folder-icon">${escapeHtml(childIcon)}</div><div><div style="font-weight:700">${escapeHtml(childName)}</div><div class="muted-note">${totalLessons} lessons</div></div></div>`;
    if (isAdmin()){
      const footer = document.createElement('div'); footer.style.display='flex'; footer.style.justifyContent='space-between'; footer.style.marginTop='8px';
      const left = document.createElement('div');
      const right = document.createElement('div'); right.style.display='flex'; right.style.gap='6px';
      const editBtn = document.createElement('button'); editBtn.className='small-btn'; editBtn.innerText='Edit';
      editBtn.onclick = (ev)=>{ ev.stopPropagation(); openEditFolderModal(child); };
      const delBtn = document.createElement('button'); delBtn.className='small-btn'; delBtn.innerText = child.isDeleted ? 'Permanently Delete':'Delete';
      delBtn.onclick = async (ev)=>{ ev.stopPropagation(); if (child.isDeleted){ if (!confirm('Perm delete?')) return; await fetchJson('/api/lessons/folders/'+child._id+'?permanent=1',{ method:'DELETE', headers:authHeaders() }); } else { if (!confirm('Soft-delete?')) return; await fetchJson('/api/lessons/folders/'+child._id,{ method:'DELETE', headers:authHeaders() }); } await loadTree(); };
      right.append(editBtn, delBtn);
      footer.append(left,right);
      fc.appendChild(footer);
    } else {
      // add Take Test for subfolders (non-admin)
      const footer = document.createElement('div'); footer.style.display='flex'; footer.style.justifyContent='flex-end'; footer.style.marginTop='8px';
      const takeBtn = document.createElement('button'); takeBtn.className='small-btn'; takeBtn.innerText='Take Test';
      takeBtn.onclick = (ev)=> { ev.stopPropagation(); if (!getToken()) return requireLoginModal('Log in to take tests.'); openTakeTest(child._id, null); };
      footer.appendChild(takeBtn);
      fc.appendChild(footer);
    }

    subGrid.appendChild(fc);
  });
  contentArea.appendChild(subGrid);

  const lessonsHeader = document.createElement('div'); lessonsHeader.style.marginTop='16px';
  const lessonsLabel = document.createElement('div'); lessonsLabel.className='muted'; lessonsLabel.innerText = 'Lessons';
  lessonsHeader.appendChild(lessonsLabel);
  contentArea.appendChild(lessonsHeader);

  const lessonsGrid = document.createElement('div'); lessonsGrid.className='lessons-grid';
  (folderNode.lessons || []).forEach(ls=>{
    const lc = document.createElement('div'); lc.className='lesson-card';
    const title = tLocalized(ls.title) || (ls.title && ls.title.en) || (typeof ls.title === 'string' ? ls.title : 'Untitled');
    const preview = tLocalized(ls.content) || (ls.content && ls.content.en) || '';
    lc.innerHTML = `<div><h4>${escapeHtml(title)}</h4><p>${escapeHtml(preview.slice(0,120))}</p></div>`;
    lc.onclick = ()=> viewLesson(ls._id);

    const actions = document.createElement('div'); actions.className='card-actions';
    if (isAdmin()){
      const edit = document.createElement('button'); edit.className='small-btn'; edit.innerText='Edit'; edit.onclick = (ev)=> { ev.stopPropagation(); openEditLessonModal(ls._id); };
      const del = document.createElement('button'); del.className='small-btn'; del.innerText = ls.isDeleted ? 'Delete Perm' : 'Delete'; del.onclick = async (ev)=>{ ev.stopPropagation(); if (!confirm('Delete lesson?')) return; if (ls.isDeleted) await fetchJson('/api/lessons/'+ls._id+'?permanent=1',{ method:'DELETE', headers: authHeaders() }); else await fetchJson('/api/lessons/'+ls._id,{ method:'DELETE', headers: authHeaders() }); await loadTree(); };
      const addTestBtn = document.createElement('button'); addTestBtn.className='small-btn'; addTestBtn.innerText='Add Test'; addTestBtn.onclick = (ev)=>{ ev.stopPropagation(); openAddTestModal(currentFolderId, ls._id); };
      const questionsBtn = document.createElement('button'); questionsBtn.className='small-btn'; questionsBtn.innerText='Questions'; questionsBtn.onclick = (ev)=>{ ev.stopPropagation(); openLessonQuestionsModal(ls._id); };
      actions.append(edit, del, addTestBtn, questionsBtn);
    } else {
      const view = document.createElement('button'); view.className='small-btn'; view.innerText='View';
      view.onclick = (ev)=> { ev.stopPropagation(); viewLesson(ls._id); };

      const testBtn = document.createElement('button'); testBtn.className='small-btn'; testBtn.innerText='Test';
      testBtn.onclick = (ev) => { ev.stopPropagation(); if (!getToken()) return requireLoginModal('Log in to take tests.'); openTakeTest(null, ls._id); };

      // favorite small toggle in list
      const favBtnList = document.createElement('button'); favBtnList.className = 'small-btn';
      const isFav = (window.userFavorites || []).map(String).includes(String(ls._id));
      favBtnList.innerText = isFav ? '‚òÖ' : '‚òÜ';
      favBtnList.title = isFav ? 'Remove favorite' : 'Add favorite';
      favBtnList.onclick = async (ev) => {
        ev.stopPropagation();
        if (!getToken()) return requireLoginModal('Log in to favorite lessons.');
        try {
          let rr;
          if ((window.userFavorites || []).map(String).includes(String(ls._id))) {
            rr = await fetchJson('/api/lessons/' + encodeURIComponent(ls._id) + '/favorite', { method:'DELETE', headers: authHeaders() });
          } else {
            rr = await fetchJson('/api/lessons/' + encodeURIComponent(ls._id) + '/favorite', { method:'POST', headers: authHeaders() });
          }
          if (!rr || !rr.ok) return alert('Favorite action failed: ' + (rr && rr.error ? rr.error : ''));
          if (Array.isArray(rr.favorites)) {
            window.userFavorites = rr.favorites.map(String);
          } else if (rr.data && Array.isArray(rr.data.favorites)) {
            window.userFavorites = rr.data.favorites.map(String);
          } else {
            await syncFavoritesFromServer(rr);
          }
          // update UI quickly
          const now = (window.userFavorites || []).map(String).includes(String(ls._id));
          favBtnList.innerText = now ? '‚òÖ' : '‚òÜ';
          favBtnList.title = now ? 'Remove favorite' : 'Add favorite';
          await loadTree();
        } catch (e) {
          console.warn('fav list toggle failed', e);
          alert('Favorite failed');
        }
      };

      actions.append(view, testBtn, favBtnList);
    }

    lc.appendChild(actions);
    lessonsGrid.appendChild(lc);
  });
  contentArea.appendChild(lessonsGrid);
}

/* ===================== DATA LOAD ===================== */
async function loadTree(){
// FAST local fallback: populate window.userFavorites from localStorage so UI shows favorites immediately
window.userFavorites = window.userFavorites || [];
  try {
    const saved = localStorage.getItem('userFavorites');
    if (saved) {
      const parsed = JSON.parse(saved);
      if (Array.isArray(parsed)) window.userFavorites = parsed.map(String);
    }
  } catch (e) {
    console.warn('Failed to read saved favorites from localStorage', e);
    window.userFavorites = window.userFavorites || [];
  }

  // fetch tree (server)
  const r = await fetchJson('/api/lessons/tree', { headers: authHeaders(), method: 'GET' });

  // then try to refresh favorites from server (this will overwrite local fallback)
  if (getToken()) {
    try {
      // try lessons-scoped users endpoint first
      let ru = await fetchJson('/api/lessons/users/me', { headers: authHeaders(), method: 'GET' });
      if (!ru || !ru.ok) {
        ru = await fetchJson('/api/users/me', { headers: authHeaders(), method: 'GET' });
      }
      // normalize shapes
      const userObj = (ru && ru.data && ru.data.user) ? ru.data.user : (ru && ru.user ? ru.user : (ru && ru.data ? ru.data : null));
      if (userObj && Array.isArray(userObj.favorites)) {
        window.userFavorites = userObj.favorites.map(String);
        localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites));
      } else {
        // fallback: call syncFavoritesFromServer which handles many shapes and persists
        await syncFavoritesFromServer(ru);
      }
    } catch (e) {
      console.warn('Could not load user favorites:', e);
      // keep localStorage fallback
      window.userFavorites = window.userFavorites || [];
    }
  } else {
    window.userFavorites = [];
    localStorage.removeItem('userFavorites');
  }

  // ... continue with your existing handling of r (tree response)
  if (!r.ok) {
    contentArea.innerHTML = '<div class="muted">Failed to load folders: '+(r.error||'')+'</div>';
    return;
  }
  // rest of your existing loadTree logic follows...
  treeCache = r.data.tree || [];
  if (!currentFolderId) {
    pathStack = [];
    renderRootFolders(treeCache);
    updateHeaderForFolder(null);
  } else {
    const node = findNodeById(currentFolderId, treeCache);
    if (!node) {
      currentFolderId = null;
      pathStack = [];
      renderRootFolders(treeCache);
      updateHeaderForFolder(null);
      return;
    }
    pathStack = buildPathToNode(node._id, treeCache);
    updateHeaderForFolder(node);
    renderFolderView(node);
  }
}

function findNodeById(id, nodes){
  for (const n of nodes){
    if (String(n._id) === String(id)) return n;
    if (n.children && n.children.length){
      const found = findNodeById(id, n.children);
      if (found) return found;
    }
  }
  return null;
}
function buildPathToNode(id, nodes, acc=[]){
  for (const n of nodes){
    if (String(n._id) === String(id)) return [...acc, n];
    if (n.children && n.children.length){
      const res = buildPathToNode(id, n.children, [...acc, n]);
      if (res) return res;
    }
  }
  return null;
}
async function openFolder(id){ currentFolderId = id; await loadTree(); }
async function goHome(){ currentFolderId = null; pathStack = []; await loadTree(); }

/* ===================== FOLDER / LESSON ACTIONS (unchanged) ===================== */
function openAddFolderModal(parentId = null){
  if (!getToken()) return requireLoginModal('You must be logged in as an admin to add folders.');
  if (!isAdmin()) return alert('Only admins may add folders.');
  const iconsHtml = ICON_OPTIONS.map(o => `<option value="${escapeHtml(o.icon)}">${escapeHtml(o.label)} ${escapeHtml(o.icon)}</option>`).join('');
  const html = `
    <h3>Add Folder${parentId ? ' (subfolder)' : ''}</h3>
    <label>Folder name ‚Äî English</label><input id="fldNameEn" placeholder="e.g. Math Basics">
    <label>Folder name ‚Äî Somali</label><input id="fldNameSom" placeholder="e.g. Aas-aaska Xisaabta (optional)">
    <label>Pick icon (emoji) or paste image URL</label>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="fldIconSelect">${iconsHtml}<option value="">-- custom / none --</option></select>
      <input id="fldIconUrl" placeholder="Or paste image URL (http...)" style="flex:1">
      <div id="fldIconPreview" style="width:44px;height:44px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:22px;background:#fff;border:1px solid #eee">üìÅ</div>
    </div>
    <div style="display:flex;gap:8px;margin-top:12px"><button id="createFolderBtn">Create</button><button id="cancelFolderBtn" class="btn-ghost">Cancel</button></div>
  `;
  showModal(html);

  const sel = document.getElementById('fldIconSelect');
  const urlInp = document.getElementById('fldIconUrl');
  const prev = document.getElementById('fldIconPreview');

  function updatePreview() {
    const emoji = sel.value;
    const url = urlInp.value.trim();
    if (url) {
      prev.style.backgroundImage = `url(${escapeHtml(url)})`;
      prev.style.backgroundSize = 'cover';
      prev.style.backgroundPosition = 'center';
      prev.innerText = '';
    } else if (emoji) {
      prev.style.backgroundImage = '';
      prev.innerText = emoji;
    } else {
      prev.style.backgroundImage = '';
      prev.innerText = 'üìÅ';
    }
  }

  sel.onchange = ()=> { if (sel.value) urlInp.value = ''; updatePreview(); };
  urlInp.oninput = ()=> { if (urlInp.value.trim()) sel.value = ''; updatePreview(); };

  document.getElementById('cancelFolderBtn').onclick = closeModal;
  document.getElementById('createFolderBtn').onclick = async ()=> {
    const nameEn = document.getElementById('fldNameEn').value.trim();
    const nameSom = document.getElementById('fldNameSom').value.trim();
    let icon = urlInp.value.trim() || sel.value || '';
    if (!nameEn) return alert('English name required');
    const namePayload = { en: nameEn };
    if (nameSom) namePayload.som = nameSom;
    const r = await fetchJson('/api/lessons/folders', { method:'POST', headers: authHeaders(), body: JSON.stringify({ name: namePayload, parentId, icon }) });
    if (!r.ok) return alert('Create failed: '+(r.error||''));
    closeModal();
    await loadTree();
    if (parentId) openFolder(parentId);
  };

  // init preview
  updatePreview();
}

function openEditFolderModal(folder){
  if (!getToken()) return requireLoginModal('You must be logged in as an admin to edit folders.');
  if (!isAdmin()) return alert('Only admins may edit folders.');
  const nameEn = (typeof folder.name === 'string') ? folder.name : (folder.name && folder.name.en ? folder.name.en : '');
  const nameSom = (typeof folder.name === 'object' && folder.name.som) ? folder.name.som : '';
  const currentIcon = folder.icon || '';
  const iconsHtml = ICON_OPTIONS.map(o => `<option value="${escapeHtml(o.icon)}" ${o.icon===currentIcon?'selected':''}>${escapeHtml(o.label)} ${escapeHtml(o.icon)}</option>`).join('');
  const html = `
    <h3>Edit Folder</h3>
    <label>Name ‚Äî English</label><input id="eNameEn" value="${escapeHtml(nameEn)}">
    <label>Name ‚Äî Somali</label><input id="eNameSom" value="${escapeHtml(nameSom)}">
    <label>Pick icon (emoji) or paste image URL</label>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="eIconSelect">${iconsHtml}<option value="">-- custom / none --</option></select>
      <input id="eIconUrl" placeholder="Or paste image URL (http...)" style="flex:1" value="${(currentIcon && currentIcon.startsWith('http'))?escapeHtml(currentIcon):''}">
      <div id="eIconPreview" style="width:44px;height:44px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:22px;background:#fff;border:1px solid #eee">${(!currentIcon || currentIcon.startsWith('http'))? 'üìÅ' : escapeHtml(currentIcon)}</div>
    </div>
    <div style="display:flex;gap:8px;margin-top:12px"><button id="saveFolderBtn">Save</button><button id="cancelFolderBtn" class="btn-ghost">Cancel</button></div>
  `;
  showModal(html);

  const sel = document.getElementById('eIconSelect');
  const urlInp = document.getElementById('eIconUrl');
  const prev = document.getElementById('eIconPreview');

  function updatePreview() {
    const emoji = sel.value;
    const url = urlInp.value.trim();
    if (url) {
      prev.style.backgroundImage = `url(${escapeHtml(url)})`;
      prev.style.backgroundSize = 'cover';
      prev.style.backgroundPosition = 'center';
      prev.innerText = '';
    } else if (emoji) {
      prev.style.backgroundImage = '';
      prev.innerText = emoji;
    } else {
      prev.style.backgroundImage = '';
      prev.innerText = 'üìÅ';
    }
  }

  sel.onchange = ()=> { if (sel.value) urlInp.value = ''; updatePreview(); };
  urlInp.oninput = ()=> { if (urlInp.value.trim()) sel.value = ''; updatePreview(); };

  document.getElementById('cancelFolderBtn').onclick = closeModal;
  document.getElementById('saveFolderBtn').onclick = async ()=> {
    const nameEnV = document.getElementById('eNameEn').value.trim();
    const nameSomV = document.getElementById('eNameSom').value.trim();
    const iconVal = urlInp.value.trim() || sel.value || '';
    if (!nameEnV) return alert('English name required');
    const namePayload = { en: nameEnV };
    if (nameSomV) namePayload.som = nameSomV;
    const r = await fetchJson('/api/lessons/folders/'+folder._id, { method:'PUT', headers: authHeaders(), body: JSON.stringify({ name: namePayload, icon: iconVal }) });
    if (!r.ok) return alert('Save failed: '+(r.error||''));
    closeModal();
    await loadTree();
  };

  // init preview
  if (currentIcon) {
    if (currentIcon.startsWith('http')) urlInp.value = currentIcon;
    else sel.value = currentIcon;
  }
  updatePreview();
}

function openAddLessonModal(folderId){
  if (!getToken()) return requireLoginModal('Please log in to add a lesson.');
  if (!isAdmin()) return alert('Only admins may add lessons.');
  const html = `
    <h3>Add Lesson</h3>
    <label>Title ‚Äî English</label><input id="lsTitleEn" placeholder="Lesson title">
    <label>Title ‚Äî Somali</label><input id="lsTitleSom" placeholder="Cinwaanka casharka (optional)">
    <label>Content ‚Äî English</label><textarea id="lsContentEn" rows="6" placeholder="Lesson content (text or html)"></textarea>
    <label>Content ‚Äî Somali</label><textarea id="lsContentSom" rows="6" placeholder="Qoraal (optional)"></textarea>
    <div style="display:flex;gap:8px;margin-top:12px"><button id="createLessonBtn">Create Lesson</button><button id="cancelLessonBtn" class="btn-ghost">Cancel</button></div>
  `;
  showModal(html);
  document.getElementById('cancelLessonBtn').onclick = closeModal;
  document.getElementById('createLessonBtn').onclick = async ()=>{
    const titleEn = document.getElementById('lsTitleEn').value.trim();
    const titleSom = document.getElementById('lsTitleSom').value.trim();
    // DO NOT trim content - preserve newlines exactly
    const contentEn = document.getElementById('lsContentEn').value;
    const contentSom = document.getElementById('lsContentSom').value;
    if (!titleEn) return alert('English title required');
    const payload = { title: { en: titleEn }, content: { en: contentEn }, folderId };
    if (titleSom) payload.title.som = titleSom;
    if (contentSom) payload.content.som = contentSom;
    const r = await fetchJson('/api/lessons', { method:'POST', headers: authHeaders(), body: JSON.stringify(payload) });
    if (!r.ok) return alert('Create failed: '+(r.error||''));
    closeModal();
    await loadTree();
    openFolder(folderId);
  };
}



async function openEditLessonModal(lessonId){
  if (!getToken()) return requireLoginModal('Please log in to edit lesson.');
  if (!isAdmin()) return alert('Only admins may edit lessons.');
  const r0 = await fetchJson('/api/lessons/'+lessonId, { headers: authHeaders() });
  if (!r0.ok) return alert('Failed to load lesson: '+(r0.error||''));
  const lesson = r0.data.lesson;
  const titleEn = (lesson.title && lesson.title.en) ? lesson.title.en : (typeof lesson.title === 'string' ? lesson.title : '');
  const titleSom = (lesson.title && lesson.title.som) ? lesson.title.som : '';
  const contentEn = (lesson.content && lesson.content.en) ? lesson.content.en : '';
  const contentSom = (lesson.content && lesson.content.som) ? lesson.content.som : '';
  const html = `
    <h3>Edit Lesson</h3>
    <label>Title ‚Äî English</label><input id="lsTitleEn" value="${escapeHtml(titleEn)}">
    <label>Title ‚Äî Somali</label><input id="lsTitleSom" value="${escapeHtml(titleSom)}">
    <label>Content ‚Äî English</label><textarea id="lsContentEn" rows="6">${escapeHtml(contentEn)}</textarea>
    <label>Content ‚Äî Somali</label><textarea id="lsContentSom" rows="6">${escapeHtml(contentSom)}</textarea>
    <div style="display:flex;gap:8px;margin-top:12px"><button id="saveLessonBtn">Save</button><button id="cancelLessonBtn" class="btn-ghost">Cancel</button></div>
  `;
  showModal(html);
  document.getElementById('cancelLessonBtn').onclick = closeModal;
  document.getElementById('saveLessonBtn').onclick = async ()=> {
  const tEn = document.getElementById('lsTitleEn').value.trim();
  const tSom = document.getElementById('lsTitleSom').value.trim();
  // DO NOT trim content here - preserve newlines inside
  const cEn = document.getElementById('lsContentEn').value;
  const cSom = document.getElementById('lsContentSom').value;
  if (!tEn) return alert('English title required');
  const payload = { title: { en: tEn }, content: { en: cEn } };
  if (tSom) payload.title.som = tSom;
  if (cSom) payload.content.som = cSom;
  const r = await fetchJson('/api/lessons/'+lessonId, { method:'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
  if (!r.ok) return alert('Save failed: '+(r.error||''));
  closeModal();
  await loadTree();
};

}

/* ===================== LESSON FULL VIEW ===================== */
async function viewLesson(id){
  if (!getToken()) return requireLoginModal('Please log in to view this lesson.');

  // 1) Load lesson
  const r = await fetchJson('/api/lessons/' + encodeURIComponent(id), { headers: authHeaders(), method: 'GET' });
  if (!r.ok) {
    if (r.status === 401 || r.status === 403) return requireLoginModal('You must be logged in (and authorized) to view this lesson.');
    return alert('Failed to load lesson: ' + (r.error || 'Server error'));
  }
  const lesson = r.data.lesson;

  // 2) Ensure we have the current user's favorites so favorite button state persists after refresh.
  // Try both possible endpoints (some setups have users route under /api/lessons/users/me)
  window.userFavorites = window.userFavorites || [];
  try {
    let ru = await fetchJson('/api/lessons/users/me', { headers: authHeaders(), method: 'GET' });
    if (!ru.ok) {
      // fallback to canonical users endpoint if available
      ru = await fetchJson('/api/users/me', { headers: authHeaders(), method: 'GET' });
    }
    if (ru.ok && ru.data && ru.data.user) {
      window.userFavorites = Array.isArray(ru.data.user.favorites) ? ru.data.user.favorites.map(String) : [];
    }
  } catch (e) {
    // ignore - we'll keep window.userFavorites as-is (at least an empty array)
    window.userFavorites = window.userFavorites || [];
  }

  // 3) Render UI immediately (fast)
  renderLessonView(lesson);

  // 4) Then POST a view increment (server will dedupe per-user when possible)
  // If the endpoint supports optional auth, it will count uniquely for logged-in users.
  try {
    const rv = await fetchJson('/api/lessons/' + encodeURIComponent(id) + '/view', { method: 'POST', headers: authHeaders() });
    if (rv && rv.ok && rv.data && rv.data.viewsCount !== undefined) {
      const el = document.getElementById('lessonViewsCount');
      if (el) el.innerText = String(rv.data.viewsCount);
    } else if (rv && rv.ok && rv.viewsCount !== undefined) {
      // in case server response shape differs slightly
      const el = document.getElementById('lessonViewsCount');
      if (el) el.innerText = String(rv.viewsCount);
    }
  } catch (e) {
    console.warn('view increment failed', e);
  }
}

/* NOTE: renderLessonView expects:
   - helpers: tLocalized, escapeHtml, authHeaders, getToken, isAdmin, openTakeTest, openEditLessonModal, openAddTestModal, openLessonQuestionsModal, closeModal, loadTree, goHome
   - global DOM elements: breadcrumbsEl, contentArea, pageTitleEl, rightHeaderEl (we avoid double title set)
*/
function renderLessonView(lesson){
  const lessonTitle = tLocalized(lesson.title) || (lesson.title && lesson.title.en) || 'Lesson';

  // breadcrumbs (clickable)
  breadcrumbsEl.innerHTML = '';
  const parts = [{ label:'Home', id: null }, ...pathStack.map(p => ({ label: tLocalized(p.name) || (typeof p.name === 'string' ? p.name : ''), id: p._id })), { label: lessonTitle, id: 'lesson:' + lesson._id }];
  parts.forEach((p,i) => {
    const a = document.createElement('a');
    a.innerText = p.label || 'Home';
    a.href = 'javascript:void(0)';
    a.onclick = async () => {
      if (!p.id) { currentFolderId = null; pathStack = []; await loadTree(); return; }
      if (String(p.id).startsWith('lesson:')) return; // already on lesson
      currentFolderId = p.id;
      await loadTree();
    };
    breadcrumbsEl.appendChild(a);
    if (i < parts.length - 1) breadcrumbsEl.appendChild(document.createTextNode(' / '));
  });

  // content: preserve newlines safely (escape HTML)
  const rawContent = (getLang() === 'som' ? (lesson.content && lesson.content.som) : (lesson.content && lesson.content.en)) || (lesson.content && lesson.content.en) || '';
  const safeContent = escapeHtml(rawContent).replace(/\n/g, '<br>');

  // admin actions HTML (if admin)
  const adminActions = isAdmin() ? `
    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="editLessonBtn" class="small-btn">Edit</button>
      <button id="deleteLessonBtn" class="small-btn">Delete</button>
      <button id="addTestToLesson" class="small-btn">Add Test</button>
      <button id="viewQuestionsBtn" class="small-btn">Questions</button>
    </div>` : '';

  // favorite button class determined from window.userFavorites
  window.userFavorites = window.userFavorites || [];
  const favOn = Array.isArray(window.userFavorites) && window.userFavorites.map(String).includes(String(lesson._id));
  const favClass = favOn ? 'fav-on' : 'fav-off';
  const favLabel = favOn ? '‚òÖ Favorited' : '‚òÜ Favorite';

  // render
  contentArea.innerHTML = `
    <div class="lesson-view">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
        <div style="flex:1">
          <h1 style="margin:0">${escapeHtml(lessonTitle)}</h1>
          <div class="muted-note" style="margin-top:6px">
            By: ${escapeHtml((lesson.author && lesson.author.fullName) ? lesson.author.fullName : (lesson.authorId ? String(lesson.authorId) : '‚Äî'))}
            ¬∑ ${lesson.createdAt ? new Date(lesson.createdAt).toLocaleString() : ''}
            ¬∑ Views: <span id="lessonViewsCount">${lesson.viewsCount != null ? String(lesson.viewsCount) : (Array.isArray(lesson.viewers) ? String(lesson.viewers.length) : '‚Äî')}</span>
          </div>
        </div>
        <div style="margin-left:12px;display:flex;flex-direction:column;gap:6px;align-items:flex-end">
          <button id="backToFolder" class="btn-ghost">Back</button>
          <button id="favoriteLessonBtn" class="small-btn ${favClass}" title="Toggle favorite" aria-pressed="${favOn}">${favLabel}</button>
        </div>
      </div>

      <div class="lesson-content" style="margin-top:12px;white-space:pre-wrap">${safeContent}</div>

      <div style="margin-top:12px">
        <button id="takeLessonTest" class="small-btn">Take Lesson Test</button>
      </div>

      ${adminActions}
    </div>
  `;

  // Back button
  document.getElementById('backToFolder').onclick = ()=> { if (!currentFolderId) goHome(); else loadTree(); };

  // Take test button
  document.getElementById('takeLessonTest').onclick = ()=> { if (!getToken()) return requireLoginModal('Log in to take tests.'); openTakeTest(null, lesson._id); };

  // Admin wiring
  if (isAdmin()){
    document.getElementById('editLessonBtn').onclick = ()=> openEditLessonModal(lesson._id);
    document.getElementById('deleteLessonBtn').onclick = async ()=> {
      if (!confirm('Delete this lesson?')) return;
      const r = await fetchJson('/api/lessons/' + encodeURIComponent(lesson._id), { method: 'DELETE', headers: authHeaders() });
      if (!r.ok) return alert('Delete failed: '+(r.error||''));
      alert('Deleted');
      if (currentFolderId) loadTree(); else goHome();
    };
    document.getElementById('addTestToLesson').onclick = ()=> openAddTestModal(currentFolderId, lesson._id);
    document.getElementById('viewQuestionsBtn').onclick = ()=> openLessonQuestionsModal(lesson._id);
  }

  // helper: extract favorites array out of many response shapes
  function extractFavsFromResp(obj) {
    if (!obj) return null;
    if (Array.isArray(obj.favorites)) return obj.favorites.map(String);
    if (obj.data && Array.isArray(obj.data.favorites)) return obj.data.favorites.map(String);
    if (obj.data && obj.data.user && Array.isArray(obj.data.user.favorites)) return obj.data.user.favorites.map(String);
    if (obj.user && Array.isArray(obj.user.favorites)) return obj.user.favorites.map(String);
    return null;
  }

  // Favorite toggle wiring (works for POST and DELETE endpoints)
  const favBtn = document.getElementById('favoriteLessonBtn');
  if (favBtn) {
    favBtn.onclick = async () => {
      if (!getToken()) return requireLoginModal('Log in to favorite lessons.');
      favBtn.disabled = true;
      try {
        const currentlyFav = (window.userFavorites || []).map(String).includes(String(lesson._id));
        // send request (POST=add, DELETE=remove)
        let r;
        if (currentlyFav) {
          r = await fetchJson('/api/lessons/' + encodeURIComponent(lesson._id) + '/favorite', { method: 'DELETE', headers: authHeaders() });
        } else {
          r = await fetchJson('/api/lessons/' + encodeURIComponent(lesson._id) + '/favorite', { method: 'POST', headers: authHeaders() });
        }

        // LOG response for debug (helps see exactly what backend returned)
        console.log('favorite toggle response for lesson', lesson._id, r);

        if (!r || !r.ok) {
          const errMsg = (r && r.error) ? r.error : 'Server error';
          favBtn.disabled = false;
          return alert('Failed to toggle favorite: ' + errMsg);
        }

        // Prefer server authoritative result:
        // 1) If response included favorites, use it.
        // 2) Otherwise, re-sync from server (guaranteed authoritative).
        let favsFromResp = extractFavsFromResp(r) || extractFavsFromResp(r.data) || extractFavsFromResp(r.user);
        if (favsFromResp) {
          window.userFavorites = favsFromResp;
        } else {
          // Force a fresh authoritative sync (this will fetch /api/lessons/users/me or /api/users/me)
          await syncFavoritesFromServer(r);
        }

        // persist to localStorage (useful on refresh/back)
        try { localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites || [])); } catch(e){ console.warn('persist favs failed', e); }

        // update the lesson favorite button UI according to new state
        const nowFav = (window.userFavorites || []).map(String).includes(String(lesson._id));
        if (nowFav) {
          favBtn.classList.remove('fav-off'); favBtn.classList.add('fav-on');
          favBtn.innerText = '‚òÖ Favorited';
          favBtn.setAttribute('aria-pressed', 'true');
        } else {
          favBtn.classList.remove('fav-on'); favBtn.classList.add('fav-off');
          favBtn.innerText = '‚òÜ Favorite';
          favBtn.setAttribute('aria-pressed', 'false');
        }

        // refresh tree/folder views so icons and header reflect favorite state
        await loadTree();

        // If a Favorites modal is open, refresh it quickly by closing + reopening (optional UX)
        // (detect by DOM presence of favorites modal elements if you have a modal id)
        // For simplicity, we'll not auto-reopen modal. User can re-open Favorites to verify.

      } catch (e) {
        console.warn('favorite toggle failed', e);
        alert('Favorite action failed');
      } finally {
        favBtn.disabled = false;
      }
    };
  }
}

/* ===================== QUESTIONS UI for a Lesson (ADMIN) ===================== */

/**
 * openLessonQuestionsModal(lessonId)
 * - Fetches tests for the lesson
 * - Shows all questions (grouped by test)
 * - Lets admin edit a question (PUT test with updated questions), delete a question (remove from test or delete test),
 *   and add a new question (append to first test or create new test)
 */
async function openLessonQuestionsModal(lessonId){
  if (!getToken()) return requireLoginModal('Please log in as an admin to manage questions.');
  if (!isAdmin()) return alert('Only admins may manage questions.');

  // load tests for this lesson
  const r = await fetchJson('/api/tests?lessonId=' + encodeURIComponent(lessonId), { headers: authHeaders(), method: 'GET' });
  if (!r.ok) return alert('Failed to load tests: ' + (r.error||''));
  const tests = Array.isArray(r.data) ? r.data : (Array.isArray(r.data.tests) ? r.data.tests : (r.data || []));
  // normalize tests structure
  const normalized = tests.map(t => ({
    id: t._id || t.id,
    title: t.title || '',
    questions: (t.questions || []).map(q => ({
      id: q.id || q._id || (q._id ? String(q._id) : null),
      text: (q.text && typeof q.text === 'object') ? (q.text.en || '') : (typeof q.text === 'string' ? q.text : (q.text && q.text.en) || ''),
      options: (q.options || []).map(o => ({ id: o.id || o._id || null, text: (o.text && (o.text.en || o.text)) || (typeof o.text === 'string' ? o.text : ''), isCorrect: !!o.isCorrect }))
    }))
  }));

  // render modal
  function render(){
    let html = `<h3>Questions for Lesson</h3>`;
    if (normalized.length === 0) {
      html += `<div class="muted-note">No tests found for this lesson. You can create a new question (a new test will be created).</div>`;
    }
    html += `<div style="max-height:55vh;overflow:auto">`;
    normalized.forEach((t, ti) => {
      html += `<div style="padding:8px;border:1px solid #eee;margin-bottom:8px;border-radius:8px"><div style="display:flex;justify-content:space-between;align-items:center"><div><strong>${escapeHtml(t.title||('Test #' + (ti+1)))}</strong><div class="muted-note">${t.questions.length} questions</div></div><div style="display:flex;gap:6px"><button class="small-btn edit-test-btn" data-id="${escapeHtml(t.id)}">Edit Test</button> <button class="small-btn del-test-btn" data-id="${escapeHtml(t.id)}">Delete Test</button></div></div><div style="margin-top:8px">`;
      t.questions.forEach((q, qi) => {
        html += `<div style="padding:8px;border:1px solid #f3f4f6;border-radius:8px;margin-bottom:6px">
                   <div style="font-weight:700">Q${qi+1}: ${escapeHtml(q.text||'')}</div>
                   <div style="margin-top:6px">${q.options.map((o,oi)=>`<div>${oi+1}. ${escapeHtml(o.text||'')} ${o.isCorrect?'<strong>(correct)</strong>':''}</div>`).join('')}</div>
                   <div style="margin-top:6px"><button class="small-btn edit-q" data-test="${escapeHtml(t.id)}" data-idx="${qi}">Edit</button> <button class="small-btn del-q" data-test="${escapeHtml(t.id)}" data-idx="${qi}">Delete</button></div>
                 </div>`;
      });
      html += `</div></div>`;
    });
    html += `</div>`;
    html += `<div style="display:flex;gap:8px;margin-top:12px"><button id="addQuestionBtn" class="small-btn">+ Add Question</button> <button id="closeQuestions" class="btn-ghost">Close</button></div>`;
    showModal(html);

    document.getElementById('closeQuestions').onclick = closeModal;
    document.getElementById('addQuestionBtn').onclick = ()=> addQuestionFlow();

    document.querySelectorAll('.edit-test-btn').forEach(b => b.onclick = (ev)=> { ev.stopPropagation(); const id=b.dataset.id; openEditTestModal(id); });
    document.querySelectorAll('.del-test-btn').forEach(b => b.onclick = async (ev)=> {
      ev.stopPropagation();
      if (!confirm('Delete whole test? This cannot be undone.')) return;
      const id = b.dataset.id;
      const rr = await fetchJson('/api/tests/' + encodeURIComponent(id), { method: 'DELETE', headers: authHeaders() });
      if (!rr.ok) return alert('Delete failed: ' + (rr.error||''));
      // remove locally and re-render
      const idx = normalized.findIndex(x=>String(x.id)===String(id));
      if (idx>=0) normalized.splice(idx,1);
      render();
    });

    document.querySelectorAll('.edit-q').forEach(b => b.onclick = (ev)=> { ev.stopPropagation(); const tId = b.dataset.test; const idx = +b.dataset.idx; openEditQuestionModal(tId, idx); });
    document.querySelectorAll('.del-q').forEach(b => b.onclick = (ev)=> { ev.stopPropagation(); const tId = b.dataset.test; const idx = +b.dataset.idx; deleteQuestionFlow(tId, idx); });
  }

  /* Add question: if there is an existing test, append to first test; otherwise create a new test */
  async function addQuestionFlow(){
    // simple prompt-based editor (better UI could reuse your question editor)
    const qText = prompt('Question text (English)');
    if (!qText) return alert('Cancelled or empty');
    const opt1 = prompt('Option 1 (English)');
    const opt2 = prompt('Option 2 (English)');
    if (!opt1 || !opt2) return alert('At least two options required');
    const opt3 = prompt('Option 3 (optional)');
    const correct = prompt('Which option number is correct? (1/2/3)') || '1';
    const opts = [{ id:null, text:{ en: opt1}, isCorrect: Number(correct) === 1 }, { id:null, text:{ en: opt2}, isCorrect: Number(correct) === 2 }];
    if (opt3) opts.push({ id:null, text:{ en: opt3}, isCorrect: Number(correct) === 3 });
    // if tests exist, append to first test via PUT; else create new test via POST
    if (normalized.length > 0) {
      const t = normalized[0];
      t.questions.push({ id: 'q_' + Math.random().toString(36).slice(2,8), text: { en: qText }, options: opts.map(o=>({ id: 'o_' + Math.random().toString(36).slice(2,8), text: o.text, isCorrect: !!o.isCorrect })), pointsValue:3 });
      const payload = { questions: t.questions.map(q=>({ id: q.id, text: { en: q.text.en||q.text }, options: q.options.map(o=>({ id: o.id, text: { en: o.text.en||o.text }, isCorrect: !!o.isCorrect })), pointsValue: q.pointsValue||3 })) };
      const rr = await fetchJson('/api/tests/' + encodeURIComponent(t.id), { method:'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
      if (!rr.ok) return alert('Failed to append question: ' + (rr.error||''));
      // reflect change locally
      render();
    } else {
      // create new test with single question
      const payload = {
        title: 'Lesson questions (auto)',
        folderId: currentFolderId || null,
        lessonId: lessonId,
        questions: [{ id: 'q_' + Math.random().toString(36).slice(2,8), text: { en: qText }, options: opts.map(o=>({ id: 'o_' + Math.random().toString(36).slice(2,8), text: o.text, isCorrect: !!o.isCorrect })), pointsValue:3 }]
      };
      const rr = await fetchJson('/api/tests', { method:'POST', headers: authHeaders(), body: JSON.stringify(payload) });
      if (!rr.ok) return alert('Failed to create test: ' + (rr.error||''));
      normalized.push({ id: rr.data.test._id || rr.data.test.id || rr.data._id, title: payload.title, questions: payload.questions });
      render();
    }
  }

  /* Edit a single question within a test */
  async function openEditQuestionModal(testId, qIndex){
    // fetch latest test
    const rtest = await fetchJson('/api/tests/' + encodeURIComponent(testId), { headers: authHeaders(), method: 'GET' });
    if (!rtest.ok) return alert('Failed to load test: ' + (rtest.error||''));
    const test = rtest.data.test || rtest.data;
    const q = test.questions[qIndex];
    if (!q) return alert('Question not found');

    // current values
    const qText = (q.text && (q.text.en || q.text)) || '';
    const opts = (q.options || []).map(o => ({ id: o.id || o._id || null, text: (o.text && (o.text.en || o.text)) || (typeof o.text === 'string' ? o.text : ''), isCorrect: !!o.isCorrect }));

    // build modal UI (simple)
    let html = `<h4>Edit Question</h4><label>Question (English)</label><input id="editQText" value="${escapeHtml(qText)}">`;
    html += `<label>Options</label><div id="editOpts" style="margin-top:8px"></div>`;
    html += `<div style="display:flex;gap:8px;margin-top:12px"><button id="saveQBtn" class="small-btn">Save</button><button id="cancelQBtn" class="btn-ghost">Cancel</button></div>`;
    showModal(html);

    function renderOpts(){
      const wrap = document.getElementById('editOpts');
      wrap.innerHTML = '';
      opts.forEach((o,i) => {
        const div = document.createElement('div');
        div.className = 'opt-row';
        div.innerHTML = `<input type="checkbox" class="opt-correct" data-i="${i}" ${o.isCorrect ? 'checked' : ''}> <input type="text" class="opt-text" data-i="${i}" value="${escapeHtml(o.text||'')}" placeholder="Option text"> <button class="small-btn del-opt" data-i="${i}">Del</button>`;
        wrap.appendChild(div);
      });
      wrap.querySelectorAll('.opt-correct').forEach(ch => ch.onchange = (e)=> { opts[+e.target.dataset.i].isCorrect = e.target.checked; });
      wrap.querySelectorAll('.opt-text').forEach(inp => inp.oninput = (e)=> { opts[+e.target.dataset.i].text = e.target.value; });
      wrap.querySelectorAll('.del-opt').forEach(b => b.onclick = (e)=> { opts.splice(+e.target.dataset.i,1); renderOpts(); });
    }

    // add option helper
    const addOptionBtn = document.createElement('button');
    addOptionBtn.className = 'small-btn';
    addOptionBtn.textContent = '+ Option';
    addOptionBtn.onclick = ()=> { opts.push({ id:null, text:'', isCorrect:false }); renderOpts(); };
    document.querySelector('.modal .modal')?.appendChild(addOptionBtn); // optional, not necessary

    renderOpts();
    document.getElementById('cancelQBtn').onclick = () => { closeModal(); openLessonQuestionsModal(lessonId); };
    document.getElementById('saveQBtn').onclick = async () => {
      const textNew = (document.getElementById('editQText').value || '').trim();
      if (!textNew) return alert('Question text required');
      if (opts.filter(o=>o.text && o.text.trim()).length < 2) return alert('At least two options required');
      // update test.questions[qIndex] accordingly
      test.questions[qIndex] = {
        id: q.id || ('q_' + Math.random().toString(36).slice(2,8)),
        text: { en: textNew },
        options: opts.map(o => ({ id: o.id || ('o_' + Math.random().toString(36).slice(2,8)), text: { en: o.text || '' }, isCorrect: !!o.isCorrect })),
        pointsValue: q.pointsValue || 3
      };
      const payload = { questions: test.questions.map(q => ({ id: q.id, text: q.text, options: q.options, pointsValue: q.pointsValue||3 })) };
      const rr = await fetchJson('/api/tests/' + encodeURIComponent(testId), { method: 'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
      if (!rr.ok) return alert('Save failed: ' + (rr.error||''));
      closeModal();
      openLessonQuestionsModal(lessonId);
    };
  }

  /* Delete question: if test has >1 question then remove only question and PUT updated test; otherwise delete test */
  async function deleteQuestionFlow(testId, qIndex){
    if (!confirm('Delete this question?')) return;
    const rtest = await fetchJson('/api/tests/' + encodeURIComponent(testId), { headers: authHeaders(), method: 'GET' });
    if (!rtest.ok) return alert('Failed to load test: ' + (rtest.error||''));
    const test = rtest.data.test || rtest.data;
    if (!test) return alert('Test not found');
    if ((test.questions || []).length <= 1) {
      // delete whole test
      const rr = await fetchJson('/api/tests/' + encodeURIComponent(testId), { method: 'DELETE', headers: authHeaders() });
      if (!rr.ok) return alert('Delete failed: ' + (rr.error||''));
      openLessonQuestionsModal(lessonId);
      return;
    }
    // remove question
    test.questions.splice(qIndex, 1);
    const payload = { questions: test.questions.map(q => ({ id: q.id || q._id, text: q.text, options: q.options, pointsValue: q.pointsValue||3 })) };
    const rr = await fetchJson('/api/tests/' + encodeURIComponent(testId), { method: 'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
    if (!rr.ok) return alert('Update failed: ' + (rr.error||''));
    openLessonQuestionsModal(lessonId);
  }

  // initial render
  render();
}

/* ===================== TEST CREATOR / EDITOR (bilingual, admin) ===================== */
/* (Kept mostly as in your previous file; openEditTestModal exists below and is used by Questions UI) */

function openAddTestModal(folderId=null, lessonId=null){
  if (!getToken()) return requireLoginModal('Please log in to add a test.');
  if (!isAdmin()) return alert('Only admins may create tests.');

  const questions = [];
  const folderNode = folderId ? findNodeById(folderId, treeCache) : null;
  const lessonOptions = (folderNode && Array.isArray(folderNode.lessons)) ? folderNode.lessons.slice() : [];

  function renderQuestionsList(container){
    container.innerHTML = '';
    questions.forEach((q, idx) => {
      const div = document.createElement('div');
      div.style.border = '1px solid #eee';
      div.style.padding = '8px';
      div.style.borderRadius = '8px';
      div.style.marginBottom = '8px';
      const qtextEn = (q.text && q.text.en) ? q.text.en : (typeof q.text === 'string' ? q.text : '');
      const qtextSom = (q.text && q.text.som) ? q.text.som : '';
      div.innerHTML = `<div style="font-weight:700">Q${idx+1}: ${escapeHtml(qtextEn)}</div>
        <div style="margin-top:6px">${q.options.map((o,i)=>`<div>${i+1}. ${escapeHtml((o.text&&o.text.en)?o.text.en:o.text||'')} ${o.isCorrect?'<strong>(correct)</strong>':''}</div>`).join('')}</div>`;
      const editBtn = document.createElement('button'); editBtn.className='small-btn'; editBtn.innerText='Edit';
      editBtn.onclick = ()=> openQuestionEditor(idx);
      const removeBtn = document.createElement('button'); removeBtn.className='small-btn'; removeBtn.innerText='Remove';
      removeBtn.onclick = ()=> { questions.splice(idx,1); renderQuestionsList(container); };
      div.appendChild(editBtn); div.appendChild(removeBtn);
      container.appendChild(div);
    });
  }

  function showTestModal(preservedTitle=''){
    const lessonSelectHtml = lessonOptions.length ? (`<label>Attach to lesson (optional)</label><select id="testLessonSelect"><option value="">-- none --</option>${lessonOptions.map(l=>`<option value="${l._id}" ${lessonId && String(lessonId)===String(l._id) ? 'selected' : ''}>${escapeHtml(tLocalized(l.title)|| (l.title && l.title.en) || 'Untitled')}</option>`).join('')}</select>`) : `<label>Attach to lesson (optional)</label><input id="testLessonInput" placeholder="paste lesson id (optional)" value="${lessonId?escapeHtml(lessonId):''}">`;

    const html = `
      <h3>Create Test</h3>
      <label>Test title</label><input id="testTitle" value="${escapeHtml(preservedTitle)}" placeholder="e.g. Algebra Basics Quiz">
      ${lessonSelectHtml}
      <div style="margin-top:8px"><button id="addQuestionBtn" class="small-btn">+ Add question</button></div>
      <div id="questionsWrap" style="margin-top:10px"></div>
      <div style="display:flex;gap:8px;margin-top:12px"><button id="createTestBtn">Create Test</button><button id="cancelTestBtn" class="btn-ghost">Cancel</button></div>
      <p class="muted-note">Mark correct option with checkbox in editor. Each question needs at least two options. Questions and options are saved bilingual (English + Somali fields).</p>
    `;
    showModal(html);
    const wrap = document.getElementById('questionsWrap');
    renderQuestionsList(wrap);
    document.getElementById('addQuestionBtn').onclick = ()=> openQuestionEditor(null);
    document.getElementById('cancelTestBtn').onclick = closeModal;
    document.getElementById('createTestBtn').onclick = async ()=>{
      const title = (document.getElementById('testTitle').value || '').trim();
      if (!title) return alert('Test title required');
      if (questions.length === 0) return alert('Add at least one question');

      questions.forEach((q,qi) => {
        q.id = q.id || ('q_' + (qi+1) + '_' + Math.random().toString(36).slice(2,6));
        q.options.forEach((o,oi) => o.id = o.id || ('o' + (oi+1) + '_' + Math.random().toString(36).slice(2,6)));
      });

      const selectedLesson = document.getElementById('testLessonSelect') ? document.getElementById('testLessonSelect').value : (document.getElementById('testLessonInput') ? document.getElementById('testLessonInput').value.trim() : '');
      const payload = {
        title,
        folderId: folderId || null,
        lessonId: selectedLesson || null,
        questions: questions.map(q => ({
          id: q.id,
          text: { en: q.text.en || '', som: q.text.som || '' },
          options: q.options.map(o=>({ id: o.id, text: { en: o.text.en || '', som: o.text.som || '' }, isCorrect: !!o.isCorrect })),
          pointsValue: q.pointsValue || 3
        }))
      };

      const r = await fetchJson('/api/tests', { method:'POST', headers: authHeaders(), body: JSON.stringify(payload) });
      if (!r.ok) return alert('Create test failed: '+(r.error||''));
      closeModal();
      alert('Test created');
      await loadTree();
    };
  }

  function openQuestionEditor(index){
    const existing = (typeof index === 'number' && questions[index]) ? questions[index] : null;
    const qTextEn = existing && existing.text ? (existing.text.en || '') : '';
    const qTextSom = existing && existing.text ? (existing.text.som || '') : '';
    const opts = existing ? (existing.options || []).map(o=>({ id:o.id, text:{ en: o.text.en || (typeof o.text==='string'?o.text:''), som: o.text.som || '' }, isCorrect: !!o.isCorrect })) : [{id:null,text:{en:'',som:''},isCorrect:false},{id:null,text:{en:'',som:''},isCorrect:false}];
    const html = `
      <h4>${existing ? 'Edit Question' : 'New Question'}</h4>
      <label>Question text ‚Äî English</label><input id="qTextEn" value="${escapeHtml(qTextEn)}" placeholder="e.g. 2+2=?">
      <label>Question text ‚Äî Somali (optional)</label><input id="qTextSom" value="${escapeHtml(qTextSom)}" placeholder="e.g. 2+2=? (Somali)">
      <label>Options</label>
      <div id="optsWrap" style="margin-top:8px"></div>
      <div style="display:flex;gap:8px;margin-top:10px"><button id="addOptBtn" class="small-btn">+ Option</button><button id="saveQBtn">Save</button><button id="cancelQBtn" class="btn-ghost">Cancel</button></div>
    `;
    showModal(html);

    function renderOpts(){
      const wrap = document.getElementById('optsWrap');
      wrap.innerHTML = '';
      opts.forEach((o, i)=>{
        const div = document.createElement('div');
        div.className = 'opt-row';
        div.innerHTML = `<input type="checkbox" class="opt-correct" data-i="${i}" ${o.isCorrect ? 'checked' : ''} aria-label="Mark option ${i+1} as correct"> <input type="text" class="opt-text-en" data-i="${i}" value="${escapeHtml(o.text.en||'')}" placeholder="Option English"> <input type="text" class="opt-text-som" data-i="${i}" value="${escapeHtml(o.text.som||'')}" placeholder="Option Somali (optional)"> <button class="small-btn del-opt" data-i="${i}">Del</button>`;
        wrap.appendChild(div);
      });
      wrap.querySelectorAll('.opt-correct').forEach(ch => ch.onchange = (e)=> { opts[+e.target.dataset.i].isCorrect = e.target.checked; });
      wrap.querySelectorAll('.opt-text-en').forEach(inp => inp.oninput = (e)=> { opts[+e.target.dataset.i].text.en = e.target.value; });
      wrap.querySelectorAll('.opt-text-som').forEach(inp => inp.oninput = (e)=> { opts[+e.target.dataset.i].text.som = e.target.value; });
      wrap.querySelectorAll('.del-opt').forEach(b => b.onclick = (e)=> { opts.splice(+e.target.dataset.i,1); renderOpts(); });
    }

    document.getElementById('addOptBtn').onclick = ()=> { opts.push({ id:null, text:{en:'',som:''}, isCorrect:false }); renderOpts(); };
    document.getElementById('cancelQBtn').onclick = ()=> { showTestModal(document.getElementById('testTitle') ? document.getElementById('testTitle').value : ''); };
    document.getElementById('saveQBtn').onclick = ()=>{
      const text = (document.getElementById('qTextEn').value || '').trim();
      const textSomNew = (document.getElementById('qTextSom').value || '').trim();
      if (!text) return alert('Question text required');
      if (opts.filter(o=>o.text && o.text.en && o.text.en.trim()).length < 2) return alert('At least two options with text required');
      const qObj = { id: existing && existing.id ? existing.id : null, text: { en: text, som: textSomNew }, options: opts.map(o=>({ id: o.id || null, text: { en: o.text.en || '', som: o.text.som || '' }, isCorrect: !!o.isCorrect })), pointsValue: (existing && existing.pointsValue) ? existing.pointsValue : 3 };
      if (existing && typeof index === 'number') questions[index] = qObj; else questions.push(qObj);
      showTestModal(document.getElementById('testTitle') ? document.getElementById('testTitle').value : '');
    };

    renderOpts();
    setTimeout(()=>{ const f = document.getElementById('qTextEn'); if (f) f.focus(); }, 40);
  }

  showTestModal();
}

/* Admin: Edit existing test (full modal) */
async function openEditTestModal(testId){
  if (!getToken()) return requireLoginModal('Please log in as an admin to edit tests.');
  if (!isAdmin()) return alert('Not allowed');
  const r = await fetchJson('/api/tests/'+encodeURIComponent(testId), { headers: authHeaders(), method: 'GET' });
  if (!r.ok) return alert('Failed to load test: '+(r.error||''));
  const test = r.data.test || r.data;
  // populate edit modal using same UI pieces as add
  const questions = (test.questions || []).map(q => ({ id: q.id || q._id, text: { en: (q.text && q.text.en) || (typeof q.text==='string'?q.text:''), som: (q.text && q.text.som) || '' }, options: (q.options||[]).map(o=>({ id: o.id || o._id, text: { en: (o.text && o.text.en) || (typeof o.text==='string'?o.text:''), som: (o.text && o.text.som) || '' }, isCorrect: !!o.isCorrect })), pointsValue: q.pointsValue || 3 })) ;

  const folderId = test.folderId || test.folder || null;
  const lessonId = test.lessonId || test.lesson || null;

  function renderQuestionsList(container){
    container.innerHTML = '';
    questions.forEach((q, idx) => {
      const div = document.createElement('div');
      div.style.border = '1px solid #eee'; div.style.padding='8px'; div.style.borderRadius='8px'; div.style.marginBottom='8px';
      div.innerHTML = `<div style="font-weight:700">Q${idx+1}: ${escapeHtml(q.text.en||'')}</div><div style="margin-top:6px">${q.options.map((o,i)=>`<div>${i+1}. ${escapeHtml(o.text.en||'')} ${o.isCorrect?'<strong>(correct)</strong>':''}</div>`).join('')}</div>`;
      const editBtn = document.createElement('button'); editBtn.className='small-btn'; editBtn.innerText='Edit'; editBtn.onclick = ()=> openQuestionEditorLocal(idx);
      const removeBtn = document.createElement('button'); removeBtn.className='small-btn'; removeBtn.innerText='Remove'; removeBtn.onclick = ()=> { questions.splice(idx,1); renderQuestionsList(container); };
      div.appendChild(editBtn); div.appendChild(removeBtn);
      container.appendChild(div);
    });
  }

  function openQuestionEditorLocal(index){
    const existing = questions[index];
    const qTextEn = existing ? existing.text.en : '';
    const qTextSom = existing ? existing.text.som : '';
    const opts = existing ? existing.options.map(o=>({ id:o.id, text:{en:o.text.en||'',som:o.text.som||''}, isCorrect: o.isCorrect })) : [{id:null,text:{en:'',som:''},isCorrect:false},{id:null,text:{en:'',som:''},isCorrect:false}];
    const html = `
      <h4>${existing ? 'Edit Question' : 'New Question'}</h4>
      <label>Question text ‚Äî English</label><input id="qTextEn" value="${escapeHtml(qTextEn)}">
      <label>Question text ‚Äî Somali (optional)</label><input id="qTextSom" value="${escapeHtml(qTextSom)}">
      <label>Options</label>
      <div id="optsWrap" style="margin-top:8px"></div>
      <div style="display:flex;gap:8px;margin-top:10px"><button id="addOptBtn" class="small-btn">+ Option</button><button id="saveQBtn">Save</button><button id="cancelQBtn" class="btn-ghost">Cancel</button></div>
    `;
    showModal(html);
    function renderOpts(){ const wrap=document.getElementById('optsWrap'); wrap.innerHTML=''; opts.forEach((o,i)=>{ const div=document.createElement('div'); div.className='opt-row'; div.innerHTML = `<input type="checkbox" class="opt-correct" data-i="${i}" ${o.isCorrect?'checked':''}> <input type="text" class="opt-text-en" data-i="${i}" value="${escapeHtml(o.text.en||'')}" placeholder="Option English"> <input type="text" class="opt-text-som" data-i="${i}" value="${escapeHtml(o.text.som||'')}" placeholder="Option Somali (optional)"> <button class="small-btn del-opt" data-i="${i}">Del</button>`; wrap.appendChild(div); });
      wrap.querySelectorAll('.opt-correct').forEach(ch=>ch.onchange=(e)=>opts[+e.target.dataset.i].isCorrect=e.target.checked);
      wrap.querySelectorAll('.opt-text-en').forEach(inp=>inp.oninput=(e)=>opts[+e.target.dataset.i].text.en=e.target.value);
      wrap.querySelectorAll('.opt-text-som').forEach(inp=>inp.oninput=(e)=>opts[+e.target.dataset.i].text.som=e.target.value);
      wrap.querySelectorAll('.del-opt').forEach(b=>b.onclick=(e)=>{ opts.splice(+e.target.dataset.i,1); renderOpts(); });
    }
    document.getElementById('addOptBtn').onclick = ()=> { opts.push({ id:null, text:{en:'',som:''}, isCorrect:false }); renderOpts(); };
    document.getElementById('cancelQBtn').onclick = ()=> { renderEditModal(); };
    document.getElementById('saveQBtn').onclick = ()=>{
      const textEn = (document.getElementById('qTextEn').value||'').trim();
      const textSom = (document.getElementById('qTextSom').value||'').trim();
      if (!textEn) return alert('Question English text required');
      if (opts.filter(o=>o.text && o.text.en && o.text.en.trim()).length < 2) return alert('At least two options with English text required');
      const qObj = { id: existing && existing.id ? existing.id : null, text: { en: textEn, som: textSom }, options: opts.map(o=>({ id:o.id||null, text:{en:o.text.en||'', som:o.text.som||''}, isCorrect: !!o.isCorrect })), pointsValue: existing?existing.pointsValue:3 };
      if (existing) questions[index] = qObj; else questions.push(qObj);
      renderEditModal();
    };
    renderOpts();
  }

  function renderEditModal(){
    const html = `
      <h3>Edit Test</h3>
      <label>Title</label><input id="editTestTitle" value="${escapeHtml(test.title||'')}">
      <label>Attach to lesson (optional)</label><input id="editTestLesson" value="${escapeHtml(lessonId||'')}">
      <div style="margin-top:8px"><button id="addQuestionBtn" class="small-btn">+ Add question</button></div>
      <div id="questionsWrap" style="margin-top:10px"></div>
      <div style="display:flex;gap:8px;margin-top:12px"><button id="saveTestBtn">Save Changes</button><button id="cancelEditTest" class="btn-ghost">Cancel</button></div>
      <p class="muted-note">You can add/edit/remove questions. Saving will send a PUT /api/tests/:id request (backend must support this). Questions and options are bilingual.</p>
    `;
    showModal(html);
    document.getElementById('questionsWrap').innerHTML = '';
    renderQuestionsList(document.getElementById('questionsWrap'));
    document.getElementById('addQuestionBtn').onclick = ()=> openQuestionEditorLocal(questions.length);
    document.getElementById('cancelEditTest').onclick = closeModal;
    document.getElementById('saveTestBtn').onclick = async ()=>{
      const newTitle = (document.getElementById('editTestTitle').value||'').trim();
      const newLesson = (document.getElementById('editTestLesson').value||'').trim()||null;
      if (!newTitle) return alert('Title required');
      const payload = {
        title: newTitle,
        folderId: folderId||null,
        lessonId: newLesson,
        questions: questions.map(q=>({ id:q.id, text:{ en:q.text.en||'', som:q.text.som||'' }, options: q.options.map(o=>({ id:o.id, text:{ en:o.text.en||'', som:o.text.som||'' }, isCorrect: !!o.isCorrect })), pointsValue: q.pointsValue||3 }))
      };
      let rr = await fetchJson('/api/tests/'+encodeURIComponent(testId), { method:'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
      if (!rr.ok) {
        const cr = await fetchJson('/api/tests', { method:'POST', headers: authHeaders(), body: JSON.stringify(payload) });
        if (!cr.ok) return alert('Save failed: '+(rr.error||cr.error||''));
        alert('Saved as new test; consider deleting the old one.');
      }
      closeModal();
      await loadTree();
    };
  }

  renderEditModal();
}

/* ===================== TEST TAKING (unchanged except keyboard/progress) ===================== */
/* ... keep showPaginatedRunner, showTestRunner, aggregate runner from previous file ... */
/* For brevity I reference your existing runner code here ‚Äî it's already present above in previous version and unchanged except that Take Test buttons were removed from folder cards. */
/* (If you want I can paste the full runner code again ‚Äî but current file already contains the runner functions from earlier which we kept.) */

/* ===================== TEST TAKING (folder aggregation + paginated runner w/progress + keyboard) ===================== */
/* ===================== FRONTEND PATCH ===================== */
/* Replace collectLessonIdsFromFolderNode and gatherTestsForFolder with these versions */

/**
 * collectFolderIdsRecursive(node)
 * Returns array of folder._id strings for node and all descendants.
 */

 function collectFolderIdsRecursive(node){
  const ids = [];
  if (!node) return ids;
  ids.push(String(node._id));
  if (Array.isArray(node.children)) {
    node.children.forEach(c => ids.push(...collectFolderIdsRecursive(c)));
  }
  return ids;
}

/**
 * collectLessonIdsFromFolderNode recursively collects lesson ids for a node and all descendants.
 */
function collectLessonIdsFromFolderNode(node){
  const ids = [];
  if (!node) return ids;
  if (Array.isArray(node.lessons)) {
    node.lessons.forEach(l => ids.push(String(l._id)));
  }
  if (Array.isArray(node.children)) {
    node.children.forEach(c => {
      ids.push(...collectLessonIdsFromFolderNode(c));
    });
  }
  return ids;
}

/**
 * gatherTestsForFolder(folderId)
 * - Fetches tests for every folder id in subtree AND for every lesson id in subtree.
 * - Deduplicates by test._id / id.
 */

 

 async function gatherTestsForFolder(folderId){
  const tests = [];
  const seen = new Set();
  if (!folderId) return tests;

  // Find folder node in treeCache
  const rootNode = findNodeById(folderId, treeCache);
  if (!rootNode) {
    // fallback: try server-level query for folder
    const rFolderOnly = await fetchJson(`/api/tests?folderId=${encodeURIComponent(folderId)}`, { headers: authHeaders(), method: 'GET' });
    if (rFolderOnly.ok) {
      const arr = Array.isArray(rFolderOnly.data) ? rFolderOnly.data : (rFolderOnly.data && rFolderOnly.data.tests) ? rFolderOnly.data.tests : [];
      arr.forEach(t => { if (t && (t._id || t.id) && !seen.has(String(t._id||t.id))) { seen.add(String(t._id||t.id)); tests.push(t); } });
    }
    return tests;
  }

  // Collect all folder ids in subtree
  const folderIds = collectFolderIdsRecursive(rootNode);

  // For each folder id, fetch tests attached to that folder
  for (const fid of folderIds) {
    const r = await fetchJson(`/api/tests?folderId=${encodeURIComponent(fid)}`, { headers: authHeaders(), method:'GET' });
    if (!r.ok) continue;
    const arr = Array.isArray(r.data) ? r.data : (r.data && r.data.tests) ? r.data.tests : (r.data ? (Array.isArray(r.data)?r.data:[]) : []);
    arr.forEach(t => { if (t && (t._id || t.id) && !seen.has(String(t._id||t.id))) { seen.add(String(t._id||t.id)); tests.push(t); } });
  }



 // Collect all lesson ids in subtree and fetch tests for each lesson
  const lessonIds = collectLessonIdsFromFolderNode(rootNode);
  for (const lid of lessonIds) {
    const r = await fetchJson(`/api/tests?lessonId=${encodeURIComponent(lid)}`, { headers: authHeaders(), method:'GET' });
    if (!r.ok) continue;
    const arr = Array.isArray(r.data) ? r.data : (r.data && r.data.tests) ? r.data.tests : (r.data ? (Array.isArray(r.data)?r.data:[]) : []);
    arr.forEach(t => { if (t && (t._id || t.id) && !seen.has(String(t._id||t.id))) { seen.add(String(t._id||t.id)); tests.push(t); } });
  }

  return tests;
}

async function openTakeTest(folderId=null, lessonId=null){
  let tests = [];
  if (lessonId) { const r=await fetchJson(`/api/tests?lessonId=${encodeURIComponent(lessonId)}`, { headers: authHeaders(), method:'GET' }); if (r.ok) tests = Array.isArray(r.data)?r.data:(r.data||[]); }
  if ((!tests||tests.length===0) && folderId) tests = await gatherTestsForFolder(folderId);
  if (!tests || tests.length===0) return alert('No tests found for this folder/lesson.');
  if (tests.length > 1 && !folderId) {
    const html = `<h3>Select Test</h3><div style="max-height:50vh;overflow:auto">${tests.map(t=>`<div style="padding:8px;border-bottom:1px solid #eee"><strong>${escapeHtml(t.title||'Untitled')}</strong><div style="margin-top:6px"><button class="small-btn pick-test" data-id="${escapeHtml(t._id||t.id)}">Take</button> ${isAdmin()?`<button class="small-btn edit-test" data-id="${escapeHtml(t._id||t.id)}">Edit</button>`:''}</div></div>`).join('')}</div><div style="margin-top:10px"><button id="closePick" class="btn-ghost">Close</button></div>`;
    showModal(html);
    document.getElementById('closePick').onclick = closeModal;
    document.querySelectorAll('.pick-test').forEach(btn=> btn.onclick = async ()=>{ closeModal(); await showTestRunner(btn.dataset.id); });
    document.querySelectorAll('.edit-test').forEach(btn=> btn.onclick = async ()=>{ closeModal(); openEditTestModal(btn.dataset.id); });
    return;
  }
  if (folderId && tests.length > 1) { await showAggregatedTestRunner(tests); return; }
  const testId = tests[0]._id || tests[0].id;
  await showTestRunner(testId);
}

async function showTestRunner(testId){
  const r = await fetchJson('/api/tests/'+encodeURIComponent(testId), { headers: authHeaders(), method:'GET' });
  if (!r.ok) return alert('Failed to load test: '+(r.error||''));
  const test = r.data.test || r.data;
  const qs = (test.questions||[]).map((q,idx)=>({ ...q, __testId: test._id || test.id, __origIndex: idx, textStr: (q.text && (q.text.en||q.text)) || (typeof q.text==='string'?q.text:'') }));
  await showPaginatedRunner([{ testId: test._id||test.id, title: test.title||'', questions: qs }], false);
}

async function showAggregatedTestRunner(testsArray){
  const normalized=[];
  for (const t of testsArray){
    const tId = t._id||t.id; const r = await fetchJson('/api/tests/'+encodeURIComponent(tId), { headers: authHeaders(), method:'GET' }); if (!r.ok) continue; const test = r.data.test||r.data; const qs = (test.questions||[]).map((q,idx)=>({ ...q, __testId: tId, __origIndex: idx, textStr: (q.text && (q.text.en||q.text)) || (typeof q.text==='string'?q.text:'') })); normalized.push({ testId: tId, title: test.title||'', questions: qs }); }
  if (!normalized.length) return alert('No valid tests to run.');
  await showPaginatedRunner(normalized, true);
}

async function showPaginatedRunner(testsNormalized, aggregatedFlag){
  // build blocks and flattened question list
  const blocks = testsNormalized.map(t=>({ testId: t.testId, title: t.title, questions: t.questions }));
  let flat = [];
  blocks.forEach(b=> b.questions.forEach(q=> flat.push({ ...q, __testId: b.testId, __origIndex: q.__origIndex })));

  // SHUFFLE questions each run - Fisher-Yates
  for (let i = flat.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [flat[i], flat[j]] = [flat[j], flat[i]];
  }

  // store question order and answer state
  const questionOrder = flat; // already shuffled
  const answersMap = {}; // answersMap[testId] = array of answers by question index
  const attemptMap = {};
  const testStarted = {};
  let currentIndex = 0;
  let timer = null;
  let timeLeft = QUESTION_SECONDS || 30;
  let alreadySubmitted = false;
  const answeredSet = new Set(); // IDs answered this session

  blocks.forEach(b=> { answersMap[b.testId] = Array(b.questions.length).fill(null); });

  // sound helpers (play correct/incorrect), fallback using WebAudio
  function playSound(kind){
    // try static audio files if available
    try {
      if (kind === 'correct') {
        if (typeof CORRECT_SOUND_URL !== 'undefined') { new Audio(CORRECT_SOUND_URL).play().catch(()=>{}); return; }
      } else {
        if (typeof INCORRECT_SOUND_URL !== 'undefined') { new Audio(INCORRECT_SOUND_URL).play().catch(()=>{}); return; }
      }
    } catch(e){}

    // fallback beep
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      if (kind === 'correct') { o.frequency.value = 880; } else { o.frequency.value = 220; }
      o.type = 'sine';
      g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
      o.start();
      setTimeout(()=> { g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.05); o.stop(ctx.currentTime + 0.06); }, 120);
    } catch(e){ /* ignore */ }
  }

  function keyHandler(e){
    if (e.key === 'ArrowLeft') { e.preventDefault(); goPrev(); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); goNext(); }
    else if (e.key === 'Enter') {
      const finishBtn = document.getElementById('finishQ');
      if (finishBtn) finishBtn.click();
    }
  }
  document.addEventListener('keydown', keyHandler);

  function renderQuestionUI(){
    if (currentIndex < 0) currentIndex = 0;
    if (currentIndex >= questionOrder.length) currentIndex = questionOrder.length - 1;
    const q = questionOrder[currentIndex];
    const testBlock = blocks.find(b=> b.testId === q.__testId);
    const qTitle = q.textStr || (q.text && (q.text.en || q.text)) || '';

    // if this question already answered in this run and you want to skip it: we keep it visible for review.
    // Start test attempt on first question of test encountered
    if (!testStarted[q.__testId]) {
      const firstIdx = questionOrder.findIndex(x=> x.__testId === q.__testId);
      if (currentIndex === firstIdx) {
        testStarted[q.__testId] = true;
        (async ()=>{
          const r = await fetchJson('/api/tests/'+encodeURIComponent(q.__testId)+'/start', { method:'POST', headers: authHeaders() });
          if (r.ok) attemptMap[q.__testId] = r.data && (r.data.attemptId || r.data.attemptId);
        })();
      }
    }

    const total = questionOrder.length;
    const progressPercent = Math.round(((currentIndex+1)/total)*100);

    const html = `
      <h3>${escapeHtml(testBlock.title || 'Test')}</h3>
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <div class="small-muted">Question ${currentIndex+1} of ${total} (${escapeHtml(testBlock.title || '')})</div>
        <div class="small-muted">Time left: <span id="timerDisplay" class="timer">${timeLeft}s</span></div>
      </div>
      <div class="progress-wrap" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${progressPercent}"><div class="progress-bar" id="progressBar" style="width:${progressPercent}%"></div></div>
      <div id="questionWrap" style="margin-top:10px">
        <div class="test-question">
          <h4>${escapeHtml(qTitle||'')}</h4>
          <div class="options">${ (q.options||[]).map((o,oi)=>`<div class="test-option"><input type="radio" id="opt_${currentIndex}_${oi}" name="qopt" value="${escapeHtml(o.id||o._id||oi)}" aria-labelledby="lbl_${currentIndex}_${oi}"><label id="lbl_${currentIndex}_${oi}" for="opt_${currentIndex}_${oi}">${escapeHtml((o.text && (o.text.en || o.text)) || o.text || '')}</label></div>`).join('') }</div>
        </div>
      </div>
      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="prevQ" class="small-btn" ${currentIndex===0? 'disabled':''} aria-label="Previous question">Prev</button>
        <button id="nextQ" class="small-btn" ${currentIndex===questionOrder.length-1? 'disabled':''} aria-label="Next question">Next</button>
        <button id="finishQ" class="btn-ghost" aria-label="Finish test">Finish</button>
      </div>
      <div style="margin-top:8px" class="muted-note">Each question has ${QUESTION_SECONDS||30}s. When timer expires it auto-advances. You can finish anytime. Use ‚Üê and ‚Üí keys to navigate. You can move back to change answers before finishing.</div>
    `;
    showModal(html);

    // restore previous choice if any
    const prev = answersMap[q.__testId][q.__origIndex];
    if (prev && prev.selectedOptionId) {
      setTimeout(()=> {
        const el = document.querySelector(`input[name="qopt"][value="${prev.selectedOptionId}"]`);
        if (el) el.checked = true;
      }, 30);
    }

    // timer start
    timeLeft = QUESTION_SECONDS || 30;
    const timerEl = document.getElementById('timerDisplay');
    if (timer) clearInterval(timer);
    timer = setInterval(()=> {
      timeLeft--;
      if (timerEl) timerEl.innerText = `${timeLeft}s`;
      if (timeLeft <= 0) {
        clearInterval(timer);
        saveCurrentAnswer(getSelectedOption());
        if (currentIndex < questionOrder.length - 1) { currentIndex++; renderQuestionUI(); }
        else { submitAllAnswers(); }
      }
    }, 1000);

    document.getElementById('prevQ').onclick = ()=> { saveCurrentAnswer(getSelectedOption()); goPrev(); };
    document.getElementById('nextQ').onclick = ()=> { saveCurrentAnswer(getSelectedOption()); goNext(); };
    const finishBtn = document.getElementById('finishQ');
    if (finishBtn) finishBtn.onclick = async ()=> { saveCurrentAnswer(getSelectedOption()); await submitAllAnswers(); };

    function getSelectedOption(){ const checked = document.querySelector('input[name="qopt"]:checked'); return checked ? checked.value : null; }
    function saveCurrentAnswer(selectedOptionId){
      const curQ = questionOrder[currentIndex];
      // record answer with timestamp
      const answerObj = { questionId: curQ.id || curQ._id || curQ._id || curQ.id, selectedOptionId: selectedOptionId||null, questionIndex: curQ.__origIndex, answeredAt: (new Date()).toISOString() };
      answersMap[curQ.__testId][curQ.__origIndex] = answerObj;
      if (selectedOptionId) answeredSet.add(String(answerObj.questionId));
      // play sound immediately (determine correctness)
      const opt = (curQ.options || []).find(o => String(o.id || o._id) === String(selectedOptionId));
      if (opt) {
        if (opt.isCorrect) playSound('correct'); else playSound('incorrect');
      } else {
        // if no selection (timeout), no sound
      }
    }
    function goPrev(){ if (currentIndex > 0) { currentIndex--; renderQuestionUI(); } }
    function goNext(){ if (currentIndex < questionOrder.length - 1) { currentIndex++; renderQuestionUI(); } }
  }

  async function submitAllAnswers(){
    if (alreadySubmitted) { alert('Submitting ‚Äî please wait'); return; }
    alreadySubmitted = true;
    // disable any UI
    if (timer) { clearInterval(timer); timer = null; }
    document.removeEventListener('keydown', keyHandler);

    // Prepare and post per-test answers
    const summary = { totalQuestions: 0, correct: 0, incorrect: 0, unanswered: 0, perTest: [] };
    for (const b of blocks) {
      const tId = b.testId;
      // ensure attemptId exists
      if (!attemptMap[tId]) {
        const sr = await fetchJson('/api/tests/'+encodeURIComponent(tId)+'/start', { method:'POST', headers: authHeaders() });
        if (sr.ok) attemptMap[tId] = sr.data && (sr.data.attemptId || sr.data.attemptId);
        else attemptMap[tId] = null;
      }

      const answersArr = (answersMap[tId] || []).map((a, idx) => {
        const qObj = b.questions[idx];
        const questionId = a ? a.questionId : (qObj.id || qObj._id);
        const picked = a ? a.selectedOptionId : null;
        // determine correctness locally if possible
        const opt = (qObj.options || []).find(o => String(o.id || o._id) === String(picked));
        const isCorrect = !!(opt && opt.isCorrect);
        if (a) {
          summary.totalQuestions++;
          if (picked === null) summary.unanswered++;
          else if (isCorrect) summary.correct++;
          else summary.incorrect++;
        } else {
          summary.totalQuestions++;
          summary.unanswered++;
        }
        return { questionId, selectedOptionId: picked, questionIndex: idx, answeredAt: a ? a.answeredAt : null };
      });

      // send to server
      if (!attemptMap[tId]) {
        console.warn('No attemptId for test', tId);
        continue;
      }
      const submitResp = await fetchJson('/api/tests/'+encodeURIComponent(tId)+'/submit', { method:'POST', headers: authHeaders(), body: JSON.stringify({ attemptId: attemptMap[tId], answers: answersArr }) });
      if (!submitResp.ok) {
        console.warn('submit failed for test', tId, submitResp);
      } else {
        const data = submitResp.data || submitResp;
        summary.perTest.push({ testId: tId, scoreDelta: data.scoreDelta || 0, totalAfter: data.totalAfter != null ? data.totalAfter : null, title: b.title });
      }
    }

    // Compute local penalty or stats (user requested: count incorrect answers, etc.)
    const localPenalty = (summary.incorrect || 0); // you can multiply by question points if desired
    const last = summary.perTest.length ? summary.perTest[summary.perTest.length - 1] : null;
    const totalAfter = last ? last.totalAfter : null;

    closeModal();
    const resultHtml = `
      <h3>Result</h3>
      <div style="margin-top:8px">
        <div class="muted-note">Total questions: <strong>${summary.totalQuestions}</strong></div>
        <div class="muted-note">Correct: <strong>${summary.correct}</strong></div>
        <div class="muted-note">Incorrect (penalties): <strong>${summary.incorrect}</strong></div>
        <div class="muted-note">Unanswered: <strong>${summary.unanswered}</strong></div>
        <div class="muted-note">Local penalty count: <strong>${localPenalty}</strong></div>
        <div class="muted-note">Server total (if available): <strong>${ totalAfter !== null ? totalAfter : '‚Äî' }</strong></div>
      </div>
      <div style="margin-top:12px"><button id="closeResult" class="btn-ghost">Close</button></div>
    `;
    showModal(resultHtml);
    document.getElementById('closeResult').onclick = ()=> { closeModal(); loadTree(); };

    // leave alreadySubmitted true to prevent duplicate submissions
  }

  // start UI
  if (questionOrder.length === 0) return alert('No questions to run.');
  renderQuestionUI();
}

/* ===================== RECYCLE / RESTORE (unchanged) ===================== */

async function openRecycleModal(){ if (!getToken()) return requireLoginModal('Please log in as an admin to view the recycle bin.'); if (!isAdmin()) return alert('Only admins may access the recycle bin.'); const r = await fetchJson('/api/lessons/recycle', { headers: authHeaders(), method: 'GET' }); if (r.ok) { const folders = r.data.folders||[]; const lessons = r.data.lessons||[]; return showRecycleList(folders, lessons); } const fallbackFolders = await fetchJson('/api/lessons/folders?deleted=1', { headers: authHeaders(), method: 'GET' }); const fallbackLessons = await fetchJson('/api/lessons?deleted=1', { headers: authHeaders(), method: 'GET' }); if ((fallbackFolders.ok && (Array.isArray(fallbackFolders.data) || Array.isArray(fallbackFolders.data.folders))) || (fallbackLessons.ok && (Array.isArray(fallbackLessons.data) || Array.isArray(fallbackLessons.data.lessons)))) { const folders = (fallbackFolders.ok && Array.isArray(fallbackFolders.data)) ? fallbackFolders.data : (fallbackFolders.ok && fallbackFolders.data && fallbackFolders.data.folders) ? fallbackFolders.data.folders : []; const lessons = (fallbackLessons.ok && Array.isArray(fallbackLessons.data)) ? fallbackLessons.data : (fallbackLessons.ok && fallbackLessons.data && fallbackLessons.data.lessons) ? fallbackLessons.data.lessons : []; return showRecycleList(folders, lessons); } const scanned = collectDeletedFromTree(treeCache); if (scanned.folders.length || scanned.lessons.length) { return showRecycleList(scanned.folders, scanned.lessons, { source: 'local' }); } const html = `<h3>Recycle Bin ‚Äî Error</h3><div class="muted-note">Could not load recycle bin: ${escapeHtml(String(r.error || r.rawText || 'Server error'))}</div><div style="margin-top:10px" class="muted-note">Server responses (for debugging):<pre style="white-space:pre-wrap">${escapeHtml(JSON.stringify({r, fallbackFolders, fallbackLessons}, null, 2))}</pre></div><div style="display:flex;gap:8px;margin-top:12px"><button id="retryRecycle">Retry</button><button id="showLocal" class="small-btn">Show locally-deleted</button><button id="closeRecycle" class="btn-ghost">Close</button></div>`; showModal(html); document.getElementById('retryRecycle').onclick = ()=>{ closeModal(); openRecycleModal(); }; document.getElementById('showLocal').onclick = ()=>{ closeModal(); const s = collectDeletedFromTree(treeCache); showRecycleList(s.folders, s.lessons, { source: 'local' }); }; document.getElementById('closeRecycle').onclick = closeModal; }
function collectDeletedFromTree(nodes){ const folders=[]; const lessons=[]; function walk(n){ if (!n) return; if (n.isDeleted) folders.push(n); if (Array.isArray(n.lessons)) for (const l of n.lessons) if (l.isDeleted) lessons.push(l); if (Array.isArray(n.children)) for (const c of n.children) walk(c); } if (Array.isArray(nodes)) for (const n of nodes) walk(n); else walk(nodes); return { folders, lessons }; }

// ---------------- RECYLCE UI (client) ----------------


function showRecycleList(folders, lessons, opts = {}) {
  let sourceNote = opts && opts.source ? ` (source: ${opts.source})` : '';
  let html = `<h3>Recycle Bin${sourceNote}</h3><div style="max-height:55vh;overflow:auto">`;

  html += `<h4>Folders (${folders.length})</h4>`;
  folders.forEach(f => {
    const displayName = tLocalized(f.name) || (typeof f.name === 'string' ? f.name : '');
    html += `<div style="display:flex;justify-content:space-between;align-items:center;padding:6px;border-bottom:1px solid #eee">
      <div>
        <strong>${escapeHtml(displayName)}</strong>
        <div class="muted-note" style="font-size:12px">${escapeHtml(String(f._id))}</div>
      </div>
      <div style="display:flex;gap:6px">
        <button class="small-btn recycle-restore" data-id="${f._id}" data-type="folder">Restore</button>
        <button class="small-btn recycle-delete" data-id="${f._id}" data-type="folder">Delete permanently</button>
      </div>
    </div>`;
  });

  html += `<h4>Lessons (${lessons.length})</h4>`;
  lessons.forEach(l => {
    const title = tLocalized(l.title) || (l.title && l.title.en) || (typeof l.title === 'string' ? l.title : 'Untitled');
    html += `<div style="display:flex;justify-content:space-between;align-items:center;padding:6px;border-bottom:1px solid #eee">
      <div>
        <strong>${escapeHtml(title)}</strong>
        <div class="muted-note" style="font-size:12px">${escapeHtml(String(l._id))}</div>
      </div>
      <div style="display:flex;gap:6px">
        <button class="small-btn recycle-restore" data-id="${l._id}" data-type="lesson">Restore</button>
        <button class="small-btn recycle-delete" data-id="${l._id}" data-type="lesson">Delete permanently</button>
      </div>
    </div>`;
  });

  html += `</div>
    <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
      <button id="closeRecycle" class="btn-ghost">Close</button>
    </div>`;

  showModal(html);

  document.getElementById('closeRecycle').onclick = closeModal;

  // restore buttons
  document.querySelectorAll('.recycle-restore').forEach(b => {
    b.onclick = async (ev) => {
      const id = b.dataset.id;
      const type = b.dataset.type;
      if (!confirm('Restore this item?')) return;
      const ok = await tryRestoreItem(type, id);
      if (!ok) return alert('Restore failed (server). See console.');
      alert('Restored');
      closeModal();
      await loadTree();
    };
  });

  // permanent delete buttons
  document.querySelectorAll('.recycle-delete').forEach(b => {
    b.onclick = async (ev) => {
      const id = b.dataset.id;
      const type = b.dataset.type;
      if (!confirm('Permanently delete this item? This cannot be undone.')) return;
      try {
        if (type === 'folder') {
          const rr = await fetchJson(`/api/lessons/folders/${encodeURIComponent(id)}?permanent=1`, { method: 'DELETE', headers: authHeaders() });
          if (!rr.ok) return alert('Delete failed: ' + (rr.error || 'Server error'));
        } else {
          const rr = await fetchJson(`/api/lessons/${encodeURIComponent(id)}?permanent=1`, { method: 'DELETE', headers: authHeaders() });
          if (!rr.ok) return alert('Delete failed: ' + (rr.error || 'Server error'));
        }
        alert('Permanently deleted');
        closeModal();
        await loadTree();
      } catch (err) {
        console.error('permanent delete failed', err);
        alert('Delete failed (see console).');
      }
    };
  });
}

async function tryRestoreItem(type,id){ try { if (type==='folder'){ let rr=await fetchJson(`/api/lessons/folders/${encodeURIComponent(id)}/restore`,{ method:'POST', headers: authHeaders() }); if (rr.ok) return true; rr=await fetchJson(`/api/lessons/folders/${encodeURIComponent(id)}`,{ method:'PUT', 
headers: authHeaders(), body: JSON.stringify({ isDeleted:false }) }); if (rr.ok) return true; } else { let rr=await fetchJson(`/api/lessons/${encodeURIComponent(id)}/restore`,{ method:'POST', headers: authHeaders() }); 
if (rr.ok) return true; rr=await fetchJson(`/api/lessons/${encodeURIComponent(id)}`,{ method:'PUT', headers: authHeaders(), body: JSON.stringify({ isDeleted:false }) }); 
if (rr.ok) return true; } console.warn('Restore endpoints returned errors.'); return false;
 } catch(err){ console.error('Restore attempt failed', err); 
 return false; 

} }

/* ===================== UTILITIES ===================== */
function escapeHtml(s){ if (s === 0) return '0'; if (!s) return ''; return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m])); }
function pickIconForName(name){ if (!name) return 'üìÅ'; const n=name.toLowerCase(); if (n.includes('math') || n.includes('xisaab')) return 'üßÆ'; if (n.includes('computer')||n.includes('cs')||n.includes('program')||n.includes('kombuter')) return 'üíª'; if (n.includes('network')) return 'üåê'; if (n.includes('basic')||n.includes('aas')) return 'üî∞'; if (n.includes('advanced')||n.includes('mediate')||n.includes('horumarsan')) return 'üöÄ'; if (n.includes('science')) return 'üî¨'; if (n.includes('english')||n.includes('language')) return 'üìö'; return 'üìÅ'; }



/* ---------- Config & helpers ---------- */
const MIN_WITHDRAW = 30.0;
const WITHDRAWAL_24H_CAP = 100.0; // client-side UX cap

  /* helper: strict money format for summary (2 decimals) */
  function moneyFmt2(n){ return '$' + Number(n || 0).toFixed(2); }

/* safe extractor: cope with many response shapes for withdrawals */
function extractWithdrawals(resNormalized) {
  // resNormalized is what normalizeApiResponse returns (or raw fetchJson envelope)
  if (!resNormalized) return [];
  // if normalizeApiResponse returned error
  if (resNormalized.ok === false) return [];

  // try several common locations:
  // 1) normalizeApiResponse returned { ok:true, data: { withdrawals: [...] } }
  if (resNormalized.data && Array.isArray(resNormalized.data.withdrawals)) return resNormalized.data.withdrawals;

  // 1b) double-nested data.data.withdrawals (some servers)
  if (resNormalized.data && resNormalized.data.data && Array.isArray(resNormalized.data.data.withdrawals)) return resNormalized.data.data.withdrawals;

  // 2) some responses are plain { withdrawals: [...] } (not inside data)
  if (Array.isArray(resNormalized.withdrawals)) return resNormalized.withdrawals;
  if (resNormalized.data && Array.isArray(resNormalized.data)) return resNormalized.data;

  // 3) raw fetchJson envelope: { ok:true, data: <payload> } where payload may be withdrawals
  if (resNormalized.data && (Array.isArray(resNormalized.data) || Array.isArray(resNormalized.data.withdrawals))) {
    return Array.isArray(resNormalized.data) ? resNormalized.data : resNormalized.data.withdrawals;
  }

  // 4) last resort: if resNormalized itself is an array
  if (Array.isArray(resNormalized)) return resNormalized;

  return [];
}

function moneyFmt(n){ return '$' + (Number(n||0)).toFixed(3); }
function numFmt(n){ return (Number(n||0)).toLocaleString(); }

function getToken(){ return (window.Auth && window.Auth.getToken) ? window.Auth.getToken() : localStorage.getItem('token'); }
function getUser(){ return (window.Auth && window.Auth.getUser) ? window.Auth.getUser() : (()=>{ const s=localStorage.getItem('user'); return s?JSON.parse(s):null; })(); }
function isAdmin(){ const u=getUser(); return u && u.role==='admin'; }
function authHeaders(json=true){
  const t=getToken();
  const h = {};
  if (t) h['Authorization']='Bearer '+t;
  if (json) h['Content-Type']='application/json';
  return h;
}
/**
 * computeWithdrawalStats(list, cap)
 * - list: array of withdrawal objects (may include fields: amount, status, requestedAt, createdAt, verifiedAt)
 * - cap: numeric 24h cap
 *
 * returns {
 *   spent24, pending24, remainingVerified, remainingIncludingPending, nextAllowedAtIso
 * }
 */
function computeWithdrawalStats(list = [], cap = WITHDRAWAL_24H_CAP) {
  const now = Date.now();
  const windowStart = now - 24 * 3600 * 1000;

  // normalize and filter by relevant timestamps
  const verifieds = (list || [])
    .filter(w => _statusLower(w.status) === 'verified')
    .map(w => ({ amount: safeNum(w.amount), ts: (new Date(w.verifiedAt || w.updatedAt || w.createdAt || w.requestedAt || 0)).getTime() }))
    .filter(w => w.ts && w.ts >= windowStart && w.ts <= now)
    .sort((a,b) => a.ts - b.ts); // ascending by time

  const pendings = (list || [])
    .filter(w => _statusLower(w.status) === 'pending')
    .map(w => ({ amount: safeNum(w.amount), ts: (new Date(w.requestedAt || w.createdAt || 0)).getTime() }))
    .filter(w => w.ts && w.ts >= windowStart && w.ts <= now);

  const spent24 = verifieds.reduce((s, w) => s + w.amount, 0);
  const pending24 = pendings.reduce((s, w) => s + w.amount, 0);

  const remainingVerified = Math.max(0, cap - spent24);
  const remainingIncludingPending = Math.max(0, cap - (spent24 + pending24));

  // compute nextAllowedAtIso: the earliest expiry of verifieds such that after that expiry spent24 < cap
  let nextAllowedAtIso = null;
  if (spent24 >= cap && verifieds.length) {
    // total spent in window
    const total = spent24;
    // prefix sums of verified amounts
    let prefix = 0;
    for (let i = 0; i < verifieds.length; i++) {
      // consider the moment when verifieds[i] expires (verifieds[i].ts + 24h)
      prefix += verifieds[i].amount;
      const remainingAfterExpiry = total - prefix; // spent after this earliest item expires
      if (remainingAfterExpiry < cap) {
        // earliest time where cap will no longer be reached is verifieds[i].ts + 24h
        nextAllowedAtIso = new Date(verifieds[i].ts + 24*3600*1000).toISOString();
        break;
      }
    }
    // if loop ends without break, set it to last verified expiry (fallback)
    if (!nextAllowedAtIso) {
      const lastTs = verifieds[verifieds.length - 1].ts;
      nextAllowedAtIso = new Date(lastTs + 24*3600*1000).toISOString();
    }
  }

  return {
    spent24,
    pending24,
    remainingVerified,
    remainingIncludingPending,
    nextAllowedAtIso
  };
}


/* safe wrapper for low-level fetchJson */
async function fetchJson(path, opts={}) {
  try {
    const url = path.startsWith('http') ? path : ( (typeof API_BASE === 'string' && API_BASE) ? API_BASE + path : path );
    const res = await fetch(url, opts);
    const text = await res.text();
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch(e) { data = null; }
    if (!res.ok) {
      return { ok:false, status: res.status, error: (data && (data.error||data.message)) ? (data.error||data.message) : res.statusText, data, rawText: text };
    }
    return { ok:true, status: res.status, data, rawText: text };
  } catch (err) {
    return { ok:false, error: err.message || 'Network error' };
  }
}

async function safeFetchJson(url, opts={}) {
  try {
    return await fetchJson(url, opts);
  } catch (err) {
    console.error('safeFetchJson error', url, err);
    return { ok: false, error: err && err.message ? err.message : 'Network error' };
  }
}

/**
 * normalizeApiResponse(res)
 * Produces a single shape:
 *   { ok: true, data: {...} } or { ok:false, error: '...' }
 *
 * Supports:
 * - fetchJson envelope: { ok:true, data: <apiBody> }
 * - api body envelope: { ok:true, data: {...} }
 * - legacy body: { balance:..., user:... }
 * - error shapes: { ok:false, error:... } or { error:... }
 */

/* safer normalizeApiResponse (handles server envelopes like { ok:true, withdrawals: [...] } ) */
function normalizeApiResponse(res) {
  if (!res) return { ok: false, error: 'No response' };

  // If res is the fetchJson envelope (it has boolean ok)
  if (typeof res.ok === 'boolean') {
    if (!res.ok) {
      const err = res.error || (res.data && (res.data.error || res.data.message)) || 'Network or server error';
      return { ok: false, error: err };
    }

    // payload is the server response body (res.data)
    const payload = res.data || {};

    // If server returned its own envelope { ok: boolean, ... } we should accept other keys
    if (typeof payload.ok === 'boolean') {
      if (!payload.ok) {
        return { ok: false, error: payload.error || payload.message || 'Server error' };
      }
      // Prefer returning payload.data if present (legacy).
      // If payload contains meaningful fields like withdrawals/balance/user etc, return payload itself.
      if (payload.data && (typeof payload.data === 'object')) {
        return { ok: true, data: payload.data };
      }
      // If payload has known top-level fields, return payload as data (fix for your server shape)
      const knownFields = ['withdrawals','balance','user','spent24','remaining','cap','nextAllowedAt','convertedPoints','addedDollar'];
      for (const k of knownFields) {
        if (Object.prototype.hasOwnProperty.call(payload, k)) {
          return { ok: true, data: payload };
        }
      }
      // Nothing known - return empty data object
      return { ok: true, data: {} };
    }

    // Legacy shapes: top-level fields directly (payload has withdrawals,balance,user etc)
    if (payload.withdrawals || payload.balance || payload.user || payload.convertedPoints !== undefined || payload.addedDollar !== undefined) {
      return { ok: true, data: payload };
    }

    // Fallback: return payload as data
    return { ok: true, data: payload };
  }

  // If res doesn't have boolean ok (rare): treat as server data
  if (typeof res === 'object') {
    if (res.error || res.message) return { ok: false, error: res.error || res.message };
    if (res.balance || res.user || res.data) return { ok: true, data: res.data || res };
    return { ok: true, data: res };
  }

  return { ok: false, error: 'Unexpected response shape' };
}

/* safe extractor for withdrawals (robust) */
function extractWithdrawals(resNormalized) {
  if (!resNormalized) return [];
  if (resNormalized.ok === false) return [];
  // normalized shape -> r.data may hold fields
  const d = resNormalized.data || {};
  if (Array.isArray(d.withdrawals)) return d.withdrawals;
  if (Array.isArray(resNormalized.withdrawals)) return resNormalized.withdrawals;
  if (Array.isArray(d)) return d;
  return [];
}

/* animate number with easing */
function animateNumber({ el, start = 0, end = 0, duration = 1200, decimals = 0, onFrame = null }) {
  const startTime = performance.now();
  const easeOut = t => 1 - Math.pow(1 - t, 3);
  return new Promise(resolve => {
    function step(now) {
      const t = Math.min(1, (now - startTime) / duration);
      const v = start + (end - start) * easeOut(t);
      const display = (decimals === 0) ? Math.round(v) : v.toFixed(decimals);
      el.textContent = display;
      if (onFrame) onFrame(v);
      if (t < 1) requestAnimationFrame(step);
      else resolve();
    }
    requestAnimationFrame(step);
  });
}

/* ---------- Utilities (add/replace) ---------- */

function parseApiArray(resp, key) {
  // Try multiple shapes where the array may live
  if (!resp) return [];
  if (resp.data && Array.isArray(resp.data[key])) return resp.data[key];
  if (Array.isArray(resp.data)) return resp.data;
  if (Array.isArray(resp[key])) return resp[key];
  if (resp.data && Array.isArray(resp.data.withdrawals) && key === 'withdrawals') return resp.data.withdrawals;
  return [];
}

function safeNum(v) { const n = Number(v); return Number.isFinite(n) ? n : 0; }

function formatHHMMSS(ms) {
  if (ms <= 0) return '00:00:00';
  const s = Math.floor(ms / 1000);
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = s % 60;
  return `${String(h).padStart(2,'0')}h:${String(m).padStart(2,'0')}m:${String(sec).padStart(2,'0')}s`;
}

/* improved playTick (replace previous) */
function playTick() {
  try {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return; // no audio supported

    const ctx = new Ctx();
    // resume if suspended (some browsers require user interaction)
    if (ctx.state === 'suspended' && typeof ctx.resume === 'function') {
      ctx.resume().catch(()=>{ /* silent */ });
    }

    Promise.resolve(ctx.resume()).then(() => {
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.value = 900;
      // tiny ramp to avoid pops
      g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.06, ctx.currentTime + 0.01);
      o.connect(g); g.connect(ctx.destination);
      o.start();
      setTimeout(()=>{
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.04);
        setTimeout(()=>{ try { o.stop(); ctx.close(); } catch(e){} }, 60);
      }, 80);
    }).catch(()=>{/* ignore resume failures */});
  } catch(e) {
    // ignore audio errors
  }
}

/* local conversion history */
const LOCAL_CONV_KEY = 'app_convert_history_v1';
function saveConvertHistory(entry) {
  try {
    const list = JSON.parse(localStorage.getItem(LOCAL_CONV_KEY) || '[]');
    list.unshift(entry);
    localStorage.setItem(LOCAL_CONV_KEY, JSON.stringify(list.slice(0,200)));
  } catch(e){}
}
function loadConvertHistory() {
  try { return JSON.parse(localStorage.getItem(LOCAL_CONV_KEY) || '[]'); } catch(e) { return []; }
}



function _normalizeWithdrawListShape(rawRes) {
  // returns array of withdrawals (safe)
  try {
    const nr = normalizeApiResponse(rawRes);
    if (!nr.ok) return [];
    const d = nr.data || {};
    if (Array.isArray(d.withdrawals)) return d.withdrawals;
    if (Array.isArray(d)) return d;
    // some responses: { withdrawals: [...] } at top-level inside fetch envelope
    if (Array.isArray(rawRes.data && rawRes.data.withdrawals)) return rawRes.data.withdrawals;
    if (Array.isArray(rawRes.withdrawals)) return rawRes.withdrawals;
  } catch(e){}
  return [];
}

function _statusLower(v){
  try { return (v||'').toString().toLowerCase(); } catch(e){ return ''; }
}

/* ---------- Balance / Convert UI (robust) ---------- */

/* ---------- Balance modal (updated) ---------- */

async function openBalanceModal(){
  // load balance + summary + withdrawals concurrently
  const [rawBal, rawSummary, rawList] = await Promise.all([
    safeFetchJson('/api/account/balance', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdrawals', { headers: authHeaders() })
  ]);

  const balRes = normalizeApiResponse(rawBal);
  if (!balRes.ok) {
    if (!getToken()) return alert('No authorization token found ‚Äî please log in.');
    return alert(balRes.error || 'Failed to load balance');
  }

  const b = (balRes.data && balRes.data.balance) ? balRes.data.balance : {};
  const user = (balRes.data && balRes.data.user) ? balRes.data.user : getUser() || {};
  const points = Number(b.pointsCurrent || 0);
  const balanceDollar = Number(b.balanceDollar || 0);

  const sumRes = normalizeApiResponse(rawSummary);
  const list = _normalizeWithdrawListShape(rawList);

  const capVal = (sumRes && sumRes.data && sumRes.data.cap) ? Number(sumRes.data.cap) : WITHDRAWAL_24H_CAP;
  const spent24 = (sumRes && sumRes.data && typeof sumRes.data.spent24 === 'number') ? Number(sumRes.data.spent24) : ((list||[]).filter(w=>_statusLower(w.status)==='verified').reduce((s,w)=>s+safeNum(w.amount),0));
  const pending24 = (sumRes && sumRes.data && typeof sumRes.data.pending24 === 'number') ? Number(sumRes.data.pending24) : ((list||[]).filter(w=>_statusLower(w.status)==='pending').reduce((s,w)=>s+safeNum(w.amount),0));
  const remainingVerified = (sumRes && sumRes.data && sumRes.data.remainingVerified !== undefined) ? Number(sumRes.data.remainingVerified) : Math.max(0, capVal - spent24);
  const remainingIncludingPending = (sumRes && sumRes.data && sumRes.data.remainingIncludingPending !== undefined) ? Number(sumRes.data.remainingIncludingPending) : Math.max(0, capVal - (spent24 + pending24));
  const nextAllowedAtIso = (sumRes && sumRes.data && sumRes.data.nextAllowedAt) ? sumRes.data.nextAllowedAt : null;

  const withdrawDisabled = (remainingIncludingPending <= 0 && !(safeNum(spent24) === 0 && safeNum(pending24) === 0));

  const html = `
    <div class="balance-modal" role="dialog" aria-modal="true" aria-labelledby="bal_title">
      <h3 id="bal_title">Your Balance</h3>
      <div class="balance-user">
        <div class="balance-avatar">${escapeHtml((user.fullName||user.username||'U').slice(0,2)).toUpperCase()}</div>
        <div style="flex:1">
          <div style="font-weight:700">${escapeHtml(user.fullName || user.username || '')}</div>
          <div class="small-muted">${escapeHtml(user.email || '')}</div>
        </div>
      </div>

      <div class="balance-row" style="margin-top:14px">
        <div class="balance-col">
          <div class="small-muted">Points</div>
          <div class="counter" id="bal_points">0</div>
          <div class="counter-sub">Current points</div>
        </div>
        <div style="width:14px"></div>
        <div class="balance-col" style="text-align:right">
          <div class="small-muted">Dollar Balance</div>
          <div class="counter" id="bal_dollars">0.000</div>
          <div class="counter-sub">Available dollars</div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div id="bal_remaining_box" class="small-muted"></div>
      </div>

      <div class="btn-row" style="margin-top:8px">
        <button id="bal_convert" class="btn-ghost small-cta">Convert Points ‚Üí $</button>
        <button id="bal_withdraw" class="btn small-cta btn-withdraw" ${withdrawDisabled ? 'disabled' : ''}>Withdraw</button>
        <button id="bal_requests" class="btn-ghost small-cta">My Requests</button>
        <button id="bal_close" class="btn-ghost small-cta">Close</button>
      </div>
      <div class="small-muted" style="margin-top:6px">
        Tip: convert only if you have at least 100 points. Withdrawals require at least $${MIN_WITHDRAW} available and max $${WITHDRAWAL_24H_CAP} verified per 24 hours.
      </div>
    </div>
  `;
  showModal(html);

  // render remaining box
  const remBox = document.getElementById('bal_remaining_box');
  let balCountdown = null;
  function clearBalCountdown(){ if (balCountdown) { clearInterval(balCountdown); balCountdown = null; } }

  const renderRemainingBox = () => {
    if ((safeNum(spent24) + safeNum(pending24)) <= 0) {
      remBox.innerHTML = `<div style="color:#15803d;font-weight:700">Remaining verified allowance in last 24h: <strong>$${Number(capVal).toFixed(3)}</strong></div>`;
    } else if (remainingIncludingPending > 0) {
      remBox.innerHTML = `<div>24h used: <strong>${moneyFmt(spent24)}</strong> ‚Ä¢ pending: <strong>${moneyFmt(pending24)}</strong></div>
                          <div>Remaining (including pending): <strong>$${Number(remainingIncludingPending).toFixed(3)}</strong></div>`;
    } else {
      remBox.style.color = '#b91c1c';
      if (nextAllowedAtIso) {
        const target = new Date(nextAllowedAtIso).getTime();
        const update = () => {
          const left = target - Date.now();
          if (left <= 0) {
            clearBalCountdown();
            remBox.style.color = '';
            remBox.innerHTML = `<div class="small-muted">24h verified cap has reset ‚Äî you can make a verified withdrawal now.</div>`;
            const bw = document.getElementById('bal_withdraw'); if (bw) bw.disabled = false;
            return;
          }
          const total = Math.floor(left/1000);
          const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
          const pad = v => String(v).padStart(2,'0');
          remBox.innerHTML = `<strong style="color:#b91c1c">Next allowed in: ${pad(h)}:${pad(m)}:${pad(s)} ‚Äî Remaining (including pending): $0.000</strong>`;
        };
        update(); balCountdown = setInterval(update, 1000);
      } else {
        remBox.innerHTML = `<strong style="color:#b91c1c">Remaining verified allowance for making withdrawal: unknown (cap reached)</strong>`;
      }
    }
  };
  renderRemainingBox();

  // wire buttons
  document.getElementById('bal_close').onclick = () => { clearBalCountdown(); closeModal(); };
  document.getElementById('bal_requests').onclick = async () => { clearBalCountdown(); closeModal(); await openMyRequests(); };
  document.getElementById('bal_convert').onclick = async () => { clearBalCountdown(); closeModal(); await openConvertModal(); };
  document.getElementById('bal_withdraw').onclick = async () => { clearBalCountdown(); closeModal(); await openWithdrawModal(); };

  // animate numbers
  try {
    const pointsEl = document.getElementById('bal_points');
    const dollarsEl = document.getElementById('bal_dollars');
    await Promise.all([
      animateNumber({ el: pointsEl, start: 0, end: Math.round(points), duration: 900, decimals:0, onFrame: v=>{pointsEl.textContent=numFmt(Math.round(v));} }),
      animateNumber({ el: dollarsEl, start: 0, end: balanceDollar, duration: 1200, decimals:3, onFrame: v=>{dollarsEl.textContent=Number(v).toFixed(3);} })
    ]);
    try{ playTick(); }catch(e){}
  } catch(e){
    const pointsEl = document.getElementById('bal_points'); const dollarsEl = document.getElementById('bal_dollars');
    if (pointsEl) pointsEl.textContent = numFmt(Math.round(points));
    if (dollarsEl) dollarsEl.textContent = Number(balanceDollar).toFixed(3);
  }
}

/* ---------------- Admin button wiring (use addEventListener to be robust) ---------------- */


async function openConvertModal(){
  const raw = await safeFetchJson('/api/account/balance', { headers: authHeaders() });
  const r = normalizeApiResponse(raw);
  if (!r.ok) return alert(r.error || 'Failed to load');

  const pts = Number((r.data && r.data.balance && r.data.balance.pointsCurrent) || 0);
  const estAll = pts * 0.003;

  const html = `
    <div class="balance-modal">
      <h3>Convert Points</h3>
      <div style="margin-top:8px">
        <div class="small-muted">Points available</div>
        <div style="font-weight:700; font-size:18px">${numFmt(pts)}</div>
        <div class="small-muted" style="margin-top:6px">If convert all ‚Üí ${moneyFmt(estAll)}</div>
        <label style="display:block;margin-top:12px">Points to convert (leave blank to convert all)</label>
        <input id="conv_points" type="number" min="0" placeholder="${pts}" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button id="conv_cancel" class="btn-ghost">Cancel</button>
          <button id="conv_do" class="btn">Convert</button>
        </div>
        <div class="small-muted" style="margin-top:8px">Note: Minimum 100 points required to convert.</div>
      </div>
    </div>
  `;
  showModal(html);
  document.getElementById('conv_cancel').onclick = closeModal;
  document.getElementById('conv_do').onclick = async () => {
    const pVal = (document.getElementById('conv_points').value || '').trim();
    const toConvert = pVal ? Number(pVal) : pts;
    if (!Number.isFinite(toConvert) || toConvert <= 0) return alert('Enter points to convert');
    if (toConvert < 100) return alert('Minimum 100 points required to convert to dollars.');
    if (toConvert > pts) return alert('You do not have that many points.');

    const rawRes = await safeFetchJson('/api/account/convert', {
      method: 'POST',
      headers: authHeaders(true),
      body: JSON.stringify({ points: toConvert })
    });
    const res = normalizeApiResponse(rawRes);
    if (!res.ok) return alert(res.error || 'Convert failed');

    const convertedPoints = (res.data && (res.data.convertedPoints !== undefined)) ? res.data.convertedPoints : toConvert;
    const addedDollar = (res.data && (res.data.addedDollar !== undefined)) ? res.data.addedDollar : (convertedPoints * 0.003);

    saveConvertHistory({
      id: 'conv_' + Date.now(),
      requestedAt: new Date().toISOString(),
      points: Number(convertedPoints),
      dollars: Number(addedDollar),
      serverResponse: res.data || {}
    });

    alert('Converted: ' + numFmt(convertedPoints) + ' points ‚Üí ' + moneyFmt(addedDollar));
    closeModal();
    if (typeof applyNavUI === 'function') applyNavUI();
  };
}

async function openConvertBackModal(){
  const raw = await safeFetchJson('/api/account/balance', { headers: authHeaders() });
  const r = normalizeApiResponse(raw);
  if (!r.ok) return alert(r.error || 'Failed to load');

  const balanceDollar = Number((r.data && r.data.balance && r.data.balance.balanceDollar) || 0);
  const estPoints = Math.floor(balanceDollar / 0.003);

  const html = `
    <div class="balance-modal">
      <h3>Convert Dollars ‚Üí Points</h3>
      <div style="margin-top:8px">
        <div class="small-muted">Dollar balance</div>
        <div style="font-weight:700; font-size:18px">${moneyFmt(balanceDollar)}</div>
        <div class="small-muted" style="margin-top:6px">Estimate points if converting all: ${numFmt(estPoints)}</div>
        <label style="display:block;margin-top:12px">Amount to convert (leave blank to convert all)</label>
        <input id="convback_amount" type="number" min="0" placeholder="${moneyFmt(balanceDollar)}" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button id="convback_cancel" class="btn-ghost">Cancel</button>
          <button id="convback_do" class="btn">Convert to Points</button>
        </div>
        <div class="small-muted" style="margin-top:8px">Server endpoint: POST /api/account/convert-back</div>
      </div>
    </div>
  `;
  showModal(html);
  document.getElementById('convback_cancel').onclick = closeModal;
  document.getElementById('convback_do').onclick = async () => {
    const amtRaw = (document.getElementById('convback_amount').value || '').trim();
    const payload = {};
    if (amtRaw) payload.amount = Number(amtRaw);

    const rawRes = await safeFetchJson('/api/account/convert-back', {
      method: 'POST',
      headers: authHeaders(true),
      body: JSON.stringify(payload)
    });
    const res = normalizeApiResponse(rawRes);
    if (!res.ok) return alert(res.error || 'Server does not support convert-back.');

    saveConvertHistory({
      id: 'convback_' + Date.now(),
      requestedAt: new Date().toISOString(),
      points: (res.data && res.data.addedPoints) || 0,
      dollars: -((res.data && res.data.deductedDollar) || (payload.amount || 0)),
      serverResponse: res.data || {}
    });
    alert('Converted dollars to points successfully.');
    closeModal();
  };
}

/* ---------- Withdraw modal (updated UX: disable, red countdown, explicit messages) ---------- */

async function openWithdrawModal() {
  // load balance + summary + withdrawals
  const [rawBal, rawSummary, rawList] = await Promise.all([
    safeFetchJson('/api/account/balance', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdrawals', { headers: authHeaders() })
  ]);

  const balRes = normalizeApiResponse(rawBal);
  if (!balRes.ok) {
    if (!getToken()) return alert('Please login.');
    return alert(balRes.error || 'Failed to load balance');
  }
  const bal = Number((balRes.data && balRes.data.balance && balRes.data.balance.balanceDollar) || 0);

  const sumRes = normalizeApiResponse(rawSummary);
  const list = _normalizeWithdrawListShape(rawList);

  // prefer server-provided fields, otherwise compute from list
  const capVal = (sumRes && sumRes.data && sumRes.data.cap) ? Number(sumRes.data.cap) : WITHDRAWAL_24H_CAP;
  const spent24 = (sumRes && sumRes.data && typeof sumRes.data.spent24 === 'number') ? Number(sumRes.data.spent24) : (
    (list || []).filter(w => _statusLower(w.status) === 'verified').reduce((s,w)=>s+safeNum(w.amount), 0)
  );
  const pending24 = (sumRes && sumRes.data && typeof sumRes.data.pending24 === 'number') ? Number(sumRes.data.pending24) : (
    (list || []).filter(w => _statusLower(w.status) === 'pending').reduce((s,w)=>s+safeNum(w.amount), 0)
  );

  const remainingVerified = (sumRes && sumRes.data && sumRes.data.remainingVerified !== undefined) ? Number(sumRes.data.remainingVerified) : Math.max(0, capVal - spent24);
  const remainingIncludingPending = (sumRes && sumRes.data && sumRes.data.remainingIncludingPending !== undefined) ? Number(sumRes.data.remainingIncludingPending) : Math.max(0, capVal - (spent24 + pending24));
  let nextAllowedAtIso = (sumRes && sumRes.data && sumRes.data.nextAllowedAt) ? sumRes.data.nextAllowedAt : null;

  // fallback: derive nextAllowedAt from earliest contributing verified/pending in list when needed
  if (!nextAllowedAtIso && (spent24 + pending24) >= capVal) {
    try {
      const since = new Date(Date.now() - 24*3600*1000);
      const contributors = (list||[]).filter(w => {
        const d = new Date(w.requestedAt || w.createdAt || 0);
        return d >= since && ( _statusLower(w.status) === 'verified' || _statusLower(w.status) === 'pending' );
      }).sort((a,b) => new Date(a.requestedAt||a.createdAt||0) - new Date(b.requestedAt||b.createdAt||0));
      if (contributors.length) {
        const earliest = new Date(contributors[0].requestedAt || contributors[0].createdAt || 0);
        nextAllowedAtIso = new Date(earliest.getTime() + 24*3600*1000).toISOString();
      }
    } catch(e){}
  }

  const html = `
    <div class="balance-modal">
      <h3>Withdraw</h3>
      <div style="margin-top:8px">
        <div class="small-muted">Available</div>
        <div style="font-weight:700; font-size:18px">${moneyFmt(bal)}</div>

        <label style="display:block;margin-top:12px">Phone / Account number</label>
        <input id="wd_phone" placeholder="+2519xxxxxxxx" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">

        <label style="display:block;margin-top:8px">Amount (leave blank for full)</label>
        <input id="wd_amount" type="number" min="0" placeholder="${moneyFmt(bal)}" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">

        <div id="withdraw_info" style="margin-top:8px" class="small-muted"></div>

        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button id="wd_cancel" class="btn-ghost">Cancel</button>
          <button id="wd_submit" class="btn btn-withdraw">Request Withdraw</button>
        </div>

        <div class="small-muted" style="margin-top:8px">Minimum: $${MIN_WITHDRAW}. 24h cap (verified): $${capVal}.</div>
      </div>
    </div>
  `;
  showModal(html);

  const infoEl = document.getElementById('withdraw_info');
  const submitBtn = document.getElementById('wd_submit');
  const cancelBtn = document.getElementById('wd_cancel');

  let countdownInterval = null;
  function clearCountdown(){ if (countdownInterval){ clearInterval(countdownInterval); countdownInterval = null; } }
  cancelBtn.onclick = () => { clearCountdown(); closeModal(); };

  // Render informative summary
  const renderSummary = () => {
    // Show spent, pending, two remaining numbers
    let lines = [];
    lines.push(`<div>24h verified used: <strong>${moneyFmt(spent24)}</strong></div>`);
    lines.push(`<div>24h pending: <strong>${moneyFmt(pending24)}</strong></div>`);
    lines.push(`<div>Remaining (verified only): <strong>$${Number(remainingVerified).toFixed(3)}</strong></div>`);
    lines.push(`<div>Remaining (including pending): <strong>$${Number(remainingIncludingPending).toFixed(3)}</strong></div>`);
    infoEl.style.color = remainingIncludingPending <= 0 ? '#b91c1c' : '';
    infoEl.innerHTML = lines.join('');
  };
  renderSummary();

  // if cap reached (including pending) show countdown or unknown
  if (remainingIncludingPending <= 0) {
    submitBtn.disabled = true;
    if (nextAllowedAtIso) {
      const target = new Date(nextAllowedAtIso).getTime();
      const update = () => {
        const left = target - Date.now();
        if (left <= 0) { clearCountdown(); submitBtn.disabled = false; infoEl.style.color = ''; infoEl.innerHTML = `<span class="small-muted">24h verified cap has reset ‚Äî you can make a verified withdrawal now.</span>`; return; }
        const total = Math.floor(left/1000);
        const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
        const pad = v=>String(v).padStart(2,'0');
        infoEl.innerHTML = `<strong style="color:#b91c1c">Next allowed in: ${pad(h)}:${pad(m)}:${pad(s)} ‚Äî Remaining (including pending): $0.000</strong>`;
      };
      update(); countdownInterval = setInterval(update, 1000);
    } else {
      infoEl.innerHTML = `<strong style="color:#b91c1c">Remaining verified allowance for making withdrawal: unknown (cap reached)</strong>`;
    }
  } else {
    submitBtn.disabled = false;
  }

  // SUBMIT handler
  submitBtn.onclick = async () => {
    const phone = (document.getElementById('wd_phone').value || '').trim();
    const amtRaw = (document.getElementById('wd_amount').value || '').trim();
    if (!phone) return alert('Phone required');

    // re-check fresh summary + withdrawals + balance
    const [freshSummaryRaw, freshListRaw, freshBalRaw] = await Promise.all([
      safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() }),
      safeFetchJson('/api/account/withdrawals', { headers: authHeaders() }),
      safeFetchJson('/api/account/balance', { headers: authHeaders() })
    ]);
    const freshSummary = normalizeApiResponse(freshSummaryRaw);
    const freshList = _normalizeWithdrawListShape(freshListRaw);
    const freshBal = normalizeApiResponse(freshBalRaw);
    const freshCap = (freshSummary && freshSummary.data && freshSummary.data.cap) ? Number(freshSummary.data.cap) : capVal;
    const freshSpent = (freshSummary && freshSummary.data && typeof freshSummary.data.spent24 === 'number') ? Number(freshSummary.data.spent24) : 0;
    const freshPending = (freshSummary && freshSummary.data && typeof freshSummary.data.pending24 === 'number') ? Number(freshSummary.data.pending24) :
                         ( (freshList||[]).filter(w=>_statusLower(w.status)==='pending').reduce((s,w)=>s+safeNum(w.amount),0) );
    const freshRemainingIncluding = Math.max(0, freshCap - (freshSpent + freshPending));
    const freshBalance = (freshBal && freshBal.data && freshBal.data.balance) ? Number(freshBal.data.balance.balanceDollar || 0) : bal;

    const payload = { phone };
    if (amtRaw) payload.amount = Number(amtRaw);
    const amount = payload.amount === undefined ? freshBalance : Number(payload.amount);
    if (Number.isNaN(amount) || amount <= 0) return alert('Enter a valid amount');

    if (freshBalance < MIN_WITHDRAW) return alert(`You need at least $${MIN_WITHDRAW} to make a withdraw.`);
    if (amount < MIN_WITHDRAW) return alert(`Withdrawal amount must be at least $${MIN_WITHDRAW}.`);
    if (amount > freshBalance) return alert('Cannot request more than your available balance.');
    if (freshRemainingIncluding <= 0) { submitBtn.disabled = true; return alert(`Cannot request: you've reached the verified 24h cap of $${freshCap}.`); }
    if (amount > freshRemainingIncluding) return alert(`Request would exceed your remaining verified allowance ($${freshRemainingIncluding.toFixed(3)}). Reduce amount or wait.`);

    // send request
    const rawRes = await safeFetchJson('/api/account/withdraw', {
      method: 'POST',
      headers: authHeaders(true),
      body: JSON.stringify(payload)
    });

    // handle server refusal with remaining/nextAllowedAt
    if (!rawRes || (typeof rawRes.ok === 'boolean' && !rawRes.ok)) {
      const rem = rawRes && (rawRes.remaining !== undefined ? Number(rawRes.remaining) : (rawRes.remainingIncludingPending !== undefined ? Number(rawRes.remainingIncludingPending) : null));
      const nxt = rawRes && rawRes.nextAllowedAt ? rawRes.nextAllowedAt : (rawRes.data && rawRes.data.nextAllowedAt ? rawRes.data.nextAllowedAt : null);
      if (rem !== null || nxt) {
        let msg = (rawRes && rawRes.error) ? rawRes.error : 'Withdraw blocked';
        if (rem !== null) msg += ` ‚Äî Remaining verified allowance: $${rem.toFixed(3)}.`;
        if (nxt) msg += ` Next allowed around: ${new Date(nxt).toLocaleString()}`;
        return alert(msg);
      }
      const resp = normalizeApiResponse(rawRes);
      return alert(resp.error || 'Failed to request withdraw');
    }

    // success path: prefer server-returned remaining/pending/spent/nextAllowedAt
    const respNorm = normalizeApiResponse(rawRes);
    let serverSpent = null, serverPending = null, serverRemainingInc = null, serverNext = null;
    if (rawRes && rawRes.data) {
      serverSpent = rawRes.data.spent24 !== undefined ? Number(rawRes.data.spent24) : null;
      serverPending = rawRes.data.pending24 !== undefined ? Number(rawRes.data.pending24) : null;
      serverRemainingInc = (rawRes.data.remainingIncludingPending !== undefined) ? Number(rawRes.data.remainingIncludingPending) : (rawRes.data.remaining !== undefined ? Number(rawRes.data.remaining) : null);
      serverNext = rawRes.data.nextAllowedAt || rawRes.nextAllowedAt || null;
    } else if (respNorm && respNorm.data) {
      serverSpent = respNorm.data.spent24 !== undefined ? Number(respNorm.data.spent24) : null;
      serverPending = respNorm.data.pending24 !== undefined ? Number(respNorm.data.pending24) : null;
      serverRemainingInc = respNorm.data.remainingIncludingPending !== undefined ? Number(respNorm.data.remainingIncludingPending) : null;
      serverNext = respNorm.data.nextAllowedAt || null;
    }

    alert('Withdrawal requested and is now pending admin verification.');

    // update UI immediately:
    clearCountdown();

    if (serverRemainingInc !== null) {
      if (serverRemainingInc > 0) {
        infoEl.style.color = '';
        infoEl.innerHTML = `Remaining verified allowance in last 24h: <strong>$${Number(serverRemainingInc).toFixed(3)}</strong>`;
        submitBtn.disabled = false;
      } else {
        submitBtn.disabled = true;
        if (serverNext) {
          const target = new Date(serverNext).getTime();
          const update = () => {
            const left = target - Date.now();
            if (left <= 0) { clearCountdown(); submitBtn.disabled = false; infoEl.style.color = ''; infoEl.innerHTML = `<span class="small-muted">24h verified cap has reset ‚Äî you can make a verified withdrawal now.</span>`; return; }
            const total = Math.floor(left/1000); const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
            const pad = v=>String(v).padStart(2,'0');
            infoEl.innerHTML = `<strong style="color:#b91c1c">Next allowed in: ${pad(h)}:${pad(m)}:${pad(s)} ‚Äî Remaining (including pending): $0.000</strong>`;
          };
          update(); countdownInterval = setInterval(update, 1000);
        } else {
          infoEl.innerHTML = `<strong style="color:#b91c1c">Remaining verified allowance for making withdrawal: unknown (cap reached)</strong>`;
        }
      }
      closeModal();
      if (typeof applyNavUI === 'function') applyNavUI();
      return;
    }

    // fallback: re-fetch summary + withdrawals to refresh UI (recommended)
    try {
      const [rSummary2, rList2] = await Promise.all([
        safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() }),
        safeFetchJson('/api/account/withdrawals', { headers: authHeaders() })
      ]);
      const nr = normalizeApiResponse(rSummary2);
      const list2 = _normalizeWithdrawListShape(rList2);
      const cap2 = (nr && nr.data && nr.data.cap) ? Number(nr.data.cap) : capVal;
      const spent2 = (nr && nr.data && typeof nr.data.spent24 === 'number') ? Number(nr.data.spent24) : 0;
      const pend2 = (nr && nr.data && typeof nr.data.pending24 === 'number') ? Number(nr.data.pending24) :
                    ( (list2||[]).filter(w=>_statusLower(w.status)==='pending').reduce((s,w)=>s+safeNum(w.amount),0) );
      const rem2 = Math.max(0, cap2 - (spent2 + pend2));
      if (rem2 > 0) {
        infoEl.style.color = '';
        infoEl.innerHTML = `Remaining verified allowance in last 24h: <strong>$${rem2.toFixed(3)}</strong>`;
        submitBtn.disabled = false;
      } else {
        submitBtn.disabled = true;
        const nextIso = (nr && nr.data && nr.data.nextAllowedAt) ? nr.data.nextAllowedAt : null;
        if (nextIso) {
          const target = new Date(nextIso).getTime();
          const update = () => {
            const left = target - Date.now();
            if (left <= 0) { clearCountdown(); submitBtn.disabled = false; infoEl.style.color = ''; infoEl.innerHTML = `<span class="small-muted">24h verified cap has reset ‚Äî you can make a verified withdrawal now.</span>`; return; }
            const total = Math.floor(left/1000); const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
            const pad = v=>String(v).padStart(2,'0');
            infoEl.innerHTML = `<strong style="color:#b91c1c">Next allowed in: ${pad(h)}:${pad(m)}:${pad(s)} ‚Äî Remaining (including pending): $0.000</strong>`;
          };
          update(); countdownInterval = setInterval(update, 1000);
        } else {
          infoEl.innerHTML = `<strong style="color:#b91c1c">Remaining verified allowance for making withdrawal: unknown (cap reached)</strong>`;
        }
      }
    } catch(e){
      // optimistic local update (best-effort)
      try {
        const newPending = pending24 + amount;
        const newRemaining = Math.max(0, capVal - (spent24 + newPending));
        if (newRemaining > 0) {
          infoEl.style.color = '';
          infoEl.innerHTML = `Remaining verified allowance in last 24h: <strong>$${newRemaining.toFixed(3)}</strong>`;
          submitBtn.disabled = false;
        } else {
          submitBtn.disabled = true;
          if (nextAllowedAtIso) {
            const target = new Date(nextAllowedAtIso).getTime();
            const update = () => {
              const left = target - Date.now();
              if (left <= 0) { clearCountdown(); submitBtn.disabled = false; infoEl.style.color = ''; infoEl.innerHTML = `<span class="small-muted">24h verified cap has reset ‚Äî you can make a verified withdrawal now.</span>`; return; }
              const total = Math.floor(left/1000); const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
              const pad = v=>String(v).padStart(2,'0');
              infoEl.innerHTML = `<strong style="color:#b91c1c">Next allowed in: ${pad(h)}:${pad(m)}:${pad(s)} ‚Äî Remaining (including pending): $0.000</strong>`;
            };
            update(); countdownInterval = setInterval(update, 1000);
          } else {
            infoEl.innerHTML = `<strong style="color:#b91c1c">Remaining verified allowance for making withdrawal: unknown (cap reached)</strong>`;
          }
        }
      } catch(_e){}
    }

    closeModal();
    if (typeof applyNavUI === 'function') applyNavUI();
  };
}

/* ---------- Requests / Admin (unchanged except normalization) ---------- */
/* ---------- openMyRequests (improved) ---------- */
async function openMyRequests(){
  const [rawList, rawSummary] = await Promise.all([
    safeFetchJson('/api/account/withdrawals', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() })
  ]);
  const listRes = normalizeApiResponse(rawList);
  const sumRes = normalizeApiResponse(rawSummary);

  let withdrawals = extractWithdrawals(listRes);
  if ((!withdrawals || !withdrawals.length) && listRes && listRes.data && Array.isArray(listRes.data)) withdrawals = listRes.data;
  if ((!withdrawals || !withdrawals.length) && rawList && rawList.data && Array.isArray(rawList.data.withdrawals)) withdrawals = rawList.data.withdrawals;

  const conversions = loadConvertHistory();

  const totalAll = (withdrawals || []).length;
  const verifiedList = (withdrawals || []).filter(w => _statusLower(w.status) === 'verified');
  const pendingList = (withdrawals || []).filter(w => _statusLower(w.status) === 'pending');
  const rejectedList = (withdrawals || []).filter(w => _statusLower(w.status) === 'rejected');
  const totalVerifiedAmount = verifiedList.reduce((s,w) => s + safeNum(w.amount), 0);

  // compute 24h stats (prefer server summary)
  const computed = computeWithdrawalStats(withdrawals || [], (sumRes && sumRes.data && sumRes.data.cap) ? Number(sumRes.data.cap) : WITHDRAWAL_24H_CAP);
  const spent24 = (sumRes && sumRes.data && typeof sumRes.data.spent24 === 'number') ? Number(sumRes.data.spent24) : computed.spent24;
  const pending24 = (sumRes && sumRes.data && typeof sumRes.data.pending24 === 'number') ? Number(sumRes.data.pending24) : computed.pending24;
  const remainingVerified = (sumRes && sumRes.data && sumRes.data.remainingVerified !== undefined) ? Number(sumRes.data.remainingVerified) : computed.remainingVerified;
  const remainingIncludingPending = (sumRes && sumRes.data && sumRes.data.remainingIncludingPending !== undefined) ? Number(sumRes.data.remainingIncludingPending) : computed.remainingIncludingPending;
  const nextAllowedAtRaw = (sumRes && sumRes.data && sumRes.data.nextAllowedAt) ? sumRes.data.nextAllowedAt : computed.nextAllowedAtIso;

  let remainingHtml = '';
  remainingHtml += `<div>24h used: <strong>${moneyFmt(spent24)}</strong> ‚Ä¢ pending: <strong>${moneyFmt(pending24)}</strong></div>`;
  if (remainingIncludingPending <= 0) {
    remainingHtml += `<div style="color:#b91c1c;font-weight:700">Remaining (including pending): $0.000 (cap reached)</div>`;
  } else {
    remainingHtml += `<div>Remaining (including pending): <strong>$${remainingIncludingPending.toFixed(3)}</strong></div>`;
  }
  remainingHtml += `<div>Remaining (verified only): <strong>$${remainingVerified.toFixed(3)}</strong></div>`;

  const summaryHtml = `
    <div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:8px">
      <div class="small-muted">Total requests: <strong>${totalAll}</strong></div>
      <div class="small-muted">Verified: <strong>${verifiedList.length}</strong></div>
      <div class="small-muted">Pending: <strong>${pendingList.length}</strong></div>
      <div class="small-muted">Rejected: <strong>${rejectedList.length}</strong></div>
      <div class="small-muted">Total Verified: <strong>${moneyFmt(totalVerifiedAmount)}</strong></div>
      ${remainingHtml}
      ${(nextAllowedAtRaw ? `<div id="next_allowed_box" class="small-muted">Next verified allowance: <strong id="next_allowed_countdown">${nextAllowedAtRaw}</strong></div>` : '')}
    </div>
  `;

  const wdHtml = (withdrawals.length ? withdrawals.map(w => {
    const status = String((w.status || 'pending')).toLowerCase();
    const statusClass = status === 'pending' ? 'status-pending' : (status === 'verified' ? 'status-verified' : 'status-rejected');
    const when = new Date(w.requestedAt || w.createdAt || Date.now()).toLocaleString();
    const note = escape((w.note || '').toString());
    const verifiedBy = (w.verifiedBy && typeof w.verifiedBy === 'object') ? (w.verifiedBy.fullName || w.verifiedBy.username || '') : (w.verifiedBy || '');
    const verifiedAt = w.verifiedAt ? ` ‚Ä¢ Verified at: ${new Date(w.verifiedAt).toLocaleString()}` : '';
    return `
      <div class="request-item">
        <div class="request-left">
          <div><strong>${moneyFmt(w.amount)}</strong> ‚Äî ${escape(w.phone || '')}</div>
          <div class="small-muted">${when}${verifiedAt}</div>
        </div>
        <div style="text-align:right">
          <div class="request-status ${statusClass}">${escape(w.status || 'pending')}</div>
          <div style="margin-top:8px"><small>${note}${verifiedBy ? (' ‚Ä¢ By: ' + escape(verifiedBy)) : ''}</small></div>
        </div>
      </div>
    `;
  }).join('') : `<div class="small-muted">No withdrawals found.</div>`);

  const html = `
    <div class="balance-modal">
      <h3>My Requests & History</h3>
      ${summaryHtml}
      <div style="margin-top:6px"><strong>Withdrawals</strong></div>
      <div class="requests-list">${wdHtml}</div>

      <div style="margin-top:12px"><strong>Conversions (local history)</strong></div>
      <div class="requests-list">${conversions.length ? conversions.map(c => {
        const when = new Date(c.requestedAt || Date.now()).toLocaleString();
        return `<div class="request-item"><div class="request-left"><div><strong>${numFmt(c.points||0)} pts</strong> ‚Üí ${moneyFmt(c.dollars||0)}</div><div class="small-muted">${when}</div></div><div style="text-align:right"><div class="small-muted">Converted</div></div></div>`;
      }).join('') : `<div class="small-muted">No local conversions performed yet.</div>`}</div>

      <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
        <button id="req_close" class="btn-ghost">Close</button>
        <button id="req_convert_back" class="btn-ghost">Convert $ ‚Üí pts</button>
      </div>
    </div>
  `;
  showModal(html);
  document.getElementById('req_close').onclick = closeModal;
  document.getElementById('req_convert_back').onclick = () => { closeModal(); openConvertBackModal(); };

  // start nextAllowedAt countdown if present
  const nextBox = document.getElementById('next_allowed_box');
  if (nextBox && nextAllowedAtRaw) {
    const el = document.getElementById('next_allowed_countdown');
    try {
      const target = new Date(nextAllowedAtRaw).getTime();
      if (!isNaN(target)) {
        let nextAllowedTimer = setInterval(()=>{
          const left = target - Date.now();
          if (left <= 0) {
            el.textContent = 'Now';
            clearInterval(nextAllowedTimer);
            return;
          }
          const h = Math.floor(left / 3600000);
          const m = Math.floor((left % 3600000) / 60000);
          const s = Math.floor((left % 60000) / 1000);
          el.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }, 1000);
      }
    } catch(e){}
  }
}

/* ---------------- Improved openAdminWithdrawals (frontend) ---------------- */

async function openAdminWithdrawals(){
  const raw = await safeFetchJson('/api/admin/withdrawals', { headers: authHeaders() });

  if (!raw || (typeof raw.ok === 'boolean' && !raw.ok && raw.status === 401)) {
    return alert('Not allowed ‚Äî please log in as admin.');
  }
  if (!raw || (typeof raw.ok === 'boolean' && !raw.ok && raw.status === 403)) {
    return alert('Not allowed ‚Äî admin access required.');
  }

  const rr = normalizeApiResponse(raw);
  if (!rr.ok) {
    console.error('admin.withdrawals.load error raw:', raw);
    return alert(rr.error || 'Failed to load admin withdrawals');
  }

  const list = rr.data && rr.data.withdrawals ? rr.data.withdrawals : (rr.withdrawals || []);
  const rowsHtml = list.length ? list.map(w => {
    const statusClass = w.status === 'pending' ? 'status-pending' : (w.status === 'verified' ? 'status-verified' : 'status-rejected');

    // Support populated userId (object) or plain userId string
    const requester = (w.userId && typeof w.userId === 'object')
      ? (w.userId.fullName || w.userId.username || w.userId.email || '')
      : '';

    return `
      <div class="admin-wd-item" data-id="${escapeHtml(w._id || w.id || '')}" style="display:flex;gap:12px;align-items:center;padding:10px;border-bottom:1px solid #f0f0f0">
        <div style="flex:1">
          <div><strong>${moneyFmt(w.amount)}</strong> ‚Äî ${escapeHtml(w.phone || '')}</div>
          <div class="small-muted">${escapeHtml(requester)} ‚Ä¢ ${new Date(w.requestedAt || w.createdAt || Date.now()).toLocaleString()}</div>
        </div>
        <div style="text-align:right">
          <div class="request-status ${statusClass}">${escapeHtml(w.status || 'pending')}</div>
          <div style="margin-top:8px; display:flex; gap:6px; justify-content:flex-end;">
            <button class="btn-ghost admin-verify-btn" data-id="${escapeHtml(w._id || w.id || '')}">Verify</button>
            <button class="btn-ghost admin-reject-btn" data-id="${escapeHtml(w._id || w.id || '')}">Reject</button>
          </div>
        </div>
      </div>
    `;
  }).join('') : `<div class="small-muted" style="padding:12px">No withdrawals found.</div>`;

  const html = `
    <div class="balance-modal" role="dialog" aria-modal="true">
      <h3>Admin ‚Äî Withdrawals</h3>
      <div style="margin-top:8px">
        <div style="max-height:380px; overflow:auto">${rowsHtml}</div>
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button id="admin_wd_close" class="btn-ghost">Close</button>
        </div>
      </div>
    </div>
  `;
  showModal(html);

  document.getElementById('admin_wd_close').onclick = closeModal;

  // VERIFY handler
  Array.from(document.getElementsByClassName('admin-verify-btn')).forEach(btn => {
    btn.onclick = async (ev) => {
      const id = ev.currentTarget.dataset.id;
      if (!id) return alert('Missing id for this withdrawal');

      if (!confirm('Mark withdrawal as VERIFIED?')) return;

      // POST verify
      const rawResp = await safeFetchJson(`/api/admin/withdrawals/${encodeURIComponent(id)}/verify`, {
        method: 'POST',
        headers: authHeaders(true)
      });

      // Print raw response to console for debugging
      console.log('verify rawResp:', rawResp);

      // normalize and show useful message
      const resp = normalizeApiResponse(rawResp);
      if (!resp.ok) {
        // prefer server-provided details
        let serverMsg = rawResp && rawResp.data && (rawResp.data.error || rawResp.data.message) ? (rawResp.data.error || rawResp.data.message) : null;
        // if rawText exists (maybe stack or HTML), include it in console only
        if (rawResp && rawResp.rawText) console.error('verify rawText:', rawResp.rawText);
        return alert(serverMsg || resp.error || 'Failed to verify withdrawal. Check server logs for details.');
      }

      alert('Withdrawal marked verified.');
      closeModal();
      if (typeof applyNavUI === 'function') applyNavUI();
    };
  });

  // REJECT handler
  Array.from(document.getElementsByClassName('admin-reject-btn')).forEach(btn => {
    btn.onclick = async (ev) => {
      const id = ev.currentTarget.dataset.id;
      if (!id) return alert('Missing id for this withdrawal');

      const reason = prompt('Enter rejection note (optional):', '');
      if (!confirm('Reject withdrawal?')) return;

      const rawResp = await safeFetchJson(`/api/admin/withdrawals/${encodeURIComponent(id)}/reject`, {
        method: 'POST',
        headers: authHeaders(true),
        body: JSON.stringify({ note: reason || '' })
      });

      console.log('reject rawResp:', rawResp);
      const resp = normalizeApiResponse(rawResp);
      if (!resp.ok) {
        let serverMsg = rawResp && rawResp.data && (rawResp.data.error || rawResp.data.message) ? (rawResp.data.error || rawResp.data.message) : null;
        if (rawResp && rawResp.rawText) console.error('reject rawText:', rawResp.rawText);
        return alert(serverMsg || resp.error || 'Failed to reject withdrawal. Check server logs.');
      }

      alert('Withdrawal rejected.');
      closeModal();
      if (typeof applyNavUI === 'function') applyNavUI();
    };
  });
}

/* attach global buttons (if present) ‚Äî declare element refs first, then wire handlers */
const balBtn = document.getElementById('btn-balance');
const convBtn = document.getElementById('btn-convert');
const convBackBtn = document.getElementById('btn-convert-back');
const adminCheckBtn = document.getElementById('btn-check-withdrawals');

if (balBtn) {
  balBtn.addEventListener('click', openBalanceModal);
}
if (convBtn) {
  convBtn.addEventListener('click', openConvertModal);
}
if (convBackBtn) {
  convBackBtn.addEventListener('click', openConvertBackModal);
}
if (adminCheckBtn) {
  adminCheckBtn.addEventListener('click', openAdminWithdrawals);
}

// Ensure API_BASE, fetchJson, getToken, getUser, authHeaders, escapeHtml are defined above this snippet


// Open edit profile modal


async function openEditProfile(){
  const token = getToken();
  if (!token) return requireLoginModal('Please login to edit your profile.');

  const r = await fetchJson('/api/auth/me', { headers: authHeaders(), method: 'GET' });
  if (!r || !r.ok) return alert('Failed to load profile: ' + (r && r.error ? r.error : ''));

  const user = r.data && r.data.user ? r.data.user : (r.data || {});
  const countrySelectHtml = buildCountrySelectHtml(user.country || '');
  const cityHtml = buildCitySelectHtml(user.country || '', user.city || '');

  const html = `
    <h3>Edit Profile</h3>
    <label>Full name</label><input id="ep_fullName" value="${escapeHtml(user.fullName||'')}" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">
    <label>Email (optional)</label><input id="ep_email" value="${escapeHtml(user.email||'')}" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">
    <label>Phone</label><input id="ep_phone" value="${escapeHtml(user.phoneNumber||user.phone||'')}" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">
    <label>Country</label>${countrySelectHtml}
    <label>City</label><div id="ep_city_container">${cityHtml}</div>
    <label>New password (leave blank to keep)</label><input id="ep_password" type="password" placeholder="New password" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">
    <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
      <button id="ep_cancel" class="btn-ghost">Cancel</button>
      <button id="ep_save" class="btn">Save</button>
    </div>
  `;
  showModal(html);

  // country change updates available city select
  document.getElementById('profile_country').addEventListener('change', (ev) => {
    const code = ev.target.value;
    document.getElementById('ep_city_container').innerHTML = buildCitySelectHtml(code, '');
  });

  document.getElementById('ep_cancel').onclick = closeModal;
  document.getElementById('ep_save').onclick = async () => {
    const fullName = (document.getElementById('ep_fullName').value || '').trim();
    const email = (document.getElementById('ep_email').value || '').trim();
    const phone = (document.getElementById('ep_phone').value || '').trim();
    const country = (document.getElementById('profile_country').value || '').trim();
    const cityEl = document.getElementById('profile_city') || document.querySelector('#ep_city_container input') || document.querySelector('#ep_city_container select');
    const city = cityEl ? (cityEl.value || '').trim() : '';
    const password = (document.getElementById('ep_password').value || '');

    if (!fullName) return alert('Full name required');
    if (phone && !/^\+?[0-9\-\s()]{7,20}$/.test(phone)) return alert('Enter a valid phone number with country code');
    if (password && password.length < 6) return alert('New password must be at least 6 characters');

    const countryFlagEmoji = codeToFlagEmoji(country);
    const countryName = (COUNTRIES.find(c => c.code === country) || {}).name || country || '';

    const payload = {
      fullName,
      email: email || undefined,
      phoneNumber: phone || undefined,
      country: country || undefined,
      countryName: countryName || undefined,
      countryFlagEmoji: countryFlagEmoji || undefined,
      city: city || undefined
    };
    if (password) payload.password = password;

    const upd = await fetchJson('/api/auth/me', {
      method: 'PUT',
      headers: authHeaders(true),
      body: JSON.stringify(payload)
    });

    if (!upd || !upd.ok) return alert('Save failed: ' + (upd && (upd.error || (upd.data && upd.data.error)) ? (upd.error || upd.data.error) : ''));
    const updatedUser = upd.data && upd.data.user ? upd.data.user : (upd.user || null);
    if (updatedUser) {
      const localUser = getUser() || {};
      const mergedUser = Object.assign({}, localUser, updatedUser);
      localStorage.setItem('user', JSON.stringify(mergedUser));
    }
    alert('Profile updated');
    closeModal();
    if (typeof applyNavUI === 'function') applyNavUI();
  };
}

// ---------- Bell UI & actions ----------

/* --- fetch unread count and display badge (smart: subtract opened local ones if backend is unchanged) --- */
async function fetchHelpUnreadCount(announcementsForContext = []) {
  try {
    const res = await fetchJson('/api/help/unread-count', { headers: authHeaders(), method: 'GET' });
    if (!res.ok) { console.warn('unread-count', res.error); return; }
    let serverUnread = (res.data && typeof res.data.unread === 'number') ? res.data.unread : 0;
    const badge = document.getElementById('help_unread_badge');
    if (!badge) return;

    // compute how many of the server-side unread are already opened locally (best-effort)
    let localOpenedOverlap = 0;
    if (Array.isArray(announcementsForContext) && announcementsForContext.length) {
      const opened = getOpenedSet();
      for (const a of announcementsForContext) {
        if (!a) continue;
        if ((a.isUnread === false) || a._read === true) continue; // if server marks as read
        if (opened.has(String(a._id))) localOpenedOverlap++;
      }
    } else {
      // no context; we can estimate by counting local opened items but avoid going negative
      // don't apply overlap if we don't know the server list (safer to show server value)
      localOpenedOverlap = 0;
    }

    const displayCount = Math.max(0, serverUnread - localOpenedOverlap);
    if (displayCount > 0) { badge.innerText = (displayCount > 99 ? '99+' : String(displayCount)); badge.style.display = ''; }
    else badge.style.display = 'none';
  } catch (e) { console.warn('fetchHelpUnreadCount err', e); }
}

// Open a small modal (bell) showing announcements and (for admin) create/edit/delete controls
async function openBellModal() {
  // Load announcements
  const r = await fetchJson('/api/help/announcements?limit=100', { method: 'GET' });
  if (!r.ok) return alert('Failed to load announcements: ' + (r.error || ''));
  const ann = r.data.announcements || [];

  const is_admin = isAdmin();
  // Build HTML
  const rows = ann.map(a => {
    const date = new Date(a.createdAt).toLocaleString();
    let adminControls = '';
    if (is_admin) {
      adminControls = `
        <div style="margin-top:6px">
          <button class="ann-edit" data-id="${a._id}">Edit</button>
          <button class="ann-delete" data-id="${a._id}">Delete</button>
        </div>`;
    }
    return `
      <div style="padding:10px;border-bottom:1px solid #eee">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">${escapeHtml(a.title || 'Announcement')}</div>
          <div style="color:#666;font-size:12px">${escapeHtml(date)}</div>
        </div>
        <div style="margin-top:6px;color:#111">${escapeHtml(a.text)}</div>
        ${adminControls}
      </div>`;
  }).join('');

  const adminCreateHtml = is_admin ? `
    <hr>
    <div style="margin-top:8px">
      <div><input id="ann_title" placeholder="Title (optional)" style="width:100%;padding:8px;margin-bottom:6px"></div>
      <div><textarea id="ann_text" placeholder="Write announcement..." style="width:100%;min-height:80px;padding:8px"></textarea></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="ann_create">Create</button>
        <button id="ann_mark_read" class="btn-ghost">Mark all read</button>
      </div>
    </div>` : `<div style="padding:8px"><button id="ann_mark_read">Mark all read</button></div>`;

  const html = `
    <h3>Announcements</h3>
    <div style="max-height:50vh;overflow:auto;border:1px solid #f0f0f0;border-radius:8px;margin-top:8px">${rows || '<div style="padding:12px;color:#666">No announcements</div>'}</div>
    ${adminCreateHtml}
    <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
      <button id="bell_close" class="btn-ghost">Close</button>
    </div>
  `;
  showModal(html);

  // handlers
  document.getElementById('bell_close').onclick = closeModal;

  // Mark read button available to all logged-in users (or guests it will call mark-read but fail auth)
  const markBtn = document.getElementById('ann_mark_read');
  if (markBtn) markBtn.onclick = async () => {
    if (!getToken()) {
      // guests: just close (they can't mark as read)
      alert('Please login to mark announcements read.');
      return;
    }
    const rr = await fetchJson('/api/help/mark-read', { method: 'POST', headers: authHeaders() });
    if (!rr.ok) return alert('Failed to mark read: ' + (rr.error || ''));
    await fetchHelpUnreadCount();
    alert('Marked announcements as read');
    closeModal();
  };

  // Admin create
  if (is_admin) {
    document.getElementById('ann_create').onclick = async () => {
      const title = document.getElementById('ann_title').value.trim();
      const text = document.getElementById('ann_text').value.trim();
      if (!text) return alert('Text required');
      const res = await fetchJson('/api/help/announcements', { method: 'POST', headers: authHeaders(true), body: JSON.stringify({ title, text }) });
      if (!res.ok) return alert('Create failed: ' + (res.error || ''));
      alert('Created');
      closeModal();
      // refresh badge + re-open
      await fetchHelpUnreadCount();
      openBellModal();
    };
  }

  // admin edit/delete bindings
  document.querySelectorAll('.ann-delete').forEach(b => b.onclick = async (e) => {
    const id = e.target.dataset.id;
    if (!confirm('Delete this announcement?')) return;
    const res = await fetchJson('/api/help/announcements/' + encodeURIComponent(id), { method: 'DELETE', headers: authHeaders() });
    if (!res.ok) return alert('Delete failed: ' + (res.error || ''));
    alert('Deleted');
    closeModal();
    await fetchHelpUnreadCount();
    openBellModal();
  });

  document.querySelectorAll('.ann-edit').forEach(b => b.onclick = async (e) => {
    const id = e.target.dataset.id;
    // simple prompt edit (quick). You can replace with nicer modal edit UI
    const current = ann.find(x => x._id === id);
    const newText = prompt('Edit text', current ? current.text : '');
    if (newText === null) return;
    const newTitle = prompt('Edit title (optional)', current ? current.title : '');
    const res = await fetchJson('/api/help/announcements/' + encodeURIComponent(id), {
      method: 'PUT',
      headers: authHeaders(true),
      body: JSON.stringify({ text: newText, title: newTitle })
    });
    if (!res.ok) return alert('Edit failed: ' + (res.error || ''));
    alert('Updated');
    closeModal();
    await fetchHelpUnreadCount();
    openBellModal();
  });
}

/* ----------------- Improved Bell / Announcements module ----------------- */

/*
  Requires in-page helpers:
    - fetchJson(path, opts)
    - authHeaders(json=true)
    - getToken()
    - isAdmin()
    - showModal(html)
    - closeModal()
    - escapeHtml(s)
  If you have them named differently, adapt those calls.
*/


  // localStorage key to track which announcements the current browser/user opened
  const OPENED_KEY = 'openedAnnouncements';

  function getOpenedSet() {
  try {
    const s = localStorage.getItem(OPENED_KEY);
    return s ? new Set(JSON.parse(s)) : new Set();
  } catch (e) { return new Set(); }
}
function addOpened(id) {
  try {
    const s = getOpenedSet();
    s.add(String(id));
    localStorage.setItem(OPENED_KEY, JSON.stringify(Array.from(s)));
  } catch (e) { /* ignore */ }
}
function openedHas(id) { return getOpenedSet().has(String(id)); }

/* --- format text with safe escaping + preserve newlines --- */
function escapeHtml(s){
  if (s === 0) return '0';
  if (!s) return '';
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}
function formatAnnouncementText(text) {
  // escape then convert newlines to <br> ‚Äî preserves multi-line content
  return escapeHtml(text).replace(/\r\n?/g, '\n').replace(/\n/g, '<br>');
}

function buildAnnouncementsListHTML(announcements = []) {
  const openedSet = getOpenedSet();
  if (!announcements.length) {
    return `<div style="padding:12px;color:#666">No announcements</div>`;
  }
  return announcements.map(a => {
    const date = a.createdAt ? new Date(a.createdAt).toLocaleString() : '';
    const isOpened = openedSet.has(String(a._id));
    const unreadClass = isOpened ? '' : 'ann-unopened';

    // Preview: show only the first line (trimmed). If there are more lines, show ellipsis.
    const rawText = (a.text || '');
    const firstLine = rawText.split(/\r?\n/)[0] || '';              // first line only
    const hasMoreLines = rawText.split(/\r?\n/).length > 1;
    // short preview length guard
    const previewShort = firstLine.length > 200 ? firstLine.slice(0, 200) + '‚Ä¶' : firstLine + (hasMoreLines && firstLine.length < 200 ? '‚Ä¶' : '');
    const previewHtml = escapeHtml(previewShort); // do not convert newlines to <br> in preview

    // New badge for unopened announcements
    const newBadgeHtml = isOpened ? '' : `<span class="ann-new-badge">New</span>`;

    return `
      <div class="ann-row ${unreadClass}" data-id="${escapeHtml(a._id)}" style="">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:8px">
          <div style="flex:1;min-width:0">
            <div style="display:flex;align-items:center;gap:8px">
              <div class="ann-title">${escapeHtml(a.title || 'Announcement')}</div>
              ${newBadgeHtml}
            </div>
            <div class="ann-meta">${escapeHtml(date)}</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="ann-open small-btn" data-id="${escapeHtml(a._id)}">Open</button>
            ${isAdmin() ? `<button class="ann-edit-btn small-btn" data-id="${escapeHtml(a._id)}">Edit</button>` : ''}
            ${isAdmin() ? `<button class="ann-delete-btn small-btn" data-id="${escapeHtml(a._id)}">Delete</button>` : ''}
          </div>
        </div>
        <div class="ann-text">${previewHtml}</div>
      </div>
    `;
  }).join('');
}


/* --- open announcement detail, attempt to mark this announcement as read on server --- */
async function openAnnouncementDetail(ann, announcementsContext = []) {
  // mark opened locally
  addOpened(ann._id);

  // remove 'new' styling immediately for a snappy UI (client-side)
  try {
    const row = document.querySelector(`.ann-row[data-id="${ann._id}"]`);
    if (row) {
      row.classList.remove('ann-unopened');
      const badge = row.querySelector('.ann-new-badge');
      if (badge) badge.remove();
      // optionally update preview to reflect opened state (no-op here since we removed new badge)
    }
  } catch (e) { /* ignore DOM errors */ }

  // (rest of your existing code: render modal, tryMarkSingleRead, etc.)
  const html = `
    <h3 style="margin:0">${escapeHtml(ann.title || 'Announcement')}</h3>
    <div style="color:#6b7280;font-size:13px;margin-top:6px">${escapeHtml(new Date(ann.createdAt || Date.now()).toLocaleString())}</div>
    <div style="margin-top:12px" class="ann-text">${formatAnnouncementText(ann.text || '')}</div>
    
    <div style="margin-top:16px;display:flex;justify-content:space-between;align-items:center;gap:8px">
      <div style="display:flex;gap:8px">
        ${isAdmin() ? `<button id="ann_detail_edit" class="small-btn">Edit</button>` : ''}
        <button id="ann_detail_close" class="small-btn">Close</button>
      </div>
      <div>
        <button id="ann_detail_mark_read" class="btn-ghost">Mark all read</button>
      </div>
    </div>
  `;
  showModal(html);


  // attempt to mark this announcement as read on the server for the logged-in user.
  // Many backends support "mark-read" (all) only ‚Äî so try per-id payload first, fallback to nothing.
  async function tryMarkSingleRead(id) {
    if (!getToken()) return false; // guest can't mark on server
    try {
      // try per-id marking (server should accept { ids: [id] } or { id })
      const try1 = await fetchJson('/api/help/mark-read', {
        method: 'POST',
        headers: authHeaders(true),
        body: JSON.stringify({ ids: [id] })
      });
      if (try1.ok) return true;
      // attempt alternate key 'id'
      const try2 = await fetchJson('/api/help/mark-read', {
        method: 'POST',
        headers: authHeaders(true),
        body: JSON.stringify({ id })
      });
      if (try2.ok) return true;
    } catch (e) { /* ignore */ }
    return false;
  }

  // run best-effort marking: if backend can mark single, badge will be refreshed from server
  const singleMarked = await tryMarkSingleRead(ann._id);
  if (singleMarked) {
    await fetchHelpUnreadCount(announcementsContext);
  } else {
    // fallback ‚Äî server unchanged: update badge by re-fetching server count and subtracting local opened overlap
    await fetchHelpUnreadCount(announcementsContext);
  }

  // handlers
  document.getElementById('ann_detail_close').onclick = () => { closeModal(); fetchHelpUnreadCount(announcementsContext); };

  document.getElementById('ann_detail_mark_read').onclick = async () => {
    if (!getToken()) { alert('Please login to mark announcements read.'); return; }
    const rr = await fetchJson('/api/help/mark-read', { method: 'POST', headers: authHeaders(true) });
    if (!rr.ok) return alert('Failed to mark read: ' + (rr.error || ''));
    // server updated ‚Äî clear local opened set (they are now read on server)
    try { localStorage.removeItem(OPENED_KEY); } catch(e) {}
    await fetchHelpUnreadCount(announcementsContext);
    alert('Marked announcements as read');
    closeModal();
  };

  // admin edit
  if (isAdmin()) {
    const editBtn = document.getElementById('ann_detail_edit');
    if (editBtn) editBtn.onclick = () => {
      const editHtml = `
        <h3>Edit announcement</h3>
        <div style="display:flex;flex-direction:column;gap:8px">
          <input id="admin_edit_title" placeholder="Title (optional)" value="${escapeHtml(ann.title || '')}" style="padding:8px;border-radius:6px;border:1px solid #e6e6e6">
          <textarea id="admin_edit_text" style="min-height:160px;padding:8px;border-radius:6px;border:1px solid #e6e6e6">${escapeHtml(ann.text || '')}</textarea>
          <div style="display:flex;gap:8px;justify-content:flex-end">
            <button id="admin_edit_cancel" class="btn-ghost">Cancel</button>
            <button id="admin_edit_save" class="btn-primary">Save</button>
          </div>
        </div>
      `;
      showModal(editHtml);
      document.getElementById('admin_edit_cancel').onclick = closeModal;
      document.getElementById('admin_edit_save').onclick = async () => {
        const newTitle = document.getElementById('admin_edit_title').value.trim();
        const newText = document.getElementById('admin_edit_text').value;
        if (!newText.trim()) return alert('Text required');
        const r = await fetchJson('/api/help/announcements/' + encodeURIComponent(ann._id), {
          method: 'PUT',
          headers: authHeaders(true),
          body: JSON.stringify({ title: newTitle, text: newText })
        });
        if (!r.ok) return alert('Save failed: ' + (r.error || ''));
        alert('Updated');
        closeModal();
        await fetchHelpUnreadCount();
        openBellModal(); // refresh list
      };
    };
  }  
}

/* --- openBellModal (list + admin create + mark all read) --- */
async function openBellModal() {
  const r = await fetchJson('/api/help/announcements?limit=200', { method: 'GET' });
  if (!r.ok) return alert('Failed to load announcements: ' + (r.error || ''));
  const ann = r.data.announcements || [];
  const is_admin = isAdmin();

  const adminCreateHtml = is_admin ? `
    <hr style="margin:12px 0">
    <div style="display:flex;flex-direction:column;gap:8px">
      <input id="ann_new_title" placeholder="Title (optional)" style="padding:8px;border-radius:6px;border:1px solid #e6e6e6">
      <textarea id="ann_new_text" placeholder="Write announcement..." style="min-height:100px;padding:8px;border-radius:6px;border:1px solid #e6e6e6;white-space:pre-wrap"></textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end">
        <button id="ann_new_cancel" class="btn-ghost">Cancel</button>
        <button id="ann_new_create" class="btn-primary">Create</button>
      </div>
    </div>` : '';

  const listHTML = buildAnnouncementsListHTML(ann);

  const html = `
    <h3 style="display:flex;justify-content:space-between;align-items:center;margin:0">
      <span>Announcements</span>
      <small style="color:#6b7280">${ann.length} total</small>
    </h3>
    <div style="margin-top:10px;max-height:50vh;overflow:auto;padding:8px;background:#fff;border:1px solid #f3f5f7;border-radius:8px">
      ${listHTML}
    </div>
    ${adminCreateHtml}
    <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px">
      <button id="bell_close_btn" class="btn-ghost">Close</button>
      <button id="bell_mark_read_btn" class="btn-ghost">Mark all read</button>
    </div>
  `;
  showModal(html);

  // attach handlers
  document.getElementById('bell_close_btn').onclick = closeModal;

  document.getElementById('bell_mark_read_btn').onclick = async () => {
    if (!getToken()) return alert('Please login to mark announcements read.');
    const rr = await fetchJson('/api/help/mark-read', { method: 'POST', headers: authHeaders(true) });
    if (!rr.ok) return alert('Failed to mark read: ' + (rr.error || ''));
    // server marked all ‚Äî clear local opened set
    try { localStorage.removeItem(OPENED_KEY); } catch(e) {}
    await fetchHelpUnreadCount(ann);
    alert('Marked announcements as read');
    closeModal();
  };

  // admin create
  if (is_admin) {
    document.getElementById('ann_new_cancel').onclick = () => {
      document.getElementById('ann_new_title').value = '';
      document.getElementById('ann_new_text').value = '';
    };
    document.getElementById('ann_new_create').onclick = async () => {
      const title = document.getElementById('ann_new_title').value.trim();
      const text = document.getElementById('ann_new_text').value;
      if (!text.trim()) return alert('Text required');
      // send raw multiline text (no trimming internal newlines)
      const res = await fetchJson('/api/help/announcements', {
        method: 'POST',
        headers: authHeaders(true),
        body: JSON.stringify({ title, text })
      });
      if (!res.ok) return alert('Create failed: ' + (res.error || ''));
      alert('Created');
      closeModal();
      await fetchHelpUnreadCount();
      openBellModal();
    };
  }

  // event delegation inside modal for open/edit/delete buttons
  const modalRoot = document.getElementById('modalRoot') || document.getElementById('modal-root') || document;
  modalRoot.querySelectorAll('.ann-open').forEach(b => b.onclick = async (e) => {
    const id = e.currentTarget.dataset.id;
    if (!id) return;
    // find announcement in current list
    const a = (ann || []).find(x => String(x._id) === String(id));
    if (!a) {
      // fallback: re-fetch single announcement list then open
      const rr = await fetchJson('/api/help/announcements?limit=200', { method: 'GET' });
      if (!rr.ok) return alert('Failed to load announcement: ' + (rr.error || ''));
      const a2 = (rr.data.announcements || []).find(x => String(x._id) === String(id));
      if (!a2) return alert('Announcement not found');
      return openAnnouncementDetail(a2, rr.data.announcements || []);
    }
    return openAnnouncementDetail(a, ann);
  });

  modalRoot.querySelectorAll('.ann-delete-btn').forEach(b => b.onclick = async (e) => {
    const id = e.currentTarget.dataset.id;
    if (!id) return;
    if (!confirm('Delete this announcement?')) return;
    const res = await fetchJson('/api/help/announcements/' + encodeURIComponent(id), { method: 'DELETE', headers: authHeaders(true) });
    if (!res.ok) return alert('Delete failed: ' + (res.error || ''));
    alert('Deleted');
    closeModal();
    await fetchHelpUnreadCount();
    openBellModal();
  });

  modalRoot.querySelectorAll('.ann-edit-btn').forEach(b => b.onclick = async (e) => {
    const id = e.currentTarget.dataset.id;
    if (!id) return;
    const a = (ann || []).find(x => String(x._id) === String(id));
    if (!a) return alert('Announcement not found');
    // open edit modal (same UI as detail edit)
    openAnnouncementDetail(a, ann); // open detail -> admin can press edit inside
  });

  // update badge taking into account announcements list (so local opened items show correctly)
  fetchHelpUnreadCount(ann);
}

  // attach bell button event (btn-help)
  const helpBtn = document.getElementById('btn-help');
  if (helpBtn) helpBtn.onclick = openBellModal;

/* patch applyNavUI if present to start polling + set up badge */
(function initBellPolling(){
  if (typeof applyNavUI === 'function') {
    const orig = applyNavUI;
    window.applyNavUI = function(...args) {
      try { orig(...args); } catch(e) { console.warn('applyNavUI err', e); }
      try { fetchHelpUnreadCount(); } catch(e) {}
      if (window.helpPollTimer) clearInterval(window.helpPollTimer);
      window.helpPollTimer = setInterval(() => fetchHelpUnreadCount(), 20000);
    };
    // call once
    try { applyNavUI(); } catch(e) { fetchHelpUnreadCount(); }
  } else {
    fetchHelpUnreadCount();
    if (window.helpPollTimer) clearInterval(window.helpPollTimer);
    window.helpPollTimer = setInterval(() => fetchHelpUnreadCount(), 20000);
  }
})();

  // initial run
  if (typeof applyNavUI === 'function') applyNavUI();
  else fetchHelpUnreadCount();

  // Expose small API for debug if needed
  window.BellModule = { open: openBellModal, refreshBadge: fetchHelpUnreadCount, markOpened: addOpened };



  /* ---------- AUTH HELPERS (drop-in) ---------- */
/* Ensure getToken/getUser/isAdmin are defined (safe re-definitions if not present) */
function getToken(){ return localStorage.getItem('token'); }
function getUser(){ try { const s = localStorage.getItem('user'); return s ? JSON.parse(s) : null;} catch(e){ return null; } }
function isAdmin(){ const u = getUser(); return !!(u && (u.role === 'admin' || u.isAdmin)); }



/******************* AUTH & NAV PATCH (DROP-IN REPLACEMENT) *******************/
/* Replace existing doLogin, doLogout, applyNavUI, attachAuthButtons, and
   mobile/settings update logic with these. They rely on: fetchJson(), showModal(),
   closeModal(), getToken(), getUser(), authHeaders(), isAdmin(), escapeHtml(). */

   /* ---------- Countries + cities ---------- */
/* Minimal countries list: you can extend with more codes/names.
   Flags are computed from ISO codes (Android/iOS render emoji).
   Custom codes (e.g. XS-SL) can be mapped in CUSTOM_FLAG_MAP. */
   const COUNTRIES = [
  { code: 'AF', name: 'Afghanistan' },
  { code: 'AL', name: 'Albania' },
  { code: 'DZ', name: 'Algeria' },
  { code: 'AD', name: 'Andorra' },
  { code: 'AO', name: 'Angola' },
  { code: 'AG', name: 'Antigua and Barbuda' },
  { code: 'AR', name: 'Argentina' },
  { code: 'AM', name: 'Armenia' },
  { code: 'AU', name: 'Australia' },
  { code: 'AT', name: 'Austria' },
  { code: 'AZ', name: 'Azerbaijan' },
  { code: 'BS', name: 'Bahamas' },
  { code: 'BH', name: 'Bahrain' },
  { code: 'BD', name: 'Bangladesh' },
  { code: 'BB', name: 'Barbados' },
  { code: 'BY', name: 'Belarus' },
  { code: 'BE', name: 'Belgium' },
  { code: 'BZ', name: 'Belize' },
  { code: 'BJ', name: 'Benin' },
  { code: 'BT', name: 'Bhutan' },
  { code: 'BO', name: 'Bolivia (Plurinational State of)' },
  { code: 'BA', name: 'Bosnia and Herzegovina' },
  { code: 'BW', name: 'Botswana' },
  { code: 'BR', name: 'Brazil' },
  { code: 'BN', name: 'Brunei Darussalam' },
  { code: 'BG', name: 'Bulgaria' },
  { code: 'BF', name: 'Burkina Faso' },
  { code: 'BI', name: 'Burundi' },
  { code: 'CV', name: 'Cabo Verde' },
  { code: 'KH', name: 'Cambodia' },
  { code: 'CM', name: 'Cameroon' },
  { code: 'CA', name: 'Canada' },
  { code: 'CF', name: 'Central African Republic' },
  { code: 'TD', name: 'Chad' },
  { code: 'CL', name: 'Chile' },
  { code: 'CN', name: 'China' },
  { code: 'CO', name: 'Colombia' },
  { code: 'KM', name: 'Comoros' },
  { code: 'CG', name: 'Congo' },
  { code: 'CD', name: 'Congo, Democratic Republic of the' },
  { code: 'CR', name: 'Costa Rica' },
  { code: 'CI', name: "C√¥te d'Ivoire" },
  { code: 'HR', name: 'Croatia' },
  { code: 'CU', name: 'Cuba' },
  { code: 'CY', name: 'Cyprus' },
  { code: 'CZ', name: 'Czechia' },
  { code: 'DK', name: 'Denmark' },
  { code: 'DJ', name: 'Djibouti' },
  { code: 'DM', name: 'Dominica' },
  { code: 'DO', name: 'Dominican Republic' },
  { code: 'EC', name: 'Ecuador' },
  { code: 'EG', name: 'Egypt' },
  { code: 'SV', name: 'El Salvador' },
  { code: 'GQ', name: 'Equatorial Guinea' },
  { code: 'ER', name: 'Eritrea' },
  { code: 'EE', name: 'Estonia' },
  { code: 'SZ', name: 'Eswatini' },
  { code: 'ET', name: 'Ethiopia' },
  { code: 'FJ', name: 'Fiji' },
  { code: 'FI', name: 'Finland' },
  { code: 'FR', name: 'France' },
  { code: 'GA', name: 'Gabon' },
  { code: 'GM', name: 'Gambia' },
  { code: 'GE', name: 'Georgia' },
  { code: 'DE', name: 'Germany' },
  { code: 'GH', name: 'Ghana' },
  { code: 'GR', name: 'Greece' },
  { code: 'GD', name: 'Grenada' },
  { code: 'GT', name: 'Guatemala' },
  { code: 'GN', name: 'Guinea' },
  { code: 'GW', name: 'Guinea-Bissau' },
  { code: 'GY', name: 'Guyana' },
  { code: 'HT', name: 'Haiti' },
  { code: 'HN', name: 'Honduras' },
  { code: 'HU', name: 'Hungary' },
  { code: 'IS', name: 'Iceland' },
  { code: 'IN', name: 'India' },
  { code: 'ID', name: 'Indonesia' },
  { code: 'IR', name: 'Iran (Islamic Republic of)' },
  { code: 'IQ', name: 'Iraq' },
  { code: 'IE', name: 'Ireland' },
  { code: 'IL', name: 'Israel' },
  { code: 'IT', name: 'Italy' },
  { code: 'JM', name: 'Jamaica' },
  { code: 'JP', name: 'Japan' },
  { code: 'JO', name: 'Jordan' },
  { code: 'KZ', name: 'Kazakhstan' },
  { code: 'KE', name: 'Kenya' },
  { code: 'KI', name: 'Kiribati' },
  { code: 'KW', name: 'Kuwait' },
  { code: 'KG', name: 'Kyrgyzstan' },
  { code: 'LA', name: "Lao People's Democratic Republic" },
  { code: 'LV', name: 'Latvia' },
  { code: 'LB', name: 'Lebanon' },
  { code: 'LS', name: 'Lesotho' },
  { code: 'LR', name: 'Liberia' },
  { code: 'LY', name: 'Libya' },
  { code: 'LI', name: 'Liechtenstein' },
  { code: 'LT', name: 'Lithuania' },
  { code: 'LU', name: 'Luxembourg' },
  { code: 'MG', name: 'Madagascar' },
  { code: 'MW', name: 'Malawi' },
  { code: 'MY', name: 'Malaysia' },
  { code: 'MV', name: 'Maldives' },
  { code: 'ML', name: 'Mali' },
  { code: 'MT', name: 'Malta' },
  { code: 'MH', name: 'Marshall Islands' },
  { code: 'MR', name: 'Mauritania' },
  { code: 'MU', name: 'Mauritius' },
  { code: 'MX', name: 'Mexico' },
  { code: 'MC', name: 'Monaco' },
  { code: 'MN', name: 'Mongolia' },
  { code: 'ME', name: 'Montenegro' },
  { code: 'MA', name: 'Morocco' },
  { code: 'MZ', name: 'Mozambique' },
  { code: 'MM', name: 'Myanmar' },
  { code: 'NA', name: 'Namibia' },
  { code: 'NR', name: 'Nauru' },
  { code: 'NP', name: 'Nepal' },
  { code: 'NL', name: 'Netherlands' },
  { code: 'NZ', name: 'New Zealand' },
  { code: 'NI', name: 'Nicaragua' },
  { code: 'NE', name: 'Niger' },
  { code: 'NG', name: 'Nigeria' },
  { code: 'KP', name: "Korea (Democratic People's Republic of)" },
  { code: 'KR', name: 'Korea (Republic of)' },
  { code: 'MK', name: 'North Macedonia' },
  { code: 'NO', name: 'Norway' },
  { code: 'OM', name: 'Oman' },
  { code: 'PK', name: 'Pakistan' },
  { code: 'PW', name: 'Palau' },
  { code: 'PA', name: 'Panama' },
  { code: 'PG', name: 'Papua New Guinea' },
  { code: 'PY', name: 'Paraguay' },
  { code: 'PE', name: 'Peru' },
  { code: 'PH', name: 'Philippines' },
  { code: 'PL', name: 'Poland' },
  { code: 'PT', name: 'Portugal' },
  { code: 'QA', name: 'Qatar' },
  { code: 'RO', name: 'Romania' },
  { code: 'RU', name: 'Russian Federation' },
  { code: 'RW', name: 'Rwanda' },
  { code: 'KN', name: 'Saint Kitts and Nevis' },
  { code: 'LC', name: 'Saint Lucia' },
  { code: 'VC', name: 'Saint Vincent and the Grenadines' },
  { code: 'WS', name: 'Samoa' },
  { code: 'SM', name: 'San Marino' },
  { code: 'ST', name: 'Sao Tome and Principe' },
  { code: 'SA', name: 'Saudi Arabia' },
  { code: 'SN', name: 'Senegal' },
  { code: 'RS', name: 'Serbia' },
  { code: 'SC', name: 'Seychelles' },
  { code: 'SL', name: 'Sierra Leone' },
  { code: 'SG', name: 'Singapore' },
  { code: 'SK', name: 'Slovakia' },
  { code: 'SI', name: 'Slovenia' },
  { code: 'SB', name: 'Solomon Islands' },
  { code: 'SO', name: 'Somalia' },
  { code: 'ZA', name: 'South Africa' },
  { code: 'SS', name: 'South Sudan' },
  { code: 'ES', name: 'Spain' },
  { code: 'LK', name: 'Sri Lanka' },
  { code: 'SD', name: 'Sudan' },
  { code: 'SR', name: 'Suriname' },
  { code: 'SE', name: 'Sweden' },
  { code: 'CH', name: 'Switzerland' },
  { code: 'SY', name: 'Syrian Arab Republic' },
  { code: 'TJ', name: 'Tajikistan' },
  { code: 'TZ', name: 'Tanzania, United Republic of' },
  { code: 'TH', name: 'Thailand' },
  { code: 'TL', name: 'Timor-Leste' },
  { code: 'TG', name: 'Togo' },
  { code: 'TO', name: 'Tonga' },
  { code: 'TT', name: 'Trinidad and Tobago' },
  { code: 'TN', name: 'Tunisia' },
  { code: 'TR', name: 'T√ºrkiye' },
  { code: 'TM', name: 'Turkmenistan' },
  { code: 'TV', name: 'Tuvalu' },
  { code: 'UG', name: 'Uganda' },
  { code: 'UA', name: 'Ukraine' },
  { code: 'AE', name: 'United Arab Emirates' },
  { code: 'GB', name: 'United Kingdom' },
  { code: 'US', name: 'United States' },
  { code: 'UY', name: 'Uruguay' },
  { code: 'UZ', name: 'Uzbekistan' },
  { code: 'VU', name: 'Vanuatu' },
  { code: 'VE', name: 'Venezuela (Bolivarian Republic of)' },
  { code: 'VN', name: 'Viet Nam' },
  { code: 'YE', name: 'Yemen' },
  { code: 'ZM', name: 'Zambia' },
  { code: 'ZW', name: 'Zimbabwe' }
];


// custom flag overrides for non-standard codes
const CUSTOM_FLAG_MAP = {
  'XS-SL': 'üè≥Ô∏è', // Somaliland fallback
  'XN-SL': 'üè≥Ô∏è',
  'XK': 'üáΩüá∞'
};

// convert ISO alpha-2 to flag emoji e.g. 'US' -> üá∫üá∏
// fallback to CUSTOM_FLAG_MAP for custom codes
function codeToFlagEmoji(code) {
  if (!code) return '';
  if (CUSTOM_FLAG_MAP[code]) return CUSTOM_FLAG_MAP[code];
  const c = String(code).trim().toUpperCase();
  if (c.length !== 2) return '';
  const A = 0x1F1E6;
  const first = c.charCodeAt(0) - 65;
  const second = c.charCodeAt(1) - 65;
  if (first < 0 || first > 25 || second < 0 || second > 25) return '';
  return String.fromCodePoint(A + first) + String.fromCodePoint(A + second);
}

/* Cities mapping (country code -> array of cities) */
/* I expanded Somalia list per your request. Add more countries as needed. */


const CITIES_BY_COUNTRY = {
  "AF": ["Kabul", "Kandahar", "Mazar-i-Sharif", "Herat"],
  "AL": ["Tirana", "Durr√´s", "Vlor√´", "Shkod√´r"],
  "DZ": ["Algiers", "Oran", "Constantine", "Annaba"],
  "AD": ["Andorra la Vella", "Encamp", "Sant Juli√† de L√≤ria", "La Massana"],
  "AO": ["Luanda", "N'dalatando", "Huambo", "Lobito"],
  "AG": ["St. John's", "All Saints", "Liberta", "Potters Village"],
  "AR": ["Buenos Aires", "C√≥rdoba", "Rosario", "Mendoza"],
  "AM": ["Yerevan", "Gyumri", "Vanadzor", "Vagharshapat"],
  "AU": ["Canberra", "Sydney", "Melbourne", "Brisbane"],
  "AT": ["Vienna", "Graz", "Linz", "Salzburg"],
  "AZ": ["Baku", "Ganja", "Sumqayit", "Lankaran"],
  "BS": ["Nassau", "Freeport", "West End", "Marsh Harbour"],
  "BH": ["Manama", "Riffa", "Muharraq", "Hamad Town"],
  "BD": ["Dhaka", "Chittagong", "Khulna", "Rajshahi"],
  "BB": ["Bridgetown", "Speightstown", "Oistins", "Holetown"],
  "BY": ["Minsk", "Gomel", "Mogilev", "Vitebsk"],
  "BE": ["Brussels", "Antwerp", "Ghent", "Charleroi"],
  "BZ": ["Belmopan", "Belize City", "San Ignacio", "Dangriga"],
  "BJ": ["Porto-Novo", "Cotonou", "Parakou", "Abomey-Calavi"],
  "BT": ["Thimphu", "Phuntsholing", "Punakha", "Trashigang"],
  "BO": ["Sucre", "La Paz", "Santa Cruz de la Sierra", "Cochabamba"],
  "BA": ["Sarajevo", "Banja Luka", "Mostar", "Tuzla"],
  "BW": ["Gaborone", "Francistown", "Maun", "Molepolole"],
  "BR": ["Bras√≠lia", "S√£o Paulo", "Rio de Janeiro", "Salvador"],
  "BN": ["Bandar Seri Begawan", "Kuala Belait", "Seria", "Tutong"],
  "BG": ["Sofia", "Plovdiv", "Varna", "Burgas"],
  "BF": ["Ouagadougou", "Bobo-Dioulasso", "Koudougou", "Banfora"],
  "BI": ["Gitega", "Bujumbura", "Ngozi", "Muyinga"],
  "CV": ["Praia", "Mindelo", "Santa Maria", "S√£o Filipe"],
  "KH": ["Phnom Penh", "Siem Reap", "Battambang", "Kampong Cham"],
  "CM": ["Yaound√©", "Douala", "Garoua", "Bamenda"],
  "CA": ["Ottawa", "Toronto", "Montreal", "Vancouver"],
  "CF": ["Bangui", "Bambari", "Berb√©rati", "Bossangoa"],
  "TD": ["N'Djamena", "Moundou", "Sarh", "Ab√©ch√©"],
  "CL": ["Santiago", "Concepci√≥n", "Valpara√≠so", "Antofagasta"],
  "CN": ["Beijing", "Shanghai", "Guangzhou", "Shenzhen"],
  "CO": ["Bogot√°", "Medell√≠n", "Cali", "Barranquilla"],
  "KM": ["Moroni", "Mitsamiouli", "Fomboni", "Mbeni"],
  "CG": ["Brazzaville", "Pointe-Noire", "Dolisie", "Nkayi"],
  "CD": ["Kinshasa", "Lubumbashi", "Mbuji-Mayi", "Kananga"],
  "CR": ["San Jos√©", "Cartago", "Alajuela", "Liberia"],
  "CI": ["Yamoussoukro", "Abidjan", "Bouak√©", "Daloa"],
  "HR": ["Zagreb", "Split", "Rijeka", "Osijek"],
  "CU": ["Havana", "Santiago de Cuba", "Camag√ºey", "Holgu√≠n"],
  "CY": ["Nicosia", "Limassol", "Larnaca", "Famagusta"],
  "CZ": ["Prague", "Brno", "Ostrava", "Plze≈à"],
  "DK": ["Copenhagen", "Aarhus", "Odense", "Aalborg"],
  "DJ": ["Djibouti", "Tadjoura", "Ali Sabieh", "Obock"],
  "DM": ["Roseau", "Dominica (Roseau area)", "Portsmouth", "Mahaut"],
  "DO": ["Santo Domingo", "Santiago de los Caballeros", "La Romana", "San Pedro de Macor√≠s"],
  "EC": ["Quito", "Guayaquil", "Cuenca", "Santo Domingo de los Ts√°chilas"],
  "EG": ["Cairo", "Alexandria", "Giza", "Shubra El-Kheima"],
  "SV": ["San Salvador", "Santa Ana", "San Miguel", "Soyapango"],
  "GQ": ["Malabo", "Bata", "Ebebiy√≠n", "Aconibe"],
  "ER": ["Asmara", "Keren", "Massawa", "Mendefera"],
  "EE": ["Tallinn", "Tartu", "Narva", "P√§rnu"],
  "SZ": ["Mbabane", "Lobamba", "Manzini", "Nhlangano"],
  "ET": ["Addis Ababa", "Dire Dawa", "Mekelle", "Bahir Dar"],
  "FJ": ["Suva", "Nadi", "Lautoka", "Labasa"],
  "FI": ["Helsinki", "Espoo", "Tampere", "Vantaa"],
  "FR": ["Paris", "Marseille", "Lyon", "Toulouse"],
  "GA": ["Libreville", "Port-Gentil", "Franceville", "Oyem"],
  "GM": ["Banjul", "Serekunda", "Brikama", "Bakau"],
  "GE": ["Tbilisi", "Batumi", "Kutaisi", "Rustavi"],
  "DE": ["Berlin", "Hamburg", "Munich", "Cologne"],
  "GH": ["Accra", "Kumasi", "Tamale", "Takoradi"],
  "GR": ["Athens", "Thessaloniki", "Patras", "Heraklion"],
  "GD": ["St. George's", "Gouyave", "Victoria", "Sauteurs"],
  "GT": ["Guatemala City", "Quetzaltenango", "Escuintla", "Huehuetenango"],
  "GN": ["Conakry", "Kankan", "Nz√©r√©kor√©", "Kindia"],
  "GW": ["Bissau", "Bafata", "Gab√∫", "Cacheu"],
  "GY": ["Georgetown", "Linden", "New Amsterdam", "Bartica"],
  "HT": ["Port-au-Prince", "Cap-Ha√Øtien", "Gona√Øves", "Jacmel"],
  "HN": ["Tegucigalpa", "San Pedro Sula", "Choloma", "La Ceiba"],
  "HU": ["Budapest", "Debrecen", "Szeged", "Miskolc"],
  "IS": ["Reykjav√≠k", "K√≥pavogur", "Hafnarfj√∂r√∞ur", "Akureyri"],
  "IN": ["New Delhi", "Mumbai", "Kolkata", "Bengaluru"],
  "ID": ["Jakarta", "Surabaya", "Bandung", "Medan"],
  "IR": ["Tehran", "Mashhad", "Isfahan", "Karaj"],
  "IQ": ["Baghdad", "Basra", "Mosul", "Erbil"],
  "IE": ["Dublin", "Cork", "Limerick", "Galway"],
  "IL": ["Jerusalem", "Tel Aviv-Yafo", "Haifa", "Rishon LeZion"],
  "IT": ["Rome", "Milan", "Naples", "Turin"],
  "JM": ["Kingston", "Montego Bay", "Spanish Town", "Mandeville"],
  "JP": ["Tokyo", "Yokohama", "Osaka", "Nagoya"],
  "JO": ["Amman", "Zarqa", "Irbid", "Russeifa"],
  "KZ": ["Astana (Nur-Sultan)", "Almaty", "Shymkent", "Karagandy"],
  "KE": ["Nairobi", "Mombasa", "Kisumu", "Nakuru"],
  "KI": ["South Tarawa", "Betio", "Bikenibeu", "Nanikai"],
  "KW": ["Kuwait City", "Al Ahmadi", "Hawalli", "Salmiya"],
  "KG": ["Bishkek", "Osh", "Jalal-Abad", "Karakol"],
  "LA": ["Vientiane", "Luang Prabang", "Savannakhet", "Pakse"],
  "LV": ["Riga", "Daugavpils", "LiepƒÅja", "Jelgava"],
  "LB": ["Beirut", "Tripoli", "Sidon", "Tyre"],
  "LS": ["Maseru", "Teyateyaneng", "Leribe", "Mafeteng"],
  "LR": ["Monrovia", "Gbarnga", "Buchanan", "Zwedru"],
  "LY": ["Tripoli", "Benghazi", "Misrata", "Zawiya"],
  "LI": ["Vaduz", "Schaan", "Balzers", "Triesen"],
  "LT": ["Vilnius", "Kaunas", "Klaipƒóda", "≈†iauliai"],
  "LU": ["Luxembourg", "Esch-sur-Alzette", "Differdange", "Dudelange"],
  "MG": ["Antananarivo", "Toamasina", "Fianarantsoa", "Mahajanga"],
  "MW": ["Lilongwe", "Blantyre", "Mzuzu", "Zomba"],
  "MY": ["Kuala Lumpur", "George Town", "Johor Bahru", "Kota Kinabalu"],
  "MV": ["Mal√©", "Addu City", "Fuvahmulah", "Hulhumal√©"],
  "ML": ["Bamako", "Sikasso", "Kayes", "Mopti"],
  "MT": ["Valletta", "Birkirkara", "Sliema", "Mdina"],
  "MH": ["Majuro", "Ebeye", "Laura", "Jaluit"],
  "MR": ["Nouakchott", "Nouadhibou", "Zou√©rat", "Rosso"],
  "MU": ["Port Louis", "Beau Bassin-Rose Hill", "Curepipe", "Quatre Bornes"],
  "MX": ["Mexico City", "Guadalajara", "Monterrey", "Puebla"],
  "MC": ["Monaco", "Monte Carlo", "La Condamine", "Fontvieille"],
  "MN": ["Ulaanbaatar", "Erdenet", "Darkhan", "Choibalsan"],
  "ME": ["Podgorica", "Nik≈°iƒá", "Herceg Novi", "Bar"],
  "MA": ["Rabat", "Casablanca", "Fes", "Marrakesh"],
  "MZ": ["Maputo", "Matola", "Nampula", "Beira"],
  "MM": ["Naypyidaw", "Yangon", "Mandalay", "Mawlamyine"],
  "NA": ["Windhoek", "Walvis Bay", "Swakopmund", "Rundu"],
  "NR": ["Yaren (de facto)", "Nauru (district)", "Denigomodu", "Buada"],
  "NP": ["Kathmandu", "Pokhara", "Lalitpur", "Biratnagar"],
  "NL": ["Amsterdam", "Rotterdam", "The Hague", "Utrecht"],
  "NZ": ["Wellington", "Auckland", "Christchurch", "Hamilton"],
  "NI": ["Managua", "Le√≥n", "Masaya", "Chinandega"],
  "NE": ["Niamey", "Zinder", "Maradi", "Dosso"],
  "NG": ["Abuja", "Lagos", "Kano", "Port Harcourt"],
  "KP": ["Pyongyang", "Hamhung", "Chongjin", "Nampo"],
  "KR": ["Seoul", "Busan", "Incheon", "Daegu"],
  "MK": ["Skopje", "Bitola", "Kumanovo", "Prilep"],
  "NO": ["Oslo", "Bergen", "Trondheim", "Stavanger"],
  "OM": ["Muscat", "Salalah", "Sohar", "Nizwa"],
  "PK": ["Islamabad", "Karachi", "Lahore", "Faisalabad"],
  "PW": ["Ngerulmud", "Koror", "Melekeok", "Airai"],
  "PA": ["Panama City", "Col√≥n", "David", "Santiago"],
  "PG": ["Port Moresby", "Lae", "Mount Hagen", "Goroka"],
  "PY": ["Asunci√≥n", "Ciudad del Este", "Encarnaci√≥n", "San Lorenzo"],
  "PE": ["Lima", "Arequipa", "Trujillo", "Chiclayo"],
  "PH": ["Manila", "Quezon City", "Cebu City", "Davao City"],
  "PL": ["Warsaw", "Krak√≥w", "≈Å√≥d≈∫", "Wroc≈Çaw"],
  "PT": ["Lisbon", "Porto", "Funchal", "Coimbra"],
  "QA": ["Doha", "Al Rayyan", "Umm Salal", "Al Wakrah"],
  "RO": ["Bucharest", "Cluj-Napoca", "Timi»ôoara", "Ia»ôi"],
  "RU": ["Moscow", "Saint Petersburg", "Novosibirsk", "Yekaterinburg"],
  "RW": ["Kigali", "Butare (Huye)", "Gisenyi (Rubavu)", "Kigoma"],
  "KN": ["Basseterre", "Charlestown", "Cayon", "Dieppe Bay Town"],
  "LC": ["Castries", "Gros Islet", "Vieux Fort", "Soufri√®re"],
  "VC": ["Kingstown", "Georgetown", "Barrouallie", "Chateaubelair"],
  "WS": ["Apia", "Vaitele", "Leulumoega", "Faleasi'u"],
  "SM": ["San Marino", "City of San Marino", "Borgo Maggiore", "Serravalle"],
  "ST": ["S√£o Tom√©", "Santo Ant√≥nio", "Neves", "Guadalupe"],
  "SA": ["Riyadh", "Jeddah", "Mecca", "Medina"],
  "SN": ["Dakar", "Touba", "Thi√®s", "Ziguinchor"],
  "RS": ["Belgrade", "Novi Sad", "Ni≈°", "Kragujevac"],
  "SC": ["Victoria (Mah√©)", "Anse Boileau", "Beau Vallon", "Glacis"],
  "SL": ["Freetown", "Bo", "Kenema", "Koidu"],
  "SG": ["Singapore", "Jurong East", "Woodlands", "Tampines"],
  "SK": ["Bratislava", "Ko≈°ice", "Pre≈°ov", "≈Ωilina"],
  "SI": ["Ljubljana", "Maribor", "Celje", "Kranj"],
  "SB": ["Honiara", "Auki", "Gizo", "Kirakira"],
'SO': [
    'Mogadishu',
    'Hargeisa',
    'Bosaso',
    'Galkayo',
    'Kismayo',
    'Garowe',
    'Burao',
    'Berbera',
    'Baidoa',
    'Beledweyne',
    'Bardhere',
    'Laascaanood',
    'Jowhar',
    'Luuq',
    'Afmadow',
    'Afgooye',
    'El Wak',
    'Borama',
    'Eyl',
    'Jilib',
   'Hargeisa', 
   'Burao', 
   'Berbera', 
   'Gabiley' ],
    "ZA": ["Pretoria", "Johannesburg", "Cape Town", "Durban"],
  "SS": ["Juba", "Malakal", "Wau", "Bor"],
  "ES": ["Madrid", "Barcelona", "Valencia", "Seville"],
  "LK": ["Sri Jayawardenepura Kotte", "Colombo", "Kandy", "Galle"],
  "SD": ["Khartoum", "Omdurman", "Port Sudan", "Kassala"],
  "SR": ["Paramaribo", "Lelydorp", "Nieuw Nickerie", "Moengo"],
  "SE": ["Stockholm", "Gothenburg", "Malm√∂", "Uppsala"],
  "CH": ["Bern", "Zurich", "Geneva", "Basel"],
  "SY": ["Damascus", "Aleppo", "Homs", "Hama"],
  "TJ": ["Dushanbe", "Khujand", "Kulob", "Istaravshan"],
  "TZ": ["Dodoma", "Dar es Salaam", "Mwanza", "Arusha"],
  "TH": ["Bangkok", "Chiang Mai", "Phuket", "Hat Yai"],
  "TL": ["Dili", "Baucau", "Dili District (Asumanu)", "Suai"],
  "TG": ["Lom√©", "Sokod√©", "Kara", "Atakpam√©"],
  "TO": ["Nuku'alofa", "Neiafu", "Havelu", "Vaini"],
  "TT": ["Port of Spain", "San Fernando", "Chaguanas", "Arima"],
  "TN": ["Tunis", "Sfax", "Sousse", "Kairouan"],
  "TR": ["Ankara", "Istanbul", "ƒ∞zmir", "Bursa"],
  "TM": ["Ashgabat", "Turkmenabat", "Mary", "Dashoguz"],
  "TV": ["Funafuti", "Vaiaku", "Fongafale", "Vaitupu"],
  "UG": ["Kampala", "Gulu", "Lira", "Mbarara"],
  "UA": ["Kyiv", "Kharkiv", "Odesa", "Dnipro"],
  "AE": ["Abu Dhabi", "Dubai", "Sharjah", "Al Ain"],
  "GB": ["London", "Birmingham", "Leeds", "Glasgow"],
  "US": ["Washington, D.C.", "New York", "Los Angeles", "Chicago"],
  "UY": ["Montevideo", "Salto", "Punta del Este", "Paysand√∫"],
  "UZ": ["Tashkent", "Samarkand", "Bukhara", "Namangan"],
  "VU": ["Port Vila", "Luganville", "Norsup", "Lenakel"],
  "VE": ["Caracas", "Maracaibo", "Valencia", "Barquisimeto"],
  "VN": ["Hanoi", "Ho Chi Minh City", "Da Nang", "Hai Phong"],
  "YE": ["Sana'a", "Aden", "Taiz", "Al Hudaydah"],
  "ZM": ["Lusaka", "Ndola", "Kitwe", "Livingstone"],
  "ZW": ["Harare", "Bulawayo", "Mutare", "Gweru"]
};





   /* ---------- COUNTRIES: code, name, flag (emoji or short label) ---------- */











   function buildCountrySelectHtml(selectedCode = '') {
  const opts = COUNTRIES.map(c => {
    const code = c.code || '';
    const emoji = codeToFlagEmoji(code);
    const sel = code === selectedCode ? 'selected' : '';
    return `<option value="${escapeHtml(code)}" ${sel}>${escapeHtml(emoji ? emoji + ' ' + c.name : c.name)}</option>`;
  }).join('');
  return `<select id="profile_country" aria-label="Country" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">${opts}</select>`;
}

function buildCitySelectHtml(countryCode = '', selectedCity = '') {
  const cities = (CITIES_BY_COUNTRY[countryCode] || []);
  if (!cities.length) {
    // fallback to a free input if there is no predefined list
    return `<input id="profile_city" placeholder="City" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff" value="${escapeHtml(selectedCity||'')}">`;
  }
  const opts = cities.map(c => {
    const sel = String(c) === String(selectedCity) ? 'selected' : '';
    return `<option value="${escapeHtml(c)}" ${sel}>${escapeHtml(c)}</option>`;
  }).join('');
  return `<select id="profile_city" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">${opts}</select>`;
}


// fetchRESTCountries builds a list, merges extras and returns an array: { name, code, flag, emoji, callingCode }
async function fetchRESTCountries() {
  try {
    const res = await fetch('https://restcountries.com/v3.1/all?fields=name,cca2,flags,idd');
    const arr = await res.json();
    const mapped = arr.map(c => {
      const code = (c.cca2 || '').toUpperCase();
      const name = (c.name && (c.name.common || c.name.official)) ? (c.name.common || c.name.official) : '';
      const flag = (c.flags && (c.flags.svg || c.flags.png)) ? (c.flags.svg || c.flags.png) : null;
      // idd.root and idd.suffixes to build calling code (best effort)
      let calling = null;
      try {
        if (c.idd && c.idd.root) {
          calling = c.idd.root + ((c.idd && Array.isArray(c.idd.suffixes) && c.idd.suffixes[0]) ? c.idd.suffixes[0] : '');
        }
      } catch(e){}
      return { name, code, flag, callingCode: calling };
    }).sort((a,b)=> a.name.localeCompare(b.name));
    // add de-facto entries manually
    const extras = [
      { name: 'Somaliland (de-facto)', code: 'XS-SL', flag: 'https://upload.wikimedia.org/wikipedia/commons/0/0c/Flag_of_Somaliland.svg', callingCode: '+252 (use local)' },
      { name: 'Taiwan (Republic of China)', code: 'TW', flag: 'https://upload.wikimedia.org/wikipedia/commons/7/72/Flag_of_the_Republic_of_China.svg', callingCode: '+886' },
      { name: 'Kosovo', code: 'XK', flag: 'https://upload.wikimedia.org/wikipedia/commons/1/1f/Flag_of_Kosovo.svg', callingCode: '+383' },
      { name: 'Palestine', code: 'PS', flag: 'https://upload.wikimedia.org/wikipedia/commons/0/00/Flag_of_Palestine.svg', callingCode: '+970' }
    ];
    // merge, avoid duplicates (by code)
    const have = new Set(mapped.map(m => m.code));
    extras.forEach(e => { if (!have.has(e.code)) mapped.push(e); });
    return mapped.sort((a,b)=> a.name.localeCompare(b.name));
  } catch (err) {
    console.error('fetchRESTCountries failed', err);
    // fallback: small set
    return [
      { name:'Somalia', code:'SO', flag: 'https://restcountries.com/data/som.svg', callingCode: '+252' },
      { name:'Somaliland (de-facto)', code:'XS-SL', flag:'https://upload.wikimedia.org/wikipedia/commons/0/0c/Flag_of_Somaliland.svg', callingCode: '+252' },
      { name:'Taiwan', code:'TW', flag:'https://upload.wikimedia.org/wikipedia/commons/7/72/Flag_of_the_Republic_of_China.svg', callingCode:'+886' },
      { name:'United States', code:'US', flag:'https://restcountries.com/data/usa.svg', callingCode:'+1' }
    ];
  }
}

// populate select example
async function populateCountrySelect(selectEl) {
  const countries = await fetchRESTCountries();
  selectEl.innerHTML = '<option value="">Select country</option>' + countries.map(c => {
    const optFlag = c.flag ? ` data-flag="${c.flag}"` : '';
    const code = c.code || '';
    return `<option value="${escapeHtml(code)}"${optFlag}>${escapeHtml(c.name)} ${code ? '('+escapeHtml(code)+')' : ''}</option>`;
  }).join('');
}

/* Open a login modal (uses showModal) */
async function openLoginModal() {
  const html = `
    <h3>Login</h3>
    <label>Username or email</label><input id="modal_login_username" placeholder="username or email">
    <label>Password</label><input id="modal_login_password" type="password" placeholder="password">
    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="modal_login_btn">Login</button>
      <button id="modal_login_cancel" class="btn-ghost">Cancel</button>
    </div>
  `;
  showModal(html);
  document.getElementById('modal_login_cancel').onclick = closeModal;
  document.getElementById('modal_login_btn').onclick = async () => {
    const username = (document.getElementById('modal_login_username').value || '').trim();
    const password = (document.getElementById('modal_login_password').value || '');
    if (!username || !password) return alert('Username and password required');
    try {
      // Use absolute path if provided, otherwise fetchJson will map to API_BASE.
      const r = await fetchJson('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });
      if (!r.ok) return alert('Login failed: ' + (r.error || 'Server error'));
      // Persist token & user, close modal, update nav
      localStorage.setItem('token', r.data.token || r.data.token || '');
      localStorage.setItem('user', JSON.stringify(r.data.user || r.data.user || r.data));
      closeModal();
      applyNavUI();
      attachAuthButtons(); // re-attach to ensure handlers are consistent
      alert('Logged in: ' + ((r.data && (r.data.user && (r.data.user.fullName || r.data.user.username))) || 'User'));
      // reload tree so protected content becomes available
      try { await loadTree(); } catch(e){}
    } catch (err) {
      console.error('login error', err);
      alert('Login error: ' + (err && err.message ? err.message : 'Unknown'));
    }
  };
}

/* Open a simple registration modal */

async function openRegisterModal() {
  const countrySelectHtml = buildCountrySelectHtml('');
  const cityHtml = buildCitySelectHtml('', '');

  const html = `
    <div class="register-modal">
      <h3>Register</h3>

      <label>Full name</label>
      <input id="reg_fullName" placeholder="Full name" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">

      <label>Username</label>
      <input id="reg_username" placeholder="username or email" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">

      <label>Country</label>
      ${countrySelectHtml}

      <label>City</label>
      <div id="reg_city_container">${cityHtml}</div>

      <label>Phone (eg. +252...)</label>
      <input id="reg_phone" placeholder="+2519xxxxxxxx" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">

      <label>Password</label>
      <input id="reg_password" type="password" placeholder="Password" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">

      <label>Confirm password</label>
      <input id="reg_password_confirm" type="password" placeholder="Confirm password" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">

      <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
        <button id="reg_cancel" class="btn-ghost">Cancel</button>
        <button id="reg_submit" class="btn">Register</button>
      </div>
    </div>
  `;
  showModal(html);

  // wire country change -> populate city container
  document.getElementById('profile_country').addEventListener('change', (ev) => {
    const code = ev.target.value;
    const cityContainer = document.getElementById('reg_city_container');
    cityContainer.innerHTML = buildCitySelectHtml(code, '');
  });

  document.getElementById('reg_cancel').onclick = closeModal;
  document.getElementById('reg_submit').onclick = async () => {
    const fullName = (document.getElementById('reg_fullName').value || '').trim();
    const username = (document.getElementById('reg_username').value || '').trim();
    const country = (document.getElementById('profile_country').value || '').trim();
    const cityEl = document.getElementById('profile_city') || document.getElementById('reg_city') || document.querySelector('#reg_city_container input');
    const city = cityEl ? (cityEl.value || '').trim() : '';
    const phoneNumber = (document.getElementById('reg_phone').value || '').trim();
    const password = (document.getElementById('reg_password').value || '');
    const confirm = (document.getElementById('reg_password_confirm').value || '');

    if (!fullName || !username || !password) return alert('Full name, username and password are required');
    if (password.length < 6) return alert('Password must be at least 6 characters');
    if (password !== confirm) return alert('Passwords do not match');

    // simple phone validation (optional)
    if (phoneNumber && !/^\+?[0-9\-\s()]{7,20}$/.test(phoneNumber)) return alert('Enter a valid phone number with country code');

    const countryName = (COUNTRIES.find(c => c.code === country) || {}).name || country || null;
    const countryFlagEmoji = codeToFlagEmoji(country);

    // send registration
    const payload = {
      username, fullName, password,
      phoneNumber: phoneNumber || undefined,
      country: country || undefined,
      countryName: countryName || undefined,
      countryFlagEmoji: countryFlagEmoji || undefined,
      city: city || undefined
    };

    const r = await fetchJson('/api/auth/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!r || !r.ok) {
      const errMsg = r && (r.error || (r.data && (r.data.error || r.data.message))) ? (r.error || r.data.error || r.data.message) : 'Registration failed';
      return alert(errMsg);
    }

    // If server returned token, store and update UI
    if (r.data && r.data.token) {
      localStorage.setItem('token', r.data.token);
    }
    if (r.data && r.data.user) {
      localStorage.setItem('user', JSON.stringify(r.data.user));
    } else if (r.user) {
      localStorage.setItem('user', JSON.stringify(r.user));
    }

    alert('Registered successfully');
    closeModal();
    if (typeof applyNavUI === 'function') applyNavUI();
  };
}

/* doLogout: clears session & refreshes UI */
function doLogout(){
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  // optional: clear opened announcements to reset badge state
  // localStorage.removeItem(OPENED_KEY);
  applyNavUI();
  attachAuthButtons();
  // refresh tree to hide protected content
  try { loadTree(); } catch(e){}
  // close any open settings dropdown/modal
  try { closeModal(); } catch(e){}
  alert('Logged out');
}

/* updateSettingsDropdown: ensures mobile settings reflect login/admin state */
/* updateSettingsDropdown: ensures mobile settings reflect login/admin state
   ‚Äî Fix: always include ENG / SOM language buttons and attach handlers here
*/
function updateSettingsDropdown(){
  const dd = document.getElementById('settingsDropdown');
  if (!dd) return;
  const token = !!getToken();
  const admin = isAdmin();

  // Build inner content so it remains consistent across nav updates
  const innerParts = [];

  if (token) {
    innerParts.push(`<button id="sLogout" class="settings-item"><span class="icon">üö™</span> Logout</button>`);
    innerParts.push(`<button id="sBalance" class="settings-item"><span class="icon">üí∞</span> Balance</button>`);
    innerParts.push(`<button id="sConvert" class="settings-item"><span class="icon">üîÅ</span> Convert Points</button>`);
    if (admin) innerParts.push(`<button id="sChecking" class="settings-item"><span class="icon">‚úÖ</span> Checking</button>`);
    innerParts.push(`<div class="divider"></div>`);
    innerParts.push(`<button id="sEditProfile" class="settings-item"><span class="icon">‚úèÔ∏è</span> Edit Profile</button>`);
  } else {
    // guest UI: show Login / Register only
    innerParts.push(`<button id="sLogin" class="settings-item"><span class="icon">üîê</span> Login</button>`);
    innerParts.push(`<button id="sRegister" class="settings-item"><span class="icon">üßæ</span> Register</button>`);
  }

  innerParts.push(`<div class="divider"></div>`);

  // Language selector (always present)
  innerParts.push(`
    <div style="display:flex;gap:8px;padding:4px 4px;align-items:center">
      <button id="langEng" class="small-btn" style="flex:1">ENG</button>
      <button id="langSom" class="small-btn" style="flex:1">SOM</button>
    </div>
  `);

  innerParts.push(`<div class="divider"></div>`);

  // admin actions (visible only if admin)
  if (admin) {
    innerParts.push(`<button id="sAddFolder" class="settings-item"><span class="icon">‚ûï</span> + Add Folder</button>`);
    innerParts.push(`<button id="sRecycle" class="settings-item"><span class="icon">üóëÔ∏è</span> Recycle Bin</button>`);
  }

  // set inner HTML
  dd.querySelector('.inner').innerHTML = innerParts.join('');

  // Attach the new handlers (safe attaching)
  const tryBind = (id, fn) => { const el = document.getElementById(id); if (el) { el.onclick = fn; } };

  tryBind('sLogin', async (e) => { e.preventDefault(); closeSettingsDropdownSilently(); await openLoginModal(); });
  tryBind('sRegister', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openRegisterModal(); });
  tryBind('sLogout', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); doLogout(); });
  tryBind('sBalance', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openBalanceModal(); });
  tryBind('sConvert', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openConvertModal(); });
  tryBind('sChecking', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openAdminWithdrawals(); });
  tryBind('sEditProfile', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openEditProfile(); });
  tryBind('sAddFolder', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openAddFolderModal(null); });
  tryBind('sRecycle', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openRecycleModal(); });

  // Language handlers (attach here so they exist even after rebuild)
  tryBind('langEng', (e) => {
    e.preventDefault();
    // setLang expects 'en' or 'som' (your setLang will normalize)
    if (typeof setLang === 'function') setLang('en');
    else localStorage.setItem('lang','en');
    if (typeof applyNavUI === 'function') applyNavUI();
    if (typeof renderAfterLangChange === 'function') renderAfterLangChange();
    closeSettingsDropdownSilently();
  });
  tryBind('langSom', (e) => {
    e.preventDefault();
    if (typeof setLang === 'function') setLang('som');
    else localStorage.setItem('lang','som');
    if (typeof applyNavUI === 'function') applyNavUI();
    if (typeof renderAfterLangChange === 'function') renderAfterLangChange();
    closeSettingsDropdownSilently();
  });

  // small helper to close settings dropdown if present
  function closeSettingsDropdownSilently(){
    const settingsDrop = document.getElementById('settingsDropdown');
    if (settingsDrop) settingsDrop.classList.remove('open');
  }
}

/* setDisplay helper (safe) */
function setDisplay(id, show){
  const el = document.getElementById(id);
  if (!el) return;
  el.style.display = show ? '' : 'none';
}

/* applyNavUI: show/hide header buttons + admin links; call updateSettingsDropdown to sync mobile settings */
function applyNavUI(){
  const token = !!getToken();
  const admin = isAdmin();
  const user = getUser();

  // desktop auth buttons
  setDisplay('btn-login', !token);
  setDisplay('btn-register', !token);
  setDisplay('btn-logout', token);
  setDisplay('btn-edit-profile', token);
  setDisplay('btn-balance', token);
  setDisplay('btn-convert', token);
  setDisplay('btn-check-withdrawals', token && admin);

  // admin desktop buttons
  setDisplay('btn-add-folder', token && admin);
  setDisplay('btn-recycle', token && admin);

  // nav admin-only anchors
  document.querySelectorAll('.admin-link').forEach(a => {
    a.style.display = (token && admin) ? '' : 'none';
  });

  // settings dropdown mobile: show/hide admin items inside dropdown (we rebuild its inner HTML)
  updateSettingsDropdown();

  // update bell button visibility (we always show it if there is a btnBell)
  const bell = document.getElementById('btnBell');
  if (bell) bell.style.display = '';

  // update header user full name (if present)
  const headerNameEl = document.getElementById('headerUserFull');
  if (headerNameEl) {
    if (user) headerNameEl.innerText = user.fullName || user.username || '';
    else headerNameEl.innerText = '';
  }

  // ensure mobile panel admin links are hidden for non-admins
  document.querySelectorAll('#mobileMenu .admin-link').forEach(node => { node.style.display = (token && admin) ? '' : 'none'; });

  // make sure settings & hamburger ARIA states are consistent
  const btnHamburger = document.getElementById('btnHamburger');
  const mobileMenu = document.getElementById('mobileMenu');
  if (btnHamburger && mobileMenu) {
    btnHamburger.setAttribute('aria-expanded', mobileMenu.classList.contains('open') ? 'true' : 'false');
  }
}

/* attachAuthButtons: bind header buttons (login/register/logout/edit profile) */
function attachAuthButtons(){
  // Desktop: login
  const bLogin = document.getElementById('btn-login');
  if (bLogin) {
    bLogin.onclick = async (e) => { e.preventDefault(); await openLoginModal(); };
  }
  // desktop register
  const bReg = document.getElementById('btn-register');
  if (bReg) bReg.onclick = (e) => { e.preventDefault(); openRegisterModal(); };

  // logout
  const bOut = document.getElementById('btn-logout');
  if (bOut) bOut.onclick = (e) => { e.preventDefault(); doLogout(); };

  // edit profile
  const bEdit = document.getElementById('btn-edit-profile');
  if (bEdit) bEdit.onclick = (e) => { e.preventDefault(); openEditProfile(); };

  // recycle & add folder desktop shortcuts (admin only)
  const bRecycle = document.getElementById('btn-recycle');
  if (bRecycle) bRecycle.onclick = (e) => { e.preventDefault(); openRecycleModal(); };
  const bAddFolder = document.getElementById('btn-add-folder');
  if (bAddFolder) bAddFolder.onclick = (e) => { e.preventDefault(); openAddFolderModal(null); };

  // ensure settings dropdown content is up-to-date
  updateSettingsDropdown();
}

/* run initializers at DOMContentLoaded (replace any older in-file initial call) */
document.addEventListener('DOMContentLoaded', () => {
  // ensure header user full name element exists
  if (!document.getElementById('headerUserFull')) {
    const brand = document.querySelector('.sh-brand');
    if (brand) {
      const span = document.createElement('span');
      span.id = 'headerUserFull';
      span.style.marginLeft = '8px';
      span.style.fontWeight = '600';
      span.style.fontSize = '14px';
      brand.appendChild(span);
    }
  }

  applyNavUI();
  attachAuthButtons();
  // refresh bell badge when nav UI is applied
  try { if (typeof fetchHelpUnreadCount === 'function') fetchHelpUnreadCount(); } catch(e){}
});
/******************* END AUTH & NAV PATCH ******************************/

/* run on startup */
document.addEventListener('DOMContentLoaded', () => {
  // ensure header user full name element exists, if not create it
  if (!document.getElementById('headerUserFull')) {
    const brand = document.querySelector('.sh-brand');
    if (brand) {
      const span = document.createElement('span');
      span.id = 'headerUserFull';
      span.style.marginLeft = '8px';
      span.style.fontWeight = '600';
      span.style.fontSize = '14px';
      brand.appendChild(span);
    }
  }

  // attach handlers and make initial UI adjustments
  attachAuthButtons();

  // call applyNavUI at boot
  try { applyNavUI(); } catch(e){ console.warn('applyNavUI error', e); }

  // Re-create mobile dropdown login/logout entry immediately
  try { const dd = document.getElementById('navDropdown'); if (dd) { /* reset built in mobile content if needed */ applyNavUI(); } } catch(e){}
});

/* If your app has its own login/logout flows elsewhere, call applyNavUI() after they finish.
   Example: after successful login elsewhere -> localStorage.setItem(...), then applyNavUI(); renderNav();
*/
  function renderAfterLangChange(){ if (!treeCache) treeCache = []; if (!currentFolderId) { renderRootFolders(treeCache); pathStack = []; updateHeaderForFolder(null); } else { const node = findNodeById(currentFolderId, treeCache); if (!node) { currentFolderId = null; pathStack=[]; renderRootFolders(treeCache); updateHeaderForFolder(null); return; } pathStack = buildPathToNode(node._id, treeCache); updateHeaderForFolder(node); renderFolderView(node); } const lang=getLang();  }




  (function(){
  const $ = id => document.getElementById(id);
  const hasFn = (n) => typeof window[n] === 'function';

  // DOM refs
  const btnHamburger = $('btnHamburger');
  const mobileMenu    = $('mobileMenu');
  const btnSettings   = $('btnSettings');
  const settingsDrop  = $('settingsDropdown');
  const btnBell       = $('btnBell') || $('btn-help') || $('btnHelp');
  const modalRoot     = $('modalRoot');

  // open/close mobile nav
  function openMobile(){ if (!mobileMenu) return; mobileMenu.classList.add('open'); if (btnHamburger) btnHamburger.setAttribute('aria-expanded','true'); mobileMenu.setAttribute('aria-hidden','false'); }
  function closeMobile(){ if (!mobileMenu) return; mobileMenu.classList.remove('open'); if (btnHamburger) btnHamburger.setAttribute('aria-expanded','false'); mobileMenu.setAttribute('aria-hidden','true'); }
  function toggleMobile(){ if (!mobileMenu) return; mobileMenu.classList.contains('open') ? closeMobile() : openMobile(); }

  // settings dropdown
  function openSettings(){ if (!settingsDrop) return; settingsDrop.classList.add('open'); if (btnSettings) btnSettings.setAttribute('aria-expanded','true'); settingsDrop.setAttribute('aria-hidden','false'); }
  function closeSettings(){ if (!settingsDrop) return; settingsDrop.classList.remove('open'); if (btnSettings) btnSettings.setAttribute('aria-expanded','false'); settingsDrop.setAttribute('aria-hidden','true'); }
  function toggleSettings(){ if (!settingsDrop) return; settingsDrop.classList.contains('open') ? closeSettings() : openSettings(); }

  function on(id, fn){ const el = $(id); if (!el) return false; el.addEventListener('click', fn); return true; }

  // patch applyNavUI so it doesn't hide gear/bell on mobile
  (function patchApplyNavUI(){
    const orig = window.applyNavUI;
    window.applyNavUI = function(...args){
      try { if (typeof orig === 'function') orig(...args); } catch(e){ console.warn('applyNavUI original failed', e); }
      if (btnBell) btnBell.style.display = '';
      // don't force-hide btnSettings here because CSS controls desktop/mobile visibility
      try { if (typeof fetchHelpUnreadCount === 'function') fetchHelpUnreadCount(); } catch(e){ /*ignore*/ }
    };
  })();

  // attach handlers
  function attach(){
    // hamburger toggles mobile menu
    if (btnHamburger && mobileMenu) {
      btnHamburger.addEventListener('click', (e) => { e.stopPropagation(); toggleMobile(); });

      // close only when a nav link (mobile-nav-link) is clicked
      mobileMenu.addEventListener('click', (ev) => {
        const a = ev.target.closest('a');
        if (a && a.classList.contains('mobile-nav-link')) {
          // allow default navigation then close
          closeMobile();
        }
      });
    }

    // settings gear toggles settings dropdown (gear visible on mobile/tablet)
    if (btnSettings && settingsDrop) {
      btnSettings.addEventListener('click', (e) => { e.stopPropagation(); toggleSettings(); });
    }

    // bell button (announcements)
    if (btnBell) {
      btnBell.addEventListener('click', (e) => {
        e.stopPropagation();
        if (hasFn('openBellModal')) return openBellModal();
        if (modalRoot) {
          modalRoot.innerHTML = '<div class="modal-backdrop"><div class="modal"><h3>Announcements</h3><div style="padding:12px;color:#666">No announcements (demo)</div><div style="display:flex;justify-content:flex-end"><button id="closeAnn" class="small-btn">Close</button></div></div></div>';
          modalRoot.style.display = 'block';
          const cb = $('closeAnn'); if (cb) cb.onclick = () => { modalRoot.style.display='none'; modalRoot.innerHTML=''; };
        } else alert('Announcements (demo)');
      });
    }

    // global outside-click close
    document.addEventListener('click', (ev) => {
      if (mobileMenu && !mobileMenu.contains(ev.target) && btnHamburger && !btnHamburger.contains(ev.target)) closeMobile();
      if (settingsDrop && !settingsDrop.contains(ev.target) && btnSettings && !btnSettings.contains(ev.target)) closeSettings();
    });

    // Escape closes menus
    document.addEventListener('keydown', (ev) => { if (ev.key === 'Escape') { closeMobile(); closeSettings(); } });

    // Settings actions
    on('sLogout', async (e) => { e.preventDefault(); localStorage.removeItem('token'); localStorage.removeItem('user'); if (hasFn('applyNavUI')) applyNavUI(); closeSettings(); alert('Logged out (demo)'); });
    on('sBalance', async (e) => { e.preventDefault(); closeSettings(); if (hasFn('openBalanceModal')) return openBalanceModal(); alert('Balance (demo)'); });
    on('sConvert', async (e) => { e.preventDefault(); closeSettings(); if (hasFn('openConvertModal')) return openConvertModal(); alert('Convert Points (demo)'); });
    on('sChecking', async (e) => { e.preventDefault(); closeSettings(); if (hasFn('openAdminWithdrawals')) return openAdminWithdrawals(); alert('Checking (demo)'); });
    on('sEditProfile', (e) => { e.preventDefault(); closeSettings(); if (hasFn('openEditProfile')) return openEditProfile(); alert('Edit profile (demo)'); });
    on('sAddFolder', (e) => { e.preventDefault(); closeSettings(); if (hasFn('openAddFolderModal')) return openAddFolderModal(null); alert('Add Folder (demo)'); });
    on('sRecycle', (e) => { e.preventDefault(); closeSettings(); if (hasFn('openRecycleModal')) return openRecycleModal(); alert('Recycle (demo)'); });

    // Desktop quick buttons
    on('btn-add-folder', (e) => { e.preventDefault(); if (hasFn('openAddFolderModal')) return openAddFolderModal(null); alert('Add Folder (demo)'); });
    on('btn-recycle', (e) => { e.preventDefault(); if (hasFn('openRecycleModal')) return openRecycleModal(); alert('Recycle (demo)'); });

    // Language buttons inside settings
    const langEnEl = $('langEng') || $('lang-en');
    const langSomEl = $('langSom') || $('lang-som');
    if (langEnEl) langEnEl.addEventListener('click', () => { if (hasFn('setLang')) setLang('en'); else localStorage.setItem('lang','en'); if (hasFn('applyNavUI')) applyNavUI(); if (hasFn('renderAfterLangChange')) renderAfterLangChange(); });
    if (langSomEl) langSomEl.addEventListener('click', () => { if (hasFn('setLang')) setLang('som'); else localStorage.setItem('lang','som'); if (hasFn('applyNavUI')) applyNavUI(); if (hasFn('renderAfterLangChange')) renderAfterLangChange(); });

    // ARIA defaults
    if (mobileMenu) mobileMenu.setAttribute('aria-hidden', mobileMenu.classList.contains('open') ? 'false' : 'true');
    if (settingsDrop) settingsDrop.setAttribute('aria-hidden', settingsDrop.classList.contains('open') ? 'false' : 'true');
    if (btnHamburger && !btnHamburger.hasAttribute('aria-expanded')) btnHamburger.setAttribute('aria-expanded','false');
    if (btnSettings && !btnSettings.hasAttribute('aria-expanded')) btnSettings.setAttribute('aria-expanded','false');

    // initial bell badge poll
    if (hasFn('fetchHelpUnreadCount')) try { fetchHelpUnreadCount(); } catch(e){ console.warn(e); }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();

  // debug helpers
  window._menuDebug = { openMobile: ()=> { const el = $('mobileMenu'); if(el) el.classList.add('open'); }, closeMobile: ()=> { const el = $('mobileMenu'); if(el) el.classList.remove('open'); }, toggleMobile, openSettings, closeSettings, toggleSettings };

})();

  
/* ===================== STARTUP ===================== */
// ensure applyNavUI runs at boot and after login/logout
applyNavUI();
renderAfterLangChange();
loadTree();

</script>
</body>
</html>
