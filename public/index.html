<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>LearningHub ‚Äî Lessons (Improved Tests v2)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>

    :root{ --accent:#0b5cff; --bg:#f6f7fb; --card:#ffffff; --muted:#6b7280; }
    *{box-sizing:border-box}

    :root {
  --danger: #ef4444;
}

/* Modal layout & centering */
.modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; z-index:999; padding:20px; }
.modal { background:#fff; border-radius:12px; padding:18px; max-width:540px; width:100%; box-sizing:border-box; box-shadow:0 18px 50px rgba(8,20,50,0.12); }

/* modal content blocks */
.login-modal, .register-modal {
  max-width:420px;
  margin: 0 auto;
  display:block;
}

/* center title and slightly tighten spacing */
.login-modal h3, .register-modal h3 { text-align:center; margin:0 0 12px 0; font-size:20px; }
.login-modal label, .register-modal label { display:block; margin-top:10px; font-weight:700; }

/* full-width inputs in centered containers */
.login-modal input, .register-modal input, .register-modal select, .register-modal textarea {
  width:100%;
  box-sizing:border-box;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid #e6eefb;
  margin-top:6px;
  background: #fff;
}

/* pw wrapper and eye button */
.pw-wrapper { position: relative; display:block; width:100%; }
.pw-wrapper input[type="password"], .pw-wrapper input[type="text"] { padding-right:46px; }

/* Eye button visuals + animation */
.field-eye-btn {
  position:absolute;
  right:8px;
  top:50%;
  transform: translateY(-50%) rotate(0deg);
  border:0; background:transparent; cursor:pointer; padding:6px; border-radius:8px;
  transition: transform .18s ease, opacity .14s ease;
  display:flex; align-items:center; justify-content:center;
}
.field-eye-btn svg { width:18px; height:18px; display:block; transition: transform .22s cubic-bezier(.2,.9,.28,1), opacity .12s ease; }
.field-eye-btn[aria-pressed="true"] svg { transform: rotate(18deg) scale(.98); }

/* simple show/hide groups animation */
.eye-open, .eye-closed { transition: opacity .16s ease, transform .16s ease; display:inline-block; }
.eye-open.hidden, .eye-closed.hidden { opacity:0; transform: translateY(-4px) scale(.98); pointer-events:none; }
.eye-open.visible, .eye-closed.visible { opacity:1; transform: translateY(0) scale(1); pointer-events:auto; }

/* inline message small */
.inline-msg { margin-top:6px; font-size:13px; color:#6b7280; }

/* password strength bar */
.pw-strength { height:8px; border-radius:8px; background:#eef6ff; width:100%; margin-top:8px; overflow:hidden; box-shadow: inset 0 -1px 0 rgba(0,0,0,0.02); }
.pw-strength .fill { height:100%; width:0%; transition: width .2s ease, background .16s ease; }

/* Buttons */
.btn { padding:9px 12px; border-radius:10px; border:0; background: linear-gradient(180deg,#0b6cff,#0a58d6); color:white; font-weight:700; cursor:pointer; }
.btn-ghost { padding:9px 12px; border-radius:10px; border:1px solid #e6eefb; background:#fff; color:#0b5cff; cursor:pointer; }

/* small responsive tweak */
@media (max-width:480px) {
  .modal { padding:14px; }
  .login-modal, .register-modal { max-width: 100%; }
}


/* Password eye button / modal small tweaks (global) */
.pw-wrapper { position: relative; display: block; }
.field-eye-btn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%) rotate(0deg);
  border: none;
  background: transparent;
  cursor: pointer;
  padding: 6px;
  display:flex;
  align-items:center;
  justify-content:center;
  transition: transform .18s ease, opacity .18s ease;
  opacity: 0.98;
  border-radius:6px;
}
.field-eye-btn svg { width:18px; height:18px; display:block; transition: transform .2s ease; }

/* eye pressed state (rotate slightly) */
.field-eye-btn[aria-pressed="true"] svg { transform: rotate(20deg) scale(0.98); }

/* subtle focus for accessibility */
.field-eye-btn:focus { outline: 3px solid rgba(11,92,255,0.12); outline-offset: 2px; }

/* keep password input with space for icon */
.pw-wrapper input[type="password"], .pw-wrapper input[type="text"] { padding-right: 46px; }

/* optional gradient card style if not already added */
.folder-card, .lesson-card {
  border-radius:12px;
  box-shadow: 0 8px 30px rgba(12,40,80,0.06);
  transition: transform .16s ease, box-shadow .16s ease;
}








/* subtle colored gradients for variety (apply by index or keep single style) */
.folder-card.variant-1 { background: linear-gradient(135deg,#f8fbff,#eef6ff); border-color: rgba(224,235,255,1); }
.folder-card.variant-2 { background: linear-gradient(135deg,#fff8f9,#fff3f6); border-color: rgba(255,230,236,1); }
.lesson-card.variant-1  { background: linear-gradient(135deg,#ffffff,#f8fff6); border-color: rgba(229,255,240,1); }

/* hover lift */
.folder-card:hover, .lesson-card:hover {
  transform: translateY(-8px);
  box-shadow: 0 20px 50px rgba(12,40,80,0.12);
}

/* keep icons neat */
.folder-icon {
  width:52px;height:52px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;background:#fff;border:1px solid rgba(232,241,255,1);box-shadow:0 6px 18px rgba(12,40,80,0.04);
}

/* ensure the password container positions the eye correctly */
.lh-modal .pw-wrapper { position: relative; display:block; }


/* Modern balance modal style (updated colors + buttons) */
.balance-modal {
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  max-width: 520px;
  padding: 18px;
  border-radius: 12px;
  background: linear-gradient(180deg, #ffffff, #fbfdff);
  box-shadow: 0 12px 40px rgba(8,20,50,0.08);
  color: #0f1724;
  line-height: 1.3;
}
.balance-modal h3 { margin: 0 0 10px; font-size: 20px; }
.balance-user { display:flex; align-items:center; gap:12px; }
.balance-avatar {
  width:44px; height:44px; border-radius:10px; background: linear-gradient(135deg,#eef2ff,#e6f7ff);
  display:flex; align-items:center; justify-content:center; font-weight:700; color:#0b5cff;
}
.balance-row { margin-top:12px; display:flex; align-items:center; justify-content:space-between; }
.balance-col { flex:1; }
.counter { font-weight:700; font-size:20px; }
.counter-sub { font-size:12px; color:#475569; margin-top:6px; }

/* button group - improved primary blue */
.btn-row { margin-top:16px; display:flex; gap:8px; justify-content:flex-end; }
.btn {
  padding:8px 12px; border-radius:8px; border:0; cursor:pointer; font-weight:600;
  background: linear-gradient(180deg,#0b6cff,#0a58d6); color:white;
  box-shadow: 0 6px 18px rgba(10,86,214,0.14);
}
.btn-ghost {
  padding:8px 12px; border-radius:8px; border:1px solid #e6eefb; background:white; color:#0b5cff; cursor:pointer;
}
.small-muted { font-size:12px; color:#94a3b8; }

/* compact list for requests */
.requests-list { max-height:360px; overflow:auto; margin-top:10px; padding:6px; border-radius:8px; background:#fbfdff; border:1px solid #eef2ff; }
.request-item { padding:10px; border-bottom:1px solid #f1f5f9; display:flex; justify-content:space-between; gap:10px; align-items:center; }
.request-left { display:flex; flex-direction:column; gap:4px; }
.request-status { padding:6px 8px; border-radius:10px; font-weight:700; font-size:12px; }
.status-pending { background:#fff7ed; color:#b45309; border:1px solid rgba(245,158,11,0.08); }
.status-verified { background:#ecfdf5; color:#059669; border:1px solid rgba(16,185,129,0.08); }
.status-rejected { background:#fff1f2; color:#be123c; border:1px solid rgba(239,68,68,0.08); }
.small-cta { font-size:13px; padding:6px 8px; border-radius:8px; cursor:pointer; background:#f1f5f9; border:0; }
.toggle-row { display:flex; gap:8px; align-items:center; margin-top:8px; }

/* countdown display */
.countdown { font-weight:700; color:#0b5cff; }

/* responsive */
@media (max-width:520px){
  .balance-modal { width:calc(100vw - 32px); }
  .counter { font-size:18px; }
  .btn-row { flex-direction:column; align-items:stretch; }
}

/* Unopened (new) title highlight + small badge */
.ann-unopened .ann-title { color: var(--danger); }
.ann-new-badge {
  display:inline-block;
  background:var(--danger);
  color:#fff;
  font-size:12px;
  padding:2px 8px;
  border-radius:999px;
  margin-left:8px;
  vertical-align:middle;
  font-weight:700;
  line-height:1;
}

/* Preview text: make sure it doesn't push full height (JS will only insert first line) */
.ann-text { margin-top:8px; color:#111; font-size:14px; line-height:1.45; }

     /* small style improvements for the bell modal and list */
  .ann-unopened { background: linear-gradient(90deg, rgba(11,92,255,0.04), transparent); }
  .ann-row { padding:12px; border-bottom:1px solid #eef2f6; border-radius:8px; margin:6px 0; }
  .ann-title { font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-size:15px }
  .ann-meta { color:#6b7280; font-size:12px; margin-top:4px }
  .ann-text { margin-top:8px; white-space:pre-wrap; line-height:1.45; color:#111 } /* pre-wrap preserves newlines */
  .btn-ghost { background:#fff;border:1px solid #e6e6e6;padding:6px 10px;border-radius:8px;cursor:pointer }
  .btn-primary { background:#0b5cff;color:#fff;border:0;padding:8px 10px;border-radius:8px;cursor:pointer }
  .small-btn { padding:6px 8px;border-radius:8px;border:1px solid #e6e6e6;background:#fff }
    /* ---------- Icon-picker drop-in styles ---------- */
/* Put these near your existing modal styles */
.icon-picker {
  display:flex;
  gap:10px;
  align-items:center;
  width:100%;
  flex-wrap:wrap;
}
.icon-picker .picker-left {
  display:flex;
  gap:8px;
  align-items:center;
  min-width:250px;
  flex: 1 1 260px;
}
.icon-picker select,
.icon-picker input[type="text"] {
  padding:8px 10px;
  border-radius:8px;
  border:1px solid #e6e6e6;
  background:#fff;
  font-size:14px;
  box-shadow:0 2px 6px rgba(11,92,255,0.03);
}
.icon-picker .fldIconPreview {
  width:56px;
  height:56px;
  border-radius:10px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:26px;
  background:#fff;
  border:1px solid #eef2ff;
  box-shadow:0 6px 18px rgba(10,10,10,0.04);
  flex:0 0 56px;
  overflow:hidden;
}
.icon-picker .fldIconPreview img {
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}
/* small grid option (if you provide clickable emoji grid later) */
.icon-picker-grid {
  display:grid;
  grid-template-columns:repeat(auto-fit, minmax(44px, 1fr));
  gap:6px;
  padding-top:8px;
}
.icon-picker-grid button {
  background:#fff;border:1px solid #f0f0f3;padding:6px;border-radius:8px;font-size:18px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;
}
.icon-picker-grid button.selected { border-color: var(--accent); box-shadow: 0 6px 18px rgba(10,10,10,0.06); transform: translateY(-2px); }
@media (max-width:700px) {
  .icon-picker { gap:8px; }
  .icon-picker .picker-left { flex-basis:100%; }
}


    body{font-family:system-ui,Arial;background:var(--bg);margin:0;padding:0;color:#111}
    header{background:#fff;padding:12px 16px;display:flex;gap:12px;align-items:center;box-shadow:0 1px 0 rgba(0,0,0,0.06)}
    header .brand{font-weight:700}
    nav a{color:#333;text-decoration:none;margin-right:10px}
    .container{max-width:1100px;margin:20px auto;padding:16px}
    .topbar{display:flex;align-items:center;gap:12px}
    .card{background:var(--card);padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(10,10,10,0.04);margin-bottom:12px}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .muted{color:var(--muted)}
    .row{display:flex;gap:12px;align-items:center}
    .folders-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px}
    .folder-card{background:#fff;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(10,10,10,0.04);cursor:pointer;display:flex;flex-direction:column;gap:8px}
    .folder-icon{width:44px;height:44px;border-radius:8px;background:#eef2ff;display:inline-flex;align-items:center;justify-content:center;font-size:20px}
    .folder-actions{margin-left:auto;display:flex;gap:6px}
    .small-btn{background:#f3f4f6;color:#111;padding:6px 8px;border-radius:6px;border:none;cursor:pointer}
    .folder-header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
    .btn-ghost{background:transparent;border:1px solid #e6e6e6;padding:8px 10px;border-radius:8px;color:#333}
    .lessons-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px}
    .lesson-card{background:#fff;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(10,10,10,0.04);display:flex;flex-direction:column;justify-content:space-between;min-height:110px;cursor:pointer}
    .lesson-card h4{margin:0 0 6px 0}
    .lesson-card p{margin:0;color:var(--muted);font-size:13px}
    .lesson-card .card-actions{display:flex;gap:8px;margin-top:10px}
    .crumbs{font-size:14px;color:var(--muted);margin-bottom:8px}
    .crumbs a{color:var(--accent);cursor:pointer;text-decoration:underline;margin-right:6px}
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:999}
    .modal{background:#fff;border-radius:10px;padding:16px;max-width:900px;width:100%;max-height:90vh;overflow:auto}
    input, textarea, select{padding:8px;border-radius:6px;border:1px solid #e6e6e6;margin-top:6px}
    .modal input[type="text"], .modal textarea, .modal select { width:100%; box-sizing:border-box; }
    .opt-row { display:flex; gap:8px; align-items:center; margin-bottom:6px; }
    .opt-row input[type="text"] { flex:1; min-width:120px; width:auto; }
    label{display:block;margin-top:10px;font-weight:600}
    .muted-note{font-size:13px;color:var(--muted);margin-top:6px}
    .lang-btn { background: transparent; color: #333; border: 1px solid #e6e6e6; padding:6px 8px; border-radius:6px; cursor:pointer; margin-left:6px; }
    .lang-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }
    .lesson-view{background:#fff;padding:18px;border-radius:10px;box-shadow:0 6px 20px rgba(10,10,10,0.04)}
    .lesson-content{margin-top:12px;line-height:1.7}
    .test-question { border:1px solid #eef2ff; padding:12px; border-radius:10px; margin-bottom:10px; background:linear-gradient(180deg, #fff,#fbfeff); }
    .test-question h4 { margin:0 0 8px 0; font-size:16px; }
    .test-option { display:flex; align-items:center; gap:10px; padding:8px; border-radius:8px; margin-bottom:6px; background:#fff; border:1px solid #f3f4f6; }
    .test-option input[type="radio"], .test-option input[type="checkbox"] { transform: scale(1.2); margin:0; }
    .test-option label { flex:1; cursor:pointer; }
    .test-controls { display:flex; gap:8px; margin-top:12px; }
    .small-muted { font-size:13px; color:var(--muted); }
    .timer { font-weight:700; margin-left:10px; color:var(--accent); }
    .progress-wrap { width:100%; background:#eef2ff; height:12px; border-radius:12px; overflow:hidden; margin-top:8px }
    .progress-bar { height:100%; width:0%; background:linear-gradient(90deg,var(--accent),#4aa3ff); transition:width .25s ease }
    @media(max-width:700px){ .row{flex-wrap:wrap} .folder-header{flex-direction:column;align-items:flex-start} .modal{max-width:95%;} .container{padding:12px} }
  </style>
</head>
<body>
  <header id="site-header">
    <style>
      :root{
        --accent:#0b5cff;
        --bg:#f6f7fb;
        --card:#ffffff;
        --muted:#6b7280;
        --glass: rgba(255,255,255,0.9);
        --nav-hover-bg: rgba(11,92,255,0.06);
      }
  
      /* header layout */
      #site-header { background:var(--card); border-bottom:1px solid #eef2f6; position:relative; z-index:60; }
      .sh-top { max-width:1100px; margin:0 auto; display:flex; align-items:center; gap:12px; padding:10px 16px; }
      .sh-brand { font-weight:700; display:flex; gap:8px; align-items:center; color:#111; font-size:15px }
      .sh-brand .logo { font-size:18px }
  
      /* desktop nav */
      .sh-nav { display:flex; gap:6px; align-items:center; margin-left:12px; }
      .sh-nav a {
        color:#111;
        text-decoration:none;
        padding:8px 12px;
        border-radius:10px;
        font-size:14px;
        position:relative;
        transition: transform .18s ease, color .12s ease;
        -webkit-tap-highlight-color: transparent;
      }
      .sh-nav a::after {
        content: "";
        position: absolute;
        left: 12px;
        right: 12px;
        bottom: 6px;
        height: 2px;
        background: linear-gradient(90deg,var(--accent),#4aa3ff);
        transform-origin: left center;
        transform: scaleX(0);
        transition: transform .18s ease;
        border-radius:2px;
        opacity:0.95;
      }
      .sh-nav a:hover { color: var(--accent); transform: translateY(-2px); }
      .sh-nav a:hover::after { transform: scaleX(1); }
  
      .sh-right { margin-left:auto; display:flex; align-items:center; gap:8px; }
  
      /* buttons */
      .icon-btn { background:transparent; border:0; padding:8px; border-radius:8px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; transition: transform .12s ease, background .12s ease; }
      .icon-btn:active { transform: translateY(1px); }
      .small-btn { background:#fff; border:1px solid #e6e6e6; padding:6px 8px; border-radius:8px; cursor:pointer; font-size:13px; color:#111; transition: transform .12s ease, box-shadow .12s ease; }
      .small-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 18px rgba(11,92,255,0.06); }
      .badge { display:inline-flex; align-items:center; justify-content:center; min-width:18px; height:18px; padding:0 6px; border-radius:999px; background:#ef4444; color:#fff; font-size:11px }
  
      /* mobile panel (improved) */
      .hamburger { display:none; width:44px; height:44px; align-items:center; justify-content:center; border-radius:8px; }
      .mobile-panel {
        position:fixed; top:64px; right:12px; width:320px; max-width:92vw;
        background:linear-gradient(180deg, rgba(255,255,255,0.98), var(--card));
        border-radius:14px; box-shadow:0 24px 60px rgba(2,6,23,0.14);
        transform-origin:top right;
        transform: translateY(-10px) scale(.98);
        opacity:0; pointer-events:none;
        transition: transform .26s cubic-bezier(.2,.9,.28,1), opacity .22s ease;
        z-index:120;
      }
      .mobile-panel.open { transform: translateY(0) scale(1); opacity:1; pointer-events:auto; }
      .mobile-panel .inner { padding:14px; display:flex; flex-direction:column; gap:10px; }
      .mobile-panel .brand-row { display:flex;align-items:center;gap:10px;padding:8px 6px;border-bottom:1px solid #f1f5f9;margin-bottom:6px }
      .mobile-panel a {
        display:block;
        text-align:left; padding:12px 14px; border-radius:10px; background:transparent; border:0; color:#111; cursor:pointer; font-size:15px;
        transition: transform .14s ease, background .12s ease;
        text-decoration:none;
      }
      .mobile-panel a:hover { background: var(--nav-hover-bg); transform: translateX(6px); color: var(--accent); }
  
      .mobile-panel .section-title { font-weight:700; color:#111; padding:6px 6px; font-size:13px; opacity:.9; }
  
      /* settings dropdown */
      .settings-dropdown {
        position:absolute; top:54px; right:16px; width:320px; max-width:92vw;
        background:var(--card); border-radius:10px; box-shadow:0 20px 60px rgba(2,6,23,0.15);
        transform-origin:top right; transform:translateY(-8px) scale(.98);
        opacity:0; pointer-events:none; transition: transform .18s cubic-bezier(.2,.9,.28,1), opacity .14s ease; z-index:130;
      }
      .settings-dropdown.open { transform:translateY(0) scale(1); opacity:1; pointer-events:auto; }
      .settings-dropdown .inner { padding:10px; display:flex; flex-direction:column; gap:8px; }
      .settings-item { display:flex; align-items:center; gap:10px; padding:10px; border-radius:10px; cursor:pointer; color:#111; border:0; background:transparent; text-align:left; font-size:14px; transition: background .12s ease; }
      .settings-item:hover { background:#f6f9ff; color:var(--accent); }
      .settings-item .icon { width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; background:#fbfdff; border:1px solid #eef6ff; }
  
      .divider { height:1px; background:#f0f3f7; margin:6px 0; border-radius:2px; }
  
      /* responsive behavior */
      @media (max-width:900px) {
        .sh-nav { display:none; }           /* hide desktop nav on mobile */
        .hamburger { display:inline-flex; } /* show hamburger */
        /* show settings gear on mobile */
        #btnSettings { display:inline-flex !important; }
        /* hide wide-screen text buttons on mobile */
        #btn-login, #btn-register, #btn-logout, #btn-balance, #btn-convert, #btn-check-withdrawals, #btn-edit-profile,
        #btn-add-folder, #btn-recycle { display:none !important; }
        .sh-top { padding-right:12px; }
      }
  
      /* hide gear on desktop only */
      @media (min-width:901px) {
        .mobile-panel { display:none; }
        .settings-dropdown { right:18px; }
        #btnSettings { display:none !important; } /* hide on desktop */
      }
  
      /* accessibility / focus */
      .sh-nav a:focus, .mobile-panel a:focus, .settings-item:focus { outline: 3px solid rgba(11,92,255,0.12); outline-offset:4px; border-radius:10px; }
  
    </style>
  
    <div class="sh-top">
      <div class="sh-brand" aria-hidden="false">
        <span class="logo">üìö</span>
        <span>LearningHub</span>
      </div>
  
      <!-- Desktop nav (hidden on small screens) -->
      <nav class="sh-nav" aria-label="Main navigation">
        <a href="admin_dashboard.html" class="admin-link">Dashboard</a>
        <a href="index.html">Lessons</a>
        <a href="leaderboard.html">Leaderboard</a>
        <a href="history.html">History</a>
        <a href="story.html">Stories</a>

        <a href="games.html">Games</a>
        <a href="admin_users.html" class="admin-link">Users</a>
        <a href="helpCenter.html">Helper</a>
      </nav>
  
      <!-- Right controls -->
      <div class="sh-right" role="region" aria-label="User controls">
        <!-- auth text buttons (desktop only) -->
        <button id="btn-login" class="small-btn">Login</button>
        <button id="btn-register" class="small-btn">Register</button>
        <button id="btn-logout" class="small-btn" style="display:none">Logout</button>
  
        <!-- small action buttons (desktop only, visible via applyNavUI) -->
        <button id="btn-balance" class="small-btn" style="display:none">Balance</button>
        <button id="btn-convert" class="small-btn" style="display:none">Convert Points</button>
        <button id="btn-check-withdrawals" class="small-btn" style="display:none">Checking</button>
        <button id="btn-edit-profile" class="small-btn" style="display:none">Edit Profile</button>
  
        <!-- Add folder & recycle buttons (desktop) -->
        <button id="btn-add-folder" class="small-btn" style="display:none">+ Add Folder</button>
        <button id="btn-recycle" class="small-btn" style="display:none">Recycle</button>
  
        <!-- bell (desktop & mobile when applyNavUI shows it) -->
        <button id="btnBell" class="icon-btn" aria-haspopup="true" aria-expanded="false" title="Notifications" style="position:relative; display:none">
          <span style="font-size:18px">üîî</span>
          <span id="help_unread_badge" class="badge" style="display:none; position:absolute; top:-6px; right:-6px">0</span>
        </button>
  
        <!-- settings gear ‚Äî VISIBLE ON MOBILE/TABLET, HIDDEN ON DESKTOP via CSS above -->
        <button id="btnSettings" class="icon-btn" aria-haspopup="true" aria-expanded="false" title="Settings" style="display:none">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7z" stroke="#333" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06A2 2 0 1 1 3.28 16.9l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09c.7 0 1.3-.39 1.51-1a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06c.48.48 1.12.76 1.82.76H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09c0 .6.28 1.14.76 1.52l.06.06A2 2 0 1 1 18.7 8.28l-.06.06c-.48.48-.76 1.12-.76 1.82V11a1.65 1.65 0 0 0 1.51 1H21a2 2 0 1 1 0 4h-.09c-.6 0-1.14.28-1.52.76l-.06.06" stroke="#333" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
  
        <!-- mobile hamburger -->
        <button id="btnHamburger" class="icon-btn hamburger" aria-expanded="false" aria-label="Menu" title="Menu">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none"><path d="M3 6h18M3 12h18M3 18h18" stroke="#111" stroke-width="1.6" stroke-linecap="round"/></svg>
        </button>
      </div> <!-- sh-right -->
    </div> <!-- sh-top -->
  
    <!-- mobile panel: BRAND + NAV ONLY (no account actions here) -->
   
   
    <div id="mobileMenu" class="mobile-panel" aria-hidden="true">
      <div class="inner" role="menu" aria-label="Mobile navigation">
        <div class="brand-row">
          <span style="font-size:20px">üìö</span>
          <div style="font-weight:700">LearningHub</div>
        </div>
        <a href="admin_dashboard.html" class="mobile-nav-link admin-link">Dashboard</a>
        <a href="index.html" class="mobile-nav-link">Lessons</a>
        <a href="leaderboard.html" class="mobile-nav-link">Leaderboard</a>
        <a href="history.html" class="mobile-nav-link">History</a>
        <a href="story.html" class="mobile-nav-link ">Stories</a>
        <a href="games.html" class="mobile-nav-link">Games</a>
        <a href="admin_users.html" class="mobile-nav-link admin-link">Users</a>
        <a href="helpCenter.html" class="mobile-nav-link">Helper</a>
      </div>
    </div>
  
    <!-- settings dropdown (opened by the gear button; gear visible on mobile/tablet only) -->
    <div id="settingsDropdown" class="settings-dropdown" aria-hidden="true">
      <div class="inner" role="menu">
        <button id="sLogout" class="settings-item"><span class="icon">üö™</span> Logout</button>
        <button id="sBalance" class="settings-item"><span class="icon">üí∞</span> Balance</button>
        <button id="sConvert" class="settings-item"><span class="icon">üîÅ</span> Convert Points</button>
        <button id="sChecking" class="settings-item"><span class="icon">‚úÖ</span> Checking</button>
  
        <div class="divider"></div>
  
        <button id="sEditProfile" class="settings-item"><span class="icon">‚úèÔ∏è</span> Edit Profile</button>
        <div style="display:flex;gap:8px;padding:4px 4px;align-items:center">
          <button id="langEng" class="small-btn" style="flex:1">ENG</button>
          <button id="langSom" class="small-btn" style="flex:1">SOM</button>
        </div>
  
        <div class="divider"></div>
  
        <button id="sAddFolder" class="settings-item"><span class="icon">‚ûï</span> + Add Folder</button>
        <button id="sRecycle" class="settings-item"><span class="icon">üóëÔ∏è</span> Recycle Bin</button>
      </div>
    </div>
  </header>
  
  <!-- modal root used by fallback modals -->
  <div id="modalRoot" style="display:none"></div>


<main class="container">
  <div class="card">
    <div class="topbar">
      <div style="flex:1">
        <div class="crumbs" id="breadcrumbs">Home</div>
        <h2 id="pageTitle">Folders</h2>
      </div>
      <div style="width:260px;text-align:right" id="rightHeader"></div>
    </div>

    <div id="contentArea"></div>
  </div>
</main>


<script>
/* ===================== CONFIG & HELPERS ===================== */
const API_BASE = (window.Auth && window.Auth.apiBase) ? window.Auth.apiBase : 'http://localhost:4000';
const QUESTION_SECONDS = 20;

function getToken(){ return (window.Auth && window.Auth.getToken) ? window.Auth.getToken() : localStorage.getItem('token'); }
function getUser(){ return (window.Auth && window.Auth.getUser) ? window.Auth.getUser() : (()=>{ const s=localStorage.getItem('user'); return s?JSON.parse(s):null; })(); }
function isAdmin(){ const u=getUser(); return u && u.role==='admin'; }
function authHeaders(json=true){ const t=getToken(); const h = {}; if (t) h['Authorization']='Bearer '+t; if (json) h['Content-Type']='application/json'; return h; }

async function fetchJson(path, opts={}) {
  try {
    const url = path.startsWith('http') ? path : ( (typeof API_BASE === 'string' && API_BASE) ? API_BASE + path : path );
    const res = await fetch(url, opts);
    const text = await res.text();
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch(e) { data = null; }
    if (!res.ok) {
      return { ok:false, status: res.status, error: (data && (data.error||data.message)) ? (data.error||data.message) : res.statusText, data, rawText: text };
    }
    return { ok:true, status: res.status, data, rawText: text };
  } catch (err) {
    // network-level failure (connection refused, DNS, CORS preflight blocked)
    return { ok:false, error: err.message || 'Network error' };
  }
}


/* ===================== I18N ===================== */
function getLang(){ return localStorage.getItem('lang') || 'en'; }
function setLang(l){ localStorage.setItem('lang', l === 'som' ? 'som' : 'en'); applyNavUI(); renderAfterLangChange(); }
function tLocalized(obj){
  const lang = getLang();
  if (!obj) return '';
  if (typeof obj === 'string') return obj;
  if (typeof obj === 'object') return (lang === 'som' ? (obj.som || obj.en) : (obj.en || obj.som || ''));
  return '';
}

/* ===================== STATE ===================== */
let treeCache = [];
let currentFolderId = null;
let pathStack = [];

/* ===================== UI REFS ===================== */
const contentArea = document.getElementById('contentArea');
const breadcrumbsEl = document.getElementById('breadcrumbs');
const pageTitleEl = document.getElementById('pageTitle');
const rightHeaderEl = document.getElementById('rightHeader');
const modalRoot = document.getElementById('modalRoot');

/* ===================== MODAL HELPERS ===================== */
function showModal(html){
  modalRoot.innerHTML = `<div class="modal-backdrop" role="dialog" aria-modal="true"><div class="modal">${html}</div></div>`;
  modalRoot.style.display = 'block';
}
function closeModal(){ modalRoot.innerHTML = ''; modalRoot.style.display = 'none'; }

/* require login */
function requireLoginModal(message = 'Please log in to continue') {
  const html = `
    <h3>Login required</h3>
    <p class="muted-note">${escapeHtml(message)}</p>
    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="modalLoginBtn">Login</button>
      <button id="modalCloseBtn" class="btn-ghost">Close</button>
    </div>
  `;
  showModal(html);
  document.getElementById('modalCloseBtn').onclick = closeModal;
  document.getElementById('modalLoginBtn').onclick = async () => {
    closeModal();
    try { await document.getElementById('btn-login').onclick(); } catch(e){ if (e && e.message) alert('Login failed: '+e.message); }
  };
}


/* ===================== UTILITIES ===================== */
function escapeHtml(s){ if (s === 0) return '0'; if (!s) return ''; return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

function pickIconForName(name){
  if (!name) return 'üìÅ';
  const n = name.toLowerCase();
  if (n.includes('math') || n.includes('xisaab')) return 'üßÆ';
  if (n.includes('computer')||n.includes('cs')||n.includes('program')||n.includes('kombuter')) return 'üíª';
  if (n.includes('network')) return 'üåê';
  if (n.includes('basic')||n.includes('aas')) return 'üî∞';
  if (n.includes('advanced')||n.includes('mediate')||n.includes('horumarsan')) return 'üöÄ';
  if (n.includes('science')) return 'üî¨';
  if (n.includes('english')||n.includes('language')) return 'üìö';
  return 'üìÅ';
}

async function syncFavoritesFromServer(resp = null) {
  function extractFavs(obj) {
    if (!obj) return null;
    if (Array.isArray(obj.favorites)) return obj.favorites.map(String);
    if (obj.data && Array.isArray(obj.data.favorites)) return obj.data.favorites.map(String);
    if (obj.data && obj.data.user && Array.isArray(obj.data.user.favorites)) return obj.data.user.favorites.map(String);
    if (obj.user && Array.isArray(obj.user.favorites)) return obj.user.favorites.map(String);
    if (obj.data && obj.data.favorites && Array.isArray(obj.data.favorites)) return obj.data.favorites.map(String);
    return null;
  }

  window.userFavorites = window.userFavorites || [];

  try {
    const fromResp = extractFavs(resp);
    if (fromResp) {
      window.userFavorites = fromResp;
      // persist
      localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites));
      return window.userFavorites;
    }

    if (!getToken()) { 
      window.userFavorites = []; 
      localStorage.removeItem('userFavorites');
      return window.userFavorites; 
    }

    let ru = await fetchJson('/api/lessons/users/me', { headers: authHeaders(), method: 'GET' });
    if (!ru || !ru.ok) {
      ru = await fetchJson('/api/users/me', { headers: authHeaders(), method: 'GET' });
    }

    const favs = extractFavs(ru) || extractFavs((ru && ru.data) ? ru.data : null);
    if (favs) {
      window.userFavorites = favs;
    } else if (ru && ru.ok && ru.data && ru.data.user && Array.isArray(ru.data.user.favorites)) {
      window.userFavorites = ru.data.user.favorites.map(String);
    } else {
      window.userFavorites = window.userFavorites || [];
    }

    // persist the result (even if empty) as a fast local fallback
    localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites));

  } catch (e) {
    console.warn('syncFavoritesFromServer failed', e);
    window.userFavorites = window.userFavorites || [];
    // keep whatever local value existed
    localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites));
  }

  return window.userFavorites;
}


async function openFavoritesModal(){
  if (!getToken()) return requireLoginModal('Log in to view favorites.');

  try {
    // ensure we have up-to-date favorites
    await syncFavoritesFromServer();

    const favs = Array.isArray(window.userFavorites) ? window.userFavorites.map(String) : [];

    let html = `<h3>Your Favorites</h3>`;
    if (favs.length === 0) {
      html += `<div class="muted-note">You haven't favorited any lessons yet.</div>`;
      html += `<div style="margin-top:10px"><button id="closeFavs" class="btn-ghost">Close</button></div>`;
      showModal(html);
      document.getElementById('closeFavs').onclick = closeModal;
      return;
    }

    // fetch lesson details in parallel
    const fetches = favs.map(id => fetchJson('/api/lessons/' + encodeURIComponent(id), { headers: authHeaders(), method: 'GET' }));
    const results = await Promise.all(fetches);

    html += `<div style="max-height:55vh;overflow:auto">`;
    results.forEach((res) => {
      if (!res || !res.ok || !res.data || !res.data.lesson) return;
      const L = res.data.lesson;
      const title = (L.title && L.title.en) ? L.title.en : (typeof L.title === 'string' ? L.title : 'Untitled');
      html += `<div style="padding:8px;border-bottom:1px solid #eee">
        <strong>${escapeHtml(title)}</strong>
        <div class="muted-note" style="margin-top:6px">By: ${escapeHtml(L.author && L.author.fullName ? L.author.fullName : (L.authorId?String(L.authorId):'‚Äî'))} ¬∑ Views: ${L.viewsCount||0}</div>
        <div style="margin-top:6px">
          <button class="small-btn open-fav" data-id="${escapeHtml(L._id)}">Open</button>
          <button class="small-btn remove-fav" data-id="${escapeHtml(L._id)}">Remove</button>
        </div>
      </div>`;
    });
    html += `</div>`;
    html += `<div style="margin-top:10px"><button id="closeFavs" class="btn-ghost">Close</button></div>`;
    showModal(html);

    document.getElementById('closeFavs').onclick = closeModal;

    // handlers use event.currentTarget to avoid closure issues
    document.querySelectorAll('.open-fav').forEach(btn => {
      btn.addEventListener('click', async (ev) => {
        const id = ev.currentTarget.dataset.id;
        closeModal();
        await viewLesson(id);
      });
    });

  
        // ---- replace existing remove-fav handler with this robust version ----
        document.querySelectorAll('.remove-fav').forEach(btn => {
      btn.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        const id = ev.currentTarget.dataset.id;
        if (!id) return alert('Missing lesson id');

        // optimistic UI: disable button while request in-flight
        btn.disabled = true;
        try {
          const r = await fetchJson('/api/lessons/' + encodeURIComponent(id) + '/favorite', { method:'DELETE', headers: authHeaders() });
          console.log('remove favorite response', r);

          if (!r || !r.ok) {
            return alert('Remove failed: ' + (r && r.error ? r.error : 'Server error'));
          }

          // helper to extract favorites array from many possible shapes
          function extractFavs(o){
            if (!o) return null;
            if (Array.isArray(o.favorites)) return o.favorites.map(String);
            if (o.data && Array.isArray(o.data.favorites)) return o.data.favorites.map(String);
            if (o.data && o.data.user && Array.isArray(o.data.user.favorites)) return o.data.user.favorites.map(String);
            if (o.user && Array.isArray(o.user.favorites)) return o.user.favorites.map(String);
            return null;
          }

          // prefer server-returned favorites if present
          let favs = extractFavs(r) || extractFavs(r.data) || extractFavs(r.user);

          if (!favs) {
            // server didn't include favorites ‚Äî re-sync from server to be authoritative
            favs = await syncFavoritesFromServer(r);
          } else {
            // normalize to strings and write into window.userFavorites
            window.userFavorites = favs.map(String);
          }

          // persist locally so refresh/back keeps state
          try { localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites || [])); } catch(e){ console.warn('persist favs failed', e); }

          // refresh folder/lesson UI to reflect removed favorite
          await loadTree();

          // Re-open modal so user sees updated list (close then reopen)
          // closeModal might be your modal close function; ensure it exists
          closeModal();
          openFavoritesModal();

        } catch (err) {
          console.warn('remove-fav handler error', err);
          alert('Remove failed');
        } finally {
          btn.disabled = false;
        }
      });
    });

  } catch (e) {
    console.warn('openFavoritesModal error', e);
    alert('Failed to load favorites');
  }
}


/* ================= ICON OPTIONS (emoji / svg) ================ */
const ICON_OPTIONS = [
  { key:'computer', label:'Computer', icon:'üíª' },
  { key:'man', label:'Man', icon:'üë®' },
  { key:'woman', label:'Woman', icon:'üë©' },
  { key:'beginner', label:'Beginner', icon:'üî∞' },
  { key:'moderate', label:'Moderate', icon:'‚öñÔ∏è' },
  { key:'advanced', label:'Advanced', icon:'üöÄ' },
  { key:'mobile', label:'Mobile', icon:'üì±' },
  { key:'city', label:'City', icon:'üèôÔ∏è' },
  { key:'world', label:'World', icon:'üåç' },
  { key:'network', label:'Network', icon:'üåê' },
  { key:'geography', label:'Geography', icon:'üó∫Ô∏è' },
  { key:'tools', label:'Tools', icon:'üß∞' },
  { key:'code', label:'Code', icon:'üíª' },
  { key:'subjects', label:'Subjects', icon:'üìö' },
  { key:'language', label:'Language', icon:'üó£Ô∏è' },
  { key:'item', label:'Item', icon:'üì¶' },
  { key:'shop', label:'Shop', icon:'üè¨' },
  { key:'folder', label:'Folder', icon:'üìÅ' },
  { key:'gallery', label:'Gallery', icon:'üñºÔ∏è' },
  { key:'audio', label:'Audio', icon:'üîä' },
  { key:'video', label:'Video', icon:'üé¨' },
  { key:'window', label:'Window', icon:'ü™ü' }
];

/* Count lessons recursively inside a folder node */
function countLessonsRecursive(node){
  if (!node) return 0;
  let c = Array.isArray(node.lessons) ? node.lessons.length : 0;
  if (Array.isArray(node.children)) {
    node.children.forEach(child => { c += countLessonsRecursive(child); });
  }
  return c;
}

  /* -------------------------
   New helper: fetch all tests
   ------------------------- */
   async function gatherAllTests() {
  // Returns raw test objects (may be minimal). showAggregatedTestRunner will fetch details if needed.
  try {
    // simple server call: GET /api/tests returns all tests (no filter)
    const r = await fetchJson('/api/tests', { headers: authHeaders(), method: 'GET' });
    if (!r || !r.ok) return [];
    // normalize possible shapes: r.data may be array or { tests: [...] }
    const arr = Array.isArray(r.data) ? r.data : (r.data && Array.isArray(r.data.tests) ? r.data.tests : (Array.isArray(r.tests) ? r.tests : []));
    // dedupe by id
    const seen = new Set();
    const out = [];
    arr.forEach(t => {
      const id = (t && (t._id || t.id));
      if (!id) return;
      const sid = String(id);
      if (seen.has(sid)) return;
      seen.add(sid);
      out.push(t);
    });
    return out;
  } catch (e) {
    console.warn('gatherAllTests failed', e);
    return [];
  }
}


/* ===================== RENDERERS ===================== */

/* Breadcrumbs builder + clickable */
function renderBreadcrumbs(){
  const parts = [{ label:'Home', id: null }, ...pathStack.map(p => ({ label: tLocalized(p.name) || (typeof p.name === 'string' ? p.name : ''), id: p._id }))];
  // if we're viewing a lesson, pageTitle already is lesson; breadcrumbs built elsewhere on lesson view
  breadcrumbsEl.innerHTML = '';
  parts.forEach((p,i)=>{
    const a = document.createElement('a');
    a.innerText = p.label || 'Home';
    a.href = 'javascript:void(0)';
    a.onclick = async () => {
      if (!p.id) { currentFolderId = null; pathStack = []; await loadTree(); return; }
      currentFolderId = p.id;
      await loadTree();
    };
    breadcrumbsEl.appendChild(a);
    if (i < parts.length - 1) {
      const sep = document.createTextNode(' / ');
      breadcrumbsEl.appendChild(sep);
    }
  });
}

function updateHeaderForFolder(folderNode){
  // build pathStack if not present
  renderBreadcrumbs();
  pageTitleEl.innerText = pathStack.length ? (tLocalized(pathStack[pathStack.length-1].name) || pathStack[pathStack.length-1].name) : 'Folders';
  rightHeaderEl.innerHTML = '';

  if (pathStack.length > 0) {
    const back = document.createElement('button');
    back.className = 'small-btn';
    back.innerText = 'Back';
    back.onclick = async () => {
      if (pathStack.length <= 1) {
        currentFolderId = null;
      } else {
        const parent = pathStack[pathStack.length - 2];
        currentFolderId = parent ? parent._id : null;
      }
      await loadTree();
    };
    rightHeaderEl.appendChild(back);
  }

  if (isAdmin()) {
    const addSub = document.createElement('button'); addSub.className='small-btn'; addSub.innerText = '+ Subfolder';
    addSub.onclick = ()=> openAddFolderModal(currentFolderId);
    const addLesson = document.createElement('button'); addLesson.className='small-btn'; addLesson.innerText = '+ Lesson';
    addLesson.onclick = ()=> openAddLessonModal(currentFolderId);
    const addTest = document.createElement('button'); addTest.className='small-btn'; addTest.innerText = '+ Test';
    addTest.onclick = ()=> openAddTestModal(currentFolderId, null);
    rightHeaderEl.appendChild(addSub);
    rightHeaderEl.appendChild(addLesson);
    rightHeaderEl.appendChild(addTest);
  } else {
    // Favorites button (for any logged-in user)
    const favBtnHeader = document.createElement('button');
    favBtnHeader.className = 'small-btn';
    favBtnHeader.innerText = '‚òÖ Favorites';
    favBtnHeader.onclick = () => {
      if (!getToken()) return requireLoginModal('Log in to view favorites.');
      openFavoritesModal();
    };
    rightHeaderEl.appendChild(favBtnHeader);

    // Test All button (new) - shows every test's questions across the app
    const testAllBtn = document.createElement('button');
    testAllBtn.className = 'small-btn';
    testAllBtn.innerText = 'Test All';
    testAllBtn.title = 'Take a randomized test comprised of every question in the app';
    testAllBtn.onclick = async () => {
      if (!getToken()) return requireLoginModal('Log in to take tests.');
      // gather all tests then open aggregated runner
      const all = await gatherAllTests();
      if (!all || all.length === 0) return alert('No tests available in the app.');
      // show aggregation (this will fetch full test content per test and dedupe)
      await showAggregatedTestRunner(all);
    };
    rightHeaderEl.appendChild(testAllBtn);


  }
}

/* Root folders render: show recursive lesson count */
function renderRootFolders(folders){
  contentArea.innerHTML = '';


  if (!folders || folders.length === 0){
    const empty = document.createElement('div');
    empty.className = 'muted';
    empty.innerText = 'No folders yet. please check your connect...".';
    contentArea.appendChild(empty);
    return;
  }

  const grid = document.createElement('div');
  grid.className = 'folders-grid';

  folders.forEach(folder => {
    const fc = document.createElement('div');
    fc.className = 'folder-card';
    // clicking card opens folder but ignore button clicks
    fc.onclick = (e) => { if (e.target.tagName === 'BUTTON') return; openFolder(folder._id); };

    // meta (icon + title)
    const meta = document.createElement('div');
    meta.className = 'meta';

    const icon = document.createElement('div');
    icon.className = 'folder-icon';
    icon.innerText = (folder.icon && folder.icon.length <= 2) ? folder.icon : pickIconForName(tLocalized(folder.name) || (typeof folder.name === 'string' ? folder.name : ''));

    const displayName = tLocalized(folder.name) || (typeof folder.name === 'string' ? folder.name : '');
    const totalLessons = countLessonsRecursive(folder);
    const tit = document.createElement('div');
    tit.innerHTML = `<div style="font-weight:700">${escapeHtml(displayName)}</div><div class="muted-note">${totalLessons} lessons ¬∑ ${ (folder.children||[]).length } subfolders</div>`;

    meta.append(icon, tit);

    // actions
    const actionsWrap = document.createElement('div');
    actionsWrap.style.display = 'flex';
    actionsWrap.style.gap = '6px';

    if (isAdmin()){
      const editBtn = document.createElement('button');
      editBtn.className = 'small-btn';
      editBtn.innerText = 'Edit';
      editBtn.onclick = (ev) => { ev.stopPropagation(); openEditFolderModal(folder); };

      const delBtn = document.createElement('button');
      delBtn.className = 'small-btn';
      delBtn.innerText = folder.isDeleted ? 'Permanently Delete' : 'Delete';
      delBtn.onclick = async (ev) => {
        ev.stopPropagation();
        if (folder.isDeleted) {
          if (!confirm('Perm delete?')) return;
          await fetchJson('/api/lessons/folders/' + folder._id + '?permanent=1', { method:'DELETE', headers: authHeaders() });
        } else {
          if (!confirm('Soft-delete folder?')) return;
          await fetchJson('/api/lessons/folders/' + folder._id, { method:'DELETE', headers: authHeaders() });
        }
        await loadTree();
      };

      actionsWrap.append(editBtn, delBtn);
    } else {
      // non-admin: Open + Take Test + (Favorites quick access is in toolbar)
      const openBtn = document.createElement('button');
      openBtn.className = 'small-btn';
      openBtn.innerText = 'Open';
      openBtn.onclick = (ev) => { ev.stopPropagation(); openFolder(folder._id); };

      const takeBtn = document.createElement('button');
      takeBtn.className = 'small-btn';
      takeBtn.innerText = 'Take Test';
      takeBtn.onclick = (ev) => { ev.stopPropagation(); if (!getToken()) return requireLoginModal('Log in to take tests.'); openTakeTest(folder._id, null); };

      actionsWrap.append(openBtn, takeBtn);
    }

    const bottom = document.createElement('div');
    bottom.style.display = 'flex';
    bottom.style.justifyContent = 'space-between';
    bottom.style.alignItems = 'center';
    bottom.append(meta, actionsWrap);

    fc.appendChild(bottom);
    grid.appendChild(fc);
  });

  contentArea.appendChild(grid);
}



/* Folder view includes children and lessons. Subfolder cards show recursive lesson counts; removed test buttons for non-admins */
function renderFolderView(folderNode){
  contentArea.innerHTML = '';

  const subHeader = document.createElement('div'); subHeader.style.marginBottom='10px';
  const subLabel = document.createElement('div'); subLabel.className='muted'; subLabel.innerText = 'Subfolders';
  subHeader.appendChild(subLabel);
  contentArea.appendChild(subHeader);

  const subGrid = document.createElement('div'); subGrid.className='folders-grid';
  (folderNode.children || []).forEach(child=>{
    const fc = document.createElement('div'); fc.className='folder-card';
    fc.onclick = ()=> openFolder(child._id);
    const childIcon = child.icon && child.icon.length<=2 ? child.icon : pickIconForName(tLocalized(child.name) || (typeof child.name === 'string' ? child.name : ''));
    const childName = tLocalized(child.name) || (typeof child.name === 'string' ? child.name : '');
    const totalLessons = countLessonsRecursive(child);
    fc.innerHTML = `<div style="display:flex;align-items:center;gap:10px"><div class="folder-icon">${escapeHtml(childIcon)}</div><div><div style="font-weight:700">${escapeHtml(childName)}</div><div class="muted-note">${totalLessons} lessons</div></div></div>`;
    if (isAdmin()){
      const footer = document.createElement('div'); footer.style.display='flex'; footer.style.justifyContent='space-between'; footer.style.marginTop='8px';
      const left = document.createElement('div');
      const right = document.createElement('div'); right.style.display='flex'; right.style.gap='6px';
      const editBtn = document.createElement('button'); editBtn.className='small-btn'; editBtn.innerText='Edit';
      editBtn.onclick = (ev)=>{ ev.stopPropagation(); openEditFolderModal(child); };
      const delBtn = document.createElement('button'); delBtn.className='small-btn'; delBtn.innerText = child.isDeleted ? 'Permanently Delete':'Delete';
      delBtn.onclick = async (ev)=>{ ev.stopPropagation(); if (child.isDeleted){ if (!confirm('Perm delete?')) return; await fetchJson('/api/lessons/folders/'+child._id+'?permanent=1',{ method:'DELETE', headers:authHeaders() }); } else { if (!confirm('Soft-delete?')) return; await fetchJson('/api/lessons/folders/'+child._id,{ method:'DELETE', headers:authHeaders() }); } await loadTree(); };
      right.append(editBtn, delBtn);
      footer.append(left,right);
      fc.appendChild(footer);
    } else {
      // add Take Test for subfolders (non-admin)
      const footer = document.createElement('div'); footer.style.display='flex'; footer.style.justifyContent='flex-end'; footer.style.marginTop='8px';
      const takeBtn = document.createElement('button'); takeBtn.className='small-btn'; takeBtn.innerText='Take Test';
      takeBtn.onclick = (ev)=> { ev.stopPropagation(); if (!getToken()) return requireLoginModal('Log in to take tests.'); openTakeTest(child._id, null); };
      footer.appendChild(takeBtn);
      fc.appendChild(footer);
    }

    subGrid.appendChild(fc);
  });
  contentArea.appendChild(subGrid);

  const lessonsHeader = document.createElement('div'); lessonsHeader.style.marginTop='16px';
  const lessonsLabel = document.createElement('div'); lessonsLabel.className='muted'; lessonsLabel.innerText = 'Lessons';
  lessonsHeader.appendChild(lessonsLabel);
  contentArea.appendChild(lessonsHeader);

  const lessonsGrid = document.createElement('div'); lessonsGrid.className='lessons-grid';
  (folderNode.lessons || []).forEach(ls=>{
    const lc = document.createElement('div'); lc.className='lesson-card';
    const title = tLocalized(ls.title) || (ls.title && ls.title.en) || (typeof ls.title === 'string' ? ls.title : 'Untitled');
    const preview = tLocalized(ls.content) || (ls.content && ls.content.en) || '';
    lc.innerHTML = `<div><h4>${escapeHtml(title)}</h4><p>${escapeHtml(preview.slice(0,120))}</p></div>`;
    lc.onclick = ()=> viewLesson(ls._id);

    const actions = document.createElement('div'); actions.className='card-actions';
    if (isAdmin()){
      const edit = document.createElement('button'); edit.className='small-btn'; edit.innerText='Edit'; edit.onclick = (ev)=> { ev.stopPropagation(); openEditLessonModal(ls._id); };
      const del = document.createElement('button'); del.className='small-btn'; del.innerText = ls.isDeleted ? 'Delete Perm' : 'Delete'; del.onclick = async (ev)=>{ ev.stopPropagation(); if (!confirm('Delete lesson?')) return; if (ls.isDeleted) await fetchJson('/api/lessons/'+ls._id+'?permanent=1',{ method:'DELETE', headers: authHeaders() }); else await fetchJson('/api/lessons/'+ls._id,{ method:'DELETE', headers: authHeaders() }); await loadTree(); };
      const addTestBtn = document.createElement('button'); addTestBtn.className='small-btn'; addTestBtn.innerText='Add Test'; addTestBtn.onclick = (ev)=>{ ev.stopPropagation(); openAddTestModal(currentFolderId, ls._id); };
      const questionsBtn = document.createElement('button'); questionsBtn.className='small-btn'; questionsBtn.innerText='Questions'; questionsBtn.onclick = (ev)=>{ ev.stopPropagation(); openLessonQuestionsModal(ls._id); };
      actions.append(edit, del, addTestBtn, questionsBtn);
    } else {
      const view = document.createElement('button'); view.className='small-btn'; view.innerText='View';
      view.onclick = (ev)=> { ev.stopPropagation(); viewLesson(ls._id); };

      const testBtn = document.createElement('button'); testBtn.className='small-btn'; testBtn.innerText='Test';
      testBtn.onclick = (ev) => { ev.stopPropagation(); if (!getToken()) return requireLoginModal('Log in to take tests.'); openTakeTest(null, ls._id); };

      // favorite small toggle in list
      const favBtnList = document.createElement('button'); favBtnList.className = 'small-btn';
      const isFav = (window.userFavorites || []).map(String).includes(String(ls._id));
      favBtnList.innerText = isFav ? '‚òÖ' : '‚òÜ';
      favBtnList.title = isFav ? 'Remove favorite' : 'Add favorite';
      favBtnList.onclick = async (ev) => {
        ev.stopPropagation();
        if (!getToken()) return requireLoginModal('Log in to favorite lessons.');
        try {
          let rr;
          if ((window.userFavorites || []).map(String).includes(String(ls._id))) {
            rr = await fetchJson('/api/lessons/' + encodeURIComponent(ls._id) + '/favorite', { method:'DELETE', headers: authHeaders() });
          } else {
            rr = await fetchJson('/api/lessons/' + encodeURIComponent(ls._id) + '/favorite', { method:'POST', headers: authHeaders() });
          }
          if (!rr || !rr.ok) return alert('Favorite action failed: ' + (rr && rr.error ? rr.error : ''));
          if (Array.isArray(rr.favorites)) {
            window.userFavorites = rr.favorites.map(String);
          } else if (rr.data && Array.isArray(rr.data.favorites)) {
            window.userFavorites = rr.data.favorites.map(String);
          } else {
            await syncFavoritesFromServer(rr);
          }
          // update UI quickly
          const now = (window.userFavorites || []).map(String).includes(String(ls._id));
          favBtnList.innerText = now ? '‚òÖ' : '‚òÜ';
          favBtnList.title = now ? 'Remove favorite' : 'Add favorite';
          await loadTree();
        } catch (e) {
          console.warn('fav list toggle failed', e);
          alert('Favorite failed');
        }
      };

      actions.append(view, testBtn, favBtnList);
    }

    lc.appendChild(actions);
    lessonsGrid.appendChild(lc);
  });
  contentArea.appendChild(lessonsGrid);
}

/* ===================== DATA LOAD ===================== */
async function loadTree(){
// FAST local fallback: populate window.userFavorites from localStorage so UI shows favorites immediately
window.userFavorites = window.userFavorites || [];
  try {
    const saved = localStorage.getItem('userFavorites');
    if (saved) {
      const parsed = JSON.parse(saved);
      if (Array.isArray(parsed)) window.userFavorites = parsed.map(String);
    }
  } catch (e) {
    console.warn('Failed to read saved favorites from localStorage', e);
    window.userFavorites = window.userFavorites || [];
  }

  // fetch tree (server)
  const r = await fetchJson('/api/lessons/tree', { headers: authHeaders(), method: 'GET' });

  // then try to refresh favorites from server (this will overwrite local fallback)
  if (getToken()) {
    try {
      // try lessons-scoped users endpoint first
      let ru = await fetchJson('/api/lessons/users/me', { headers: authHeaders(), method: 'GET' });
      if (!ru || !ru.ok) {
        ru = await fetchJson('/api/users/me', { headers: authHeaders(), method: 'GET' });
      }
      // normalize shapes
      const userObj = (ru && ru.data && ru.data.user) ? ru.data.user : (ru && ru.user ? ru.user : (ru && ru.data ? ru.data : null));
      if (userObj && Array.isArray(userObj.favorites)) {
        window.userFavorites = userObj.favorites.map(String);
        localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites));
      } else {
        // fallback: call syncFavoritesFromServer which handles many shapes and persists
        await syncFavoritesFromServer(ru);
      }
    } catch (e) {
      console.warn('Could not load user favorites:', e);
      // keep localStorage fallback
      window.userFavorites = window.userFavorites || [];
    }
  } else {
    window.userFavorites = [];
    localStorage.removeItem('userFavorites');
  }

  // ... continue with your existing handling of r (tree response)
  if (!r.ok) {
    contentArea.innerHTML = '<div class="muted">Failed to load folders: '+(r.error||'')+'</div>';
    return;
  }
  // rest of your existing loadTree logic follows...
  treeCache = r.data.tree || [];
  if (!currentFolderId) {
    pathStack = [];
    renderRootFolders(treeCache);
    updateHeaderForFolder(null);
  } else {
    const node = findNodeById(currentFolderId, treeCache);
    if (!node) {
      currentFolderId = null;
      pathStack = [];
      renderRootFolders(treeCache);
      updateHeaderForFolder(null);
      return;
    }
    pathStack = buildPathToNode(node._id, treeCache);
    updateHeaderForFolder(node);
    renderFolderView(node);
  }
}

function findNodeById(id, nodes){
  for (const n of nodes){
    if (String(n._id) === String(id)) return n;
    if (n.children && n.children.length){
      const found = findNodeById(id, n.children);
      if (found) return found;
    }
  }
  return null;
}
function buildPathToNode(id, nodes, acc=[]){
  for (const n of nodes){
    if (String(n._id) === String(id)) return [...acc, n];
    if (n.children && n.children.length){
      const res = buildPathToNode(id, n.children, [...acc, n]);
      if (res) return res;
    }
  }
  return null;
}
async function openFolder(id){ currentFolderId = id; await loadTree(); }
async function goHome(){ currentFolderId = null; pathStack = []; await loadTree(); }

/* ===================== FOLDER / LESSON ACTIONS (unchanged) ===================== */
function openAddFolderModal(parentId = null){
  if (!getToken()) return requireLoginModal('You must be logged in as an admin to add folders.');
  if (!isAdmin()) return alert('Only admins may add folders.');
  const iconsHtml = ICON_OPTIONS.map(o => `<option value="${escapeHtml(o.icon)}">${escapeHtml(o.label)} ${escapeHtml(o.icon)}</option>`).join('');
  const html = `
    <h3>Add Folder${parentId ? ' (subfolder)' : ''}</h3>
    <label>Folder name ‚Äî English</label><input id="fldNameEn" placeholder="e.g. Math Basics">
    <label>Folder name ‚Äî Somali</label><input id="fldNameSom" placeholder="e.g. Aas-aaska Xisaabta (optional)">
    <label>Pick icon (emoji) or paste image URL</label>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="fldIconSelect">${iconsHtml}<option value="">-- custom / none --</option></select>
      <input id="fldIconUrl" placeholder="Or paste image URL (http...)" style="flex:1">
      <div id="fldIconPreview" style="width:44px;height:44px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:22px;background:#fff;border:1px solid #eee">üìÅ</div>
    </div>
    <div style="display:flex;gap:8px;margin-top:12px"><button id="createFolderBtn">Create</button><button id="cancelFolderBtn" class="btn-ghost">Cancel</button></div>
  `;
  showModal(html);

  const sel = document.getElementById('fldIconSelect');
  const urlInp = document.getElementById('fldIconUrl');
  const prev = document.getElementById('fldIconPreview');

  function updatePreview() {
    const emoji = sel.value;
    const url = urlInp.value.trim();
    if (url) {
      prev.style.backgroundImage = `url(${escapeHtml(url)})`;
      prev.style.backgroundSize = 'cover';
      prev.style.backgroundPosition = 'center';
      prev.innerText = '';
    } else if (emoji) {
      prev.style.backgroundImage = '';
      prev.innerText = emoji;
    } else {
      prev.style.backgroundImage = '';
      prev.innerText = 'üìÅ';
    }
  }

  sel.onchange = ()=> { if (sel.value) urlInp.value = ''; updatePreview(); };
  urlInp.oninput = ()=> { if (urlInp.value.trim()) sel.value = ''; updatePreview(); };

  document.getElementById('cancelFolderBtn').onclick = closeModal;
  document.getElementById('createFolderBtn').onclick = async ()=> {
    const nameEn = document.getElementById('fldNameEn').value.trim();
    const nameSom = document.getElementById('fldNameSom').value.trim();
    let icon = urlInp.value.trim() || sel.value || '';
    if (!nameEn) return alert('English name required');
    const namePayload = { en: nameEn };
    if (nameSom) namePayload.som = nameSom;
    const r = await fetchJson('/api/lessons/folders', { method:'POST', headers: authHeaders(), body: JSON.stringify({ name: namePayload, parentId, icon }) });
    if (!r.ok) return alert('Create failed: '+(r.error||''));
    closeModal();
    await loadTree();
    if (parentId) openFolder(parentId);
  };

  // init preview
  updatePreview();
}

function openEditFolderModal(folder){
  if (!getToken()) return requireLoginModal('You must be logged in as an admin to edit folders.');
  if (!isAdmin()) return alert('Only admins may edit folders.');
  const nameEn = (typeof folder.name === 'string') ? folder.name : (folder.name && folder.name.en ? folder.name.en : '');
  const nameSom = (typeof folder.name === 'object' && folder.name.som) ? folder.name.som : '';
  const currentIcon = folder.icon || '';
  const iconsHtml = ICON_OPTIONS.map(o => `<option value="${escapeHtml(o.icon)}" ${o.icon===currentIcon?'selected':''}>${escapeHtml(o.label)} ${escapeHtml(o.icon)}</option>`).join('');
  const html = `
    <h3>Edit Folder</h3>
    <label>Name ‚Äî English</label><input id="eNameEn" value="${escapeHtml(nameEn)}">
    <label>Name ‚Äî Somali</label><input id="eNameSom" value="${escapeHtml(nameSom)}">
    <label>Pick icon (emoji) or paste image URL</label>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="eIconSelect">${iconsHtml}<option value="">-- custom / none --</option></select>
      <input id="eIconUrl" placeholder="Or paste image URL (http...)" style="flex:1" value="${(currentIcon && currentIcon.startsWith('http'))?escapeHtml(currentIcon):''}">
      <div id="eIconPreview" style="width:44px;height:44px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:22px;background:#fff;border:1px solid #eee">${(!currentIcon || currentIcon.startsWith('http'))? 'üìÅ' : escapeHtml(currentIcon)}</div>
    </div>
    <div style="display:flex;gap:8px;margin-top:12px"><button id="saveFolderBtn">Save</button><button id="cancelFolderBtn" class="btn-ghost">Cancel</button></div>
  `;
  showModal(html);

  const sel = document.getElementById('eIconSelect');
  const urlInp = document.getElementById('eIconUrl');
  const prev = document.getElementById('eIconPreview');

  function updatePreview() {
    const emoji = sel.value;
    const url = urlInp.value.trim();
    if (url) {
      prev.style.backgroundImage = `url(${escapeHtml(url)})`;
      prev.style.backgroundSize = 'cover';
      prev.style.backgroundPosition = 'center';
      prev.innerText = '';
    } else if (emoji) {
      prev.style.backgroundImage = '';
      prev.innerText = emoji;
    } else {
      prev.style.backgroundImage = '';
      prev.innerText = 'üìÅ';
    }
  }

  sel.onchange = ()=> { if (sel.value) urlInp.value = ''; updatePreview(); };
  urlInp.oninput = ()=> { if (urlInp.value.trim()) sel.value = ''; updatePreview(); };

  document.getElementById('cancelFolderBtn').onclick = closeModal;
  document.getElementById('saveFolderBtn').onclick = async ()=> {
    const nameEnV = document.getElementById('eNameEn').value.trim();
    const nameSomV = document.getElementById('eNameSom').value.trim();
    const iconVal = urlInp.value.trim() || sel.value || '';
    if (!nameEnV) return alert('English name required');
    const namePayload = { en: nameEnV };
    if (nameSomV) namePayload.som = nameSomV;
    const r = await fetchJson('/api/lessons/folders/'+folder._id, { method:'PUT', headers: authHeaders(), body: JSON.stringify({ name: namePayload, icon: iconVal }) });
    if (!r.ok) return alert('Save failed: '+(r.error||''));
    closeModal();
    await loadTree();
  };

  // init preview
  if (currentIcon) {
    if (currentIcon.startsWith('http')) urlInp.value = currentIcon;
    else sel.value = currentIcon;
  }
  updatePreview();
}

function openAddLessonModal(folderId){
  if (!getToken()) return requireLoginModal('Please log in to add a lesson.');
  if (!isAdmin()) return alert('Only admins may add lessons.');
  const html = `
    <h3>Add Lesson</h3>
    <label>Title ‚Äî English</label><input id="lsTitleEn" placeholder="Lesson title">
    <label>Title ‚Äî Somali</label><input id="lsTitleSom" placeholder="Cinwaanka casharka (optional)">
    <label>Content ‚Äî English</label><textarea id="lsContentEn" rows="6" placeholder="Lesson content (text or html)"></textarea>
    <label>Content ‚Äî Somali</label><textarea id="lsContentSom" rows="6" placeholder="Qoraal (optional)"></textarea>
    <div style="display:flex;gap:8px;margin-top:12px"><button id="createLessonBtn">Create Lesson</button><button id="cancelLessonBtn" class="btn-ghost">Cancel</button></div>
  `;
  showModal(html);
  document.getElementById('cancelLessonBtn').onclick = closeModal;
  document.getElementById('createLessonBtn').onclick = async ()=>{
    const titleEn = document.getElementById('lsTitleEn').value.trim();
    const titleSom = document.getElementById('lsTitleSom').value.trim();
    // DO NOT trim content - preserve newlines exactly
    const contentEn = document.getElementById('lsContentEn').value;
    const contentSom = document.getElementById('lsContentSom').value;
    if (!titleEn) return alert('English title required');
    const payload = { title: { en: titleEn }, content: { en: contentEn }, folderId };
    if (titleSom) payload.title.som = titleSom;
    if (contentSom) payload.content.som = contentSom;
    const r = await fetchJson('/api/lessons', { method:'POST', headers: authHeaders(), body: JSON.stringify(payload) });
    if (!r.ok) return alert('Create failed: '+(r.error||''));
    closeModal();
    await loadTree();
    openFolder(folderId);
  };
}



async function openEditLessonModal(lessonId){
  if (!getToken()) return requireLoginModal('Please log in to edit lesson.');
  if (!isAdmin()) return alert('Only admins may edit lessons.');
  const r0 = await fetchJson('/api/lessons/'+lessonId, { headers: authHeaders() });
  if (!r0.ok) return alert('Failed to load lesson: '+(r0.error||''));
  const lesson = r0.data.lesson;
  const titleEn = (lesson.title && lesson.title.en) ? lesson.title.en : (typeof lesson.title === 'string' ? lesson.title : '');
  const titleSom = (lesson.title && lesson.title.som) ? lesson.title.som : '';
  const contentEn = (lesson.content && lesson.content.en) ? lesson.content.en : '';
  const contentSom = (lesson.content && lesson.content.som) ? lesson.content.som : '';
  const html = `
    <h3>Edit Lesson</h3>
    <label>Title ‚Äî English</label><input id="lsTitleEn" value="${escapeHtml(titleEn)}">
    <label>Title ‚Äî Somali</label><input id="lsTitleSom" value="${escapeHtml(titleSom)}">
    <label>Content ‚Äî English</label><textarea id="lsContentEn" rows="6">${escapeHtml(contentEn)}</textarea>
    <label>Content ‚Äî Somali</label><textarea id="lsContentSom" rows="6">${escapeHtml(contentSom)}</textarea>
    <div style="display:flex;gap:8px;margin-top:12px"><button id="saveLessonBtn">Save</button><button id="cancelLessonBtn" class="btn-ghost">Cancel</button></div>
  `;
  showModal(html);
  document.getElementById('cancelLessonBtn').onclick = closeModal;
  document.getElementById('saveLessonBtn').onclick = async ()=> {
  const tEn = document.getElementById('lsTitleEn').value.trim();
  const tSom = document.getElementById('lsTitleSom').value.trim();
  // DO NOT trim content here - preserve newlines inside
  const cEn = document.getElementById('lsContentEn').value;
  const cSom = document.getElementById('lsContentSom').value;
  if (!tEn) return alert('English title required');
  const payload = { title: { en: tEn }, content: { en: cEn } };
  if (tSom) payload.title.som = tSom;
  if (cSom) payload.content.som = cSom;
  const r = await fetchJson('/api/lessons/'+lessonId, { method:'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
  if (!r.ok) return alert('Save failed: '+(r.error||''));
  closeModal();
  await loadTree();
};

}

/* ===================== LESSON FULL VIEW ===================== */
async function viewLesson(id){
  if (!getToken()) return requireLoginModal('Please log in to view this lesson.');

  // 1) Load lesson
  const r = await fetchJson('/api/lessons/' + encodeURIComponent(id), { headers: authHeaders(), method: 'GET' });
  if (!r.ok) {
    if (r.status === 401 || r.status === 403) return requireLoginModal('You must be logged in (and authorized) to view this lesson.');
    return alert('Failed to load lesson: ' + (r.error || 'Server error'));
  }
  const lesson = r.data.lesson;

  // 2) Ensure we have the current user's favorites so favorite button state persists after refresh.
  // Try both possible endpoints (some setups have users route under /api/lessons/users/me)
  window.userFavorites = window.userFavorites || [];
  try {
    let ru = await fetchJson('/api/lessons/users/me', { headers: authHeaders(), method: 'GET' });
    if (!ru.ok) {
      // fallback to canonical users endpoint if available
      ru = await fetchJson('/api/users/me', { headers: authHeaders(), method: 'GET' });
    }
    if (ru.ok && ru.data && ru.data.user) {
      window.userFavorites = Array.isArray(ru.data.user.favorites) ? ru.data.user.favorites.map(String) : [];
    }
  } catch (e) {
    // ignore - we'll keep window.userFavorites as-is (at least an empty array)
    window.userFavorites = window.userFavorites || [];
  }

  // 3) Render UI immediately (fast)
  renderLessonView(lesson);

  // 4) Then POST a view increment (server will dedupe per-user when possible)
  // If the endpoint supports optional auth, it will count uniquely for logged-in users.
  try {
    const rv = await fetchJson('/api/lessons/' + encodeURIComponent(id) + '/view', { method: 'POST', headers: authHeaders() });
    if (rv && rv.ok && rv.data && rv.data.viewsCount !== undefined) {
      const el = document.getElementById('lessonViewsCount');
      if (el) el.innerText = String(rv.data.viewsCount);
    } else if (rv && rv.ok && rv.viewsCount !== undefined) {
      // in case server response shape differs slightly
      const el = document.getElementById('lessonViewsCount');
      if (el) el.innerText = String(rv.viewsCount);
    }
  } catch (e) {
    console.warn('view increment failed', e);
  }
}

/* NOTE: renderLessonView expects:
   - helpers: tLocalized, escapeHtml, authHeaders, getToken, isAdmin, openTakeTest, openEditLessonModal, openAddTestModal, openLessonQuestionsModal, closeModal, loadTree, goHome
   - global DOM elements: breadcrumbsEl, contentArea, pageTitleEl, rightHeaderEl (we avoid double title set)
*/
function renderLessonView(lesson){
  const lessonTitle = tLocalized(lesson.title) || (lesson.title && lesson.title.en) || 'Lesson';

  // breadcrumbs (clickable)
  breadcrumbsEl.innerHTML = '';
  const parts = [{ label:'Home', id: null }, ...pathStack.map(p => ({ label: tLocalized(p.name) || (typeof p.name === 'string' ? p.name : ''), id: p._id })), { label: lessonTitle, id: 'lesson:' + lesson._id }];
  parts.forEach((p,i) => {
    const a = document.createElement('a');
    a.innerText = p.label || 'Home';
    a.href = 'javascript:void(0)';
    a.onclick = async () => {
      if (!p.id) { currentFolderId = null; pathStack = []; await loadTree(); return; }
      if (String(p.id).startsWith('lesson:')) return; // already on lesson
      currentFolderId = p.id;
      await loadTree();
    };
    breadcrumbsEl.appendChild(a);
    if (i < parts.length - 1) breadcrumbsEl.appendChild(document.createTextNode(' / '));
  });

  // content: preserve newlines safely (escape HTML)
  const rawContent = (getLang() === 'som' ? (lesson.content && lesson.content.som) : (lesson.content && lesson.content.en)) || (lesson.content && lesson.content.en) || '';
  const safeContent = escapeHtml(rawContent).replace(/\n/g, '<br>');

  // admin actions HTML (if admin)
  const adminActions = isAdmin() ? `
    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="editLessonBtn" class="small-btn">Edit</button>
      <button id="deleteLessonBtn" class="small-btn">Delete</button>
      <button id="addTestToLesson" class="small-btn">Add Test</button>
      <button id="viewQuestionsBtn" class="small-btn">Questions</button>
    </div>` : '';

  // favorite button class determined from window.userFavorites
  window.userFavorites = window.userFavorites || [];
  const favOn = Array.isArray(window.userFavorites) && window.userFavorites.map(String).includes(String(lesson._id));
  const favClass = favOn ? 'fav-on' : 'fav-off';
  const favLabel = favOn ? '‚òÖ Favorited' : '‚òÜ Favorite';

  // render
  contentArea.innerHTML = `
    <div class="lesson-view">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
        <div style="flex:1">
          <h1 style="margin:0">${escapeHtml(lessonTitle)}</h1>
          <div class="muted-note" style="margin-top:6px">
            By: ${escapeHtml((lesson.author && lesson.author.fullName) ? lesson.author.fullName : (lesson.authorId ? String(lesson.authorId) : '‚Äî'))}
            ¬∑ ${lesson.createdAt ? new Date(lesson.createdAt).toLocaleString() : ''}
            ¬∑ Views: <span id="lessonViewsCount">${lesson.viewsCount != null ? String(lesson.viewsCount) : (Array.isArray(lesson.viewers) ? String(lesson.viewers.length) : '‚Äî')}</span>
          </div>
        </div>
        <div style="margin-left:12px;display:flex;flex-direction:column;gap:6px;align-items:flex-end">
          <button id="backToFolder" class="btn-ghost">Back</button>
          <button id="favoriteLessonBtn" class="small-btn ${favClass}" title="Toggle favorite" aria-pressed="${favOn}">${favLabel}</button>
        </div>
      </div>

      <div class="lesson-content" style="margin-top:12px;white-space:pre-wrap">${safeContent}</div>

      <div style="margin-top:12px">
        <button id="takeLessonTest" class="small-btn">Take Lesson Test</button>
      </div>

      ${adminActions}
    </div>
  `;

  // Back button
  document.getElementById('backToFolder').onclick = ()=> { if (!currentFolderId) goHome(); else loadTree(); };

  // Take test button
  document.getElementById('takeLessonTest').onclick = ()=> { if (!getToken()) return requireLoginModal('Log in to take tests.'); openTakeTest(null, lesson._id); };

  // Admin wiring
  if (isAdmin()){
    document.getElementById('editLessonBtn').onclick = ()=> openEditLessonModal(lesson._id);
    document.getElementById('deleteLessonBtn').onclick = async ()=> {
      if (!confirm('Delete this lesson?')) return;
      const r = await fetchJson('/api/lessons/' + encodeURIComponent(lesson._id), { method: 'DELETE', headers: authHeaders() });
      if (!r.ok) return alert('Delete failed: '+(r.error||''));
      alert('Deleted');
      if (currentFolderId) loadTree(); else goHome();
    };
    document.getElementById('addTestToLesson').onclick = ()=> openAddTestModal(currentFolderId, lesson._id);
    document.getElementById('viewQuestionsBtn').onclick = ()=> openLessonQuestionsModal(lesson._id);
  }

  // helper: extract favorites array out of many response shapes
  function extractFavsFromResp(obj) {
    if (!obj) return null;
    if (Array.isArray(obj.favorites)) return obj.favorites.map(String);
    if (obj.data && Array.isArray(obj.data.favorites)) return obj.data.favorites.map(String);
    if (obj.data && obj.data.user && Array.isArray(obj.data.user.favorites)) return obj.data.user.favorites.map(String);
    if (obj.user && Array.isArray(obj.user.favorites)) return obj.user.favorites.map(String);
    return null;
  }

  // Favorite toggle wiring (works for POST and DELETE endpoints)
  const favBtn = document.getElementById('favoriteLessonBtn');
  if (favBtn) {
    favBtn.onclick = async () => {
      if (!getToken()) return requireLoginModal('Log in to favorite lessons.');
      favBtn.disabled = true;
      try {
        const currentlyFav = (window.userFavorites || []).map(String).includes(String(lesson._id));
        // send request (POST=add, DELETE=remove)
        let r;
        if (currentlyFav) {
          r = await fetchJson('/api/lessons/' + encodeURIComponent(lesson._id) + '/favorite', { method: 'DELETE', headers: authHeaders() });
        } else {
          r = await fetchJson('/api/lessons/' + encodeURIComponent(lesson._id) + '/favorite', { method: 'POST', headers: authHeaders() });
        }

        // LOG response for debug (helps see exactly what backend returned)
        console.log('favorite toggle response for lesson', lesson._id, r);

        if (!r || !r.ok) {
          const errMsg = (r && r.error) ? r.error : 'Server error';
          favBtn.disabled = false;
          return alert('Failed to toggle favorite: ' + errMsg);
        }

        // Prefer server authoritative result:
        // 1) If response included favorites, use it.
        // 2) Otherwise, re-sync from server (guaranteed authoritative).
        let favsFromResp = extractFavsFromResp(r) || extractFavsFromResp(r.data) || extractFavsFromResp(r.user);
        if (favsFromResp) {
          window.userFavorites = favsFromResp;
        } else {
          // Force a fresh authoritative sync (this will fetch /api/lessons/users/me or /api/users/me)
          await syncFavoritesFromServer(r);
        }

        // persist to localStorage (useful on refresh/back)
        try { localStorage.setItem('userFavorites', JSON.stringify(window.userFavorites || [])); } catch(e){ console.warn('persist favs failed', e); }

        // update the lesson favorite button UI according to new state
        const nowFav = (window.userFavorites || []).map(String).includes(String(lesson._id));
        if (nowFav) {
          favBtn.classList.remove('fav-off'); favBtn.classList.add('fav-on');
          favBtn.innerText = '‚òÖ Favorited';
          favBtn.setAttribute('aria-pressed', 'true');
        } else {
          favBtn.classList.remove('fav-on'); favBtn.classList.add('fav-off');
          favBtn.innerText = '‚òÜ Favorite';
          favBtn.setAttribute('aria-pressed', 'false');
        }

        // refresh tree/folder views so icons and header reflect favorite state
        await loadTree();

        // If a Favorites modal is open, refresh it quickly by closing + reopening (optional UX)
        // (detect by DOM presence of favorites modal elements if you have a modal id)
        // For simplicity, we'll not auto-reopen modal. User can re-open Favorites to verify.

      } catch (e) {
        console.warn('favorite toggle failed', e);
        alert('Favorite action failed');
      } finally {
        favBtn.disabled = false;
      }
    };
  }
}



/* ============================
   STREAK STORAGE + UI HELPERS (fixed)
   ============================ */

// key helper (unchanged)
function testStreakKey(testId){ return 'testBestStreak:' + String(testId); }

// load best streak record (tries server if logged-in; otherwise localStorage)
async function loadBestStreak(testId){
  try {
    if (!testId) return { streak: 0, name: null };

    // local-only key handling
    if (String(testId).startsWith('yourBest:')) {
      const rawLocal = localStorage.getItem(testId);
      if (!rawLocal) return { streak: 0, name: null };
      try {
        const parsed = JSON.parse(rawLocal);
        return { streak: Number(parsed.streak || 0), name: parsed.name || null };
      } catch(e) {
        return { streak: 0, name: null };
      }
    }

    // Try server when logged in (optionalAuthenticate on server allows guests)
    if (typeof getToken === 'function' && getToken()) {
      try {
        const r = await fetchJson(`/api/tests/${encodeURIComponent(testId)}/streak`, { method:'GET', headers: authHeaders() });
        if (r && r.ok && r.data) {
          // server returns { ok:true, serverBest, personalBest }
          const serverBest = r.data.serverBest || (r.data.serverBest === 0 ? r.data.serverBest : null);
          const personalBest = r.data.personalBest || null;
          if (serverBest) {
            try {
              localStorage.setItem(testStreakKey(testId), JSON.stringify({ streak: serverBest.streak || 0, name: serverBest.name || null, updatedAt: serverBest.updatedAt || null }));
            } catch(e){}
          }
          if (personalBest) {
            try { localStorage.setItem('yourBest:' + testId, JSON.stringify({ streak: personalBest.streak || 0, updatedAt: personalBest.updatedAt || null })); } catch(e){}
          }
          if (serverBest) return { streak: Number(serverBest.streak || 0), name: serverBest.name || null };
        }
      } catch (e) {
        console.warn('streak GET failed', e);
      }
    }

    // fallback to localStorage
    const raw = localStorage.getItem(testStreakKey(testId));
    if (!raw) return { streak: 0, name: null };
    const parsed = JSON.parse(raw);
    return { streak: Number(parsed.streak||0), name: parsed.name || null };
  } catch (e) {
    console.warn('loadBestStreak error', e);
    return { streak: 0, name: null };
  }
}

// save best streak record (will attempt server update if logged-in; always update localStorage)
async function saveBestStreak(testId, streak, name){
  try {
    const record = { streak: Number(streak||0), name: name || null, updatedAt: new Date().toISOString() };
    // update local copy (fast)
    try { localStorage.setItem(testStreakKey(testId), JSON.stringify(record)); } catch(e){}

    // if logged in, send to server (await result to get server's authoritative returned object)
    if (typeof getToken === 'function' && getToken()) {
      try {
        const resp = await fetchJson(`/api/tests/${encodeURIComponent(testId)}/streak`, { method:'POST', headers: authHeaders(), body: JSON.stringify({ streak }) });
        if (resp && resp.ok && resp.data) {
          // server returns updatedTest and/or personalBest inside resp.data
          if (resp.data.updatedTest) {
            const upd = resp.data.updatedTest;
            const serverRec = { streak: Number(upd.streak||0), name: upd.name || name || null, updatedAt: upd.updatedAt || new Date().toISOString() };
            try { localStorage.setItem(testStreakKey(testId), JSON.stringify(serverRec)); } catch(e){}
            return serverRec;
          }
          if (resp.data.personalBest) {
            try { localStorage.setItem('yourBest:' + testId, JSON.stringify({ streak: Number(resp.data.personalBest.streak||0), updatedAt: resp.data.personalBest.updatedAt || new Date().toISOString() })); } catch(e){}
            return record;
          }
          return record;
        } else {
          console.warn('streak POST not ok', resp && resp.error);
          return record;
        }
      } catch (e) {
        console.warn('streak POST failed', e);
        return record;
      }
    } else {
      // not logged in ‚Äî keep local record only
      return record;
    }
  } catch (e) {
    console.warn('saveBestStreak error', e);
    return { streak: Number(streak||0), name: name || null };
  }
}

/* ------------------- Modal helpers (robust) ------------------- */

// Attempt to close modal using known functions, otherwise remove typical overlays
function safeCloseModal() {
  try {
    if (typeof closeModal === 'function') { closeModal(); return; }
    // try common overlay classes
    const selectors = ['.admin-modal-overlay', '.modal-overlay', '.modal', '.overlay'];
    for (const s of selectors) {
      const el = document.querySelector(s);
      if (el) { el.remove(); /* stop at first found */ return; }
    }
    // fallback: remove any element with role dialog
    const dlg = document.querySelector('[role="dialog"]');
    if (dlg && dlg.parentNode) dlg.parentNode.removeChild(dlg);
  } catch(e){
    console.warn('safeCloseModal failed', e);
  }
}

// show modal compat: prefer renderIntoModal() / showModal(), but return a reference if we created one
function safeShowModal(html) {
  try {
    if (typeof renderIntoModal === 'function') { renderIntoModal(html); return { created:false }; }
    if (typeof showModal === 'function') { showModal(html); return { created:false }; }
  } catch(e){}
  // fallback: create a simple overlay modal we can always close
  const overlay = document.createElement('div');
  overlay.className = 'admin-modal-overlay';
  Object.assign(overlay.style, { position:'fixed', inset:0, display:'flex', alignItems:'center', justifyContent:'center', background:'rgba(0,0,0,0.35)', zIndex:9999 });
  const box = document.createElement('div');
  Object.assign(box.style, { width:'760px', maxWidth:'94vw', background:'#fff', borderRadius:'10px', padding:'14px', boxShadow:'0 24px 60px rgba(2,6,23,0.14)' });
  box.innerHTML = html;
  overlay.appendChild(box);
  document.body.appendChild(overlay);
  overlay.addEventListener('click', (e)=> { if (e.target === overlay) overlay.remove(); });
  return { created:true, overlay, box };
}



// choose streak color based on value (returns inline-style CSS string for color and optional glow)
function streakColorStyle(n){
  n = Number(n||0);
  if (n <= 0) return 'background:#f1f1f1;color:#444;border:1px solid #ddd';
  if (n === 1) return 'background:#2ecc71;color:#fff;border:1px solid #2ecc71'; // bright green
  if (n === 2) return 'background:#7fe3a6;color:#023;color:#fff;border:1px solid #7fe3a6'; // light green (slightly different)
  if (n >=3 && n <=8) return 'background:#ffd37d;color:#3b2e00;border:1px solid #ffc857'; // amber
  if (n >=9 && n < 20) return 'background:#ff6b6b;color:#fff;border:1px solid #ff4b4b'; // red-ish
  // n >= 20 => strong glow red
  return 'background:linear-gradient(90deg,#ff3b3b,#ff6b6b);color:#fff;border:1px solid #ff1a1a;box-shadow:0 6px 18px rgba(255,26,26,0.28)';
}

// helper to render streak badge HTML
function streakBadgeHtml(prefix, n){
  const style = streakColorStyle(n);
  return `<span class="streak-badge" style="display:inline-block;padding:6px 10px;border-radius:20px;font-weight:700;margin-left:8px;${style}">${escapeHtml('x' + n)}</span>`;
}

/* ============================
   MODERN SYNTH SOUNDS (WebAudio)
   - pleasant ascending melody for correct
   - muted descending buzz for incorrect
   - soft ping for warning
   ============================ */

function playModernSound(kind){
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const now = ctx.currentTime;

    if (kind === 'correct') {
      // two short ascending notes
      const freqs = [880, 1100];
      freqs.forEach((f, i) => {
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'triangle';
        o.frequency.setValueAtTime(f, now + i*0.09);
        g.gain.setValueAtTime(0, now + i*0.09);
        g.gain.linearRampToValueAtTime(0.12, now + i*0.09 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + i*0.09 + 0.26);
        o.connect(g); g.connect(ctx.destination);
        o.start(now + i*0.09); o.stop(now + i*0.09 + 0.28);
      });
      return;
    }

    if (kind === 'incorrect') {
      // two descending muted notes (soft)
      const freqs = [240, 200];
      freqs.forEach((f, i) => {
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(f, now + i*0.08);
        g.gain.setValueAtTime(0, now + i*0.08);
        g.gain.linearRampToValueAtTime(0.09, now + i*0.08 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + i*0.08 + 0.22);
        o.connect(g); g.connect(ctx.destination);
        o.start(now + i*0.08); o.stop(now + i*0.08 + 0.22);
      });
      return;
    }

    if (kind === 'warning') {
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine'; o.frequency.value = 660;
      g.gain.value = 0.06;
      o.connect(g); g.connect(ctx.destination);
      o.start(now); o.stop(now + 0.12);
      return;
    }
  } catch(e){
    // fallback silent
    console.warn('sound failed', e);
  }
}


  /* ---------------------------
   Helper: safeText(t) - normalize explanation/question text
   --------------------------- */
   function safeText(t) {
  // If t is object like { en:'', som:'' } prefer en, else stringify safely
  if (!t && t !== '') return '';
  if (typeof t === 'string') return t;
  if (typeof t === 'object') {
    if (t.en && typeof t.en === 'string') return t.en;
    if (t.som && typeof t.som === 'string') return t.som;
    // fallback: try toString
    try { return String(t); } catch(e) { return ''; }
  }
  return String(t);
}

/* ===================== QUESTIONS UI for a Lesson (ADMIN) ===================== */

async function openLessonQuestionsModal(lessonId){
  if (!getToken()) return requireLoginModal('Please log in as an admin to manage questions.');
  if (!isAdmin()) return alert('Only admins may manage questions.');

  const r = await fetchJson('/api/tests?lessonId=' + encodeURIComponent(lessonId), { headers: authHeaders(), method:'GET' });
  if (!r || !r.ok) return alert('Failed to load tests: ' + (r && r.error ? r.error : ''));

  const tests = Array.isArray(r.data) ? r.data : (Array.isArray(r.data.tests) ? r.data.tests : (r.data || []));

  // --- NORMALIZE: produce a consistent shape for every question/option
  function normalizeQuestion(q){
    const toTextObj = (v) => {
      if (!v && v !== '') return { en:'', som:'' };
      if (typeof v === 'string') return { en: v, som: '' };
      if (typeof v === 'object') return { en: String(v.en || ''), som: String(v.som || '') };
      return { en: String(v), som: '' };
    };
    return {
      id: q.id || q._id || null,
      text: toTextObj(q.text || q.question || q.textObj || q.questionText),
      explanation: toTextObj(q.explanation || q.expl || q.explanationObj || ''),
      options: (q.options || []).map(o => ({
        id: o.id || o._id || null,
        text: toTextObj(o.text || o.textObj || ''),
        isCorrect: !!o.isCorrect
      })),
      pointsValue: q.pointsValue || 3
    };
  }

  const normalized = tests.map(t => ({
    id: t._id || t.id,
    title: t.title || '',
    questions: (t.questions || []).map(normalizeQuestion)
  }));

  function render(){
    let html = `<h3>Questions for Lesson</h3>`;
    if (!normalized.length) html += `<div class="muted-note">No tests found for this lesson. Use "Add Question" to create a new test and question.</div>`;
    html += `<div style="max-height:55vh;overflow:auto">`;
    normalized.forEach((t,ti) => {
      html += `<div style="padding:8px;border:1px solid #eee;margin-bottom:8px;border-radius:8px">
                <div style="display:flex;justify-content:space-between;align-items:center">
                  <div><strong>${escapeHtml(t.title || ('Test #' + (ti+1)))}</strong><div class="muted-note">${t.questions.length} questions</div></div>
                  <div style="display:flex;gap:6px">
                    <button class="small-btn edit-test-btn" data-id="${escapeHtml(t.id)}">Edit Test</button>
                    <button class="small-btn del-test-btn" data-id="${escapeHtml(t.id)}">Delete Test</button>
                  </div>
                </div>
                <div style="margin-top:8px">`;
      t.questions.forEach((q,qi) => {
        html += `<div style="padding:8px;border:1px solid #f3f4f6;border-radius:8px;margin-bottom:6px">
                  <div style="font-weight:700; white-space:pre-wrap">Q${qi+1}: ${escapeHtml(q.text.en || '')}</div>
                  <div style="margin-top:6px">${q.options.map((o,oi)=>`<div>${oi+1}. ${escapeHtml(o.text.en||'')} ${o.isCorrect?'<strong>(correct)</strong>':''}</div>`).join('')}</div>
                  <div style="margin-top:6px"><em>${escapeHtml(q.explanation.en||'')}</em></div>
                  <div style="margin-top:6px"><button class="small-btn edit-q" data-test="${escapeHtml(t.id)}" data-idx="${qi}">Edit</button> <button class="small-btn del-q" data-test="${escapeHtml(t.id)}" data-idx="${qi}">Delete</button></div>
                </div>`;
      });
      html += `</div></div>`;
    });
    html += `</div>`;
    html += `<div style="display:flex;gap:8px;margin-top:12px"><button id="addQuestionBtn" class="small-btn">+ Add Question</button> <button id="closeQuestions" class="btn-ghost">Close</button></div>`;
    showModal(html);

    document.getElementById('closeQuestions').onclick = closeModal;
    document.getElementById('addQuestionBtn').onclick = () => addQuestionFlow();

    document.querySelectorAll('.edit-test-btn').forEach(b => b.onclick = (ev) => { ev.stopPropagation(); openEditTestModal(b.dataset.id); });
    document.querySelectorAll('.del-test-btn').forEach(b => b.onclick = async (ev) => {
      ev.stopPropagation();
      if (!confirm('Delete whole test? This cannot be undone.')) return;
      const id = b.dataset.id;
      const rr = await fetchJson('/api/tests/' + encodeURIComponent(id), { method:'DELETE', headers: authHeaders() });
      if (!rr.ok) return alert('Delete failed: ' + (rr.error||''));
      const idx = normalized.findIndex(x => String(x.id) === String(id));
      if (idx >= 0) normalized.splice(idx,1);
      render();
    });

    document.querySelectorAll('.edit-q').forEach(b => b.onclick = (ev) => { ev.stopPropagation(); openEditQuestionModal(b.dataset.test, +b.dataset.idx); });
    document.querySelectorAll('.del-q').forEach(b => b.onclick = (ev) => { ev.stopPropagation(); deleteQuestionFlow(b.dataset.test, +b.dataset.idx); });
  }

  // Modal-based add question (consistent normalized shape)
  async function addQuestionFlow(){
    const html = `
      <h4>New Question</h4>
      <label>Question (English)</label><textarea id="newQTextEn" rows="4" placeholder="Type question text (English) ‚Äî Enter for newline"></textarea>
      <label>Question (Somali) ‚Äî optional</label><textarea id="newQTextSom" rows="3" placeholder="Somali (optional)"></textarea>
      <label>Explanation (English - shown when correct selected)</label><textarea id="newQExplEn" rows="3" placeholder="Short explanation"></textarea>
      <div id="newOptsWrap" style="margin-top:8px"></div>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="addNewOptBtn" class="small-btn">+ Option</button>
        <button id="saveNewQBtn" class="small-btn">Save Question</button>
        <button id="cancelNewQBtn" class="btn-ghost">Cancel</button>
      </div>
      <p class="muted-note">Enter newline in textareas to get multiple lines. Mark the correct option checkbox.</p>
    `;
    showModal(html);

    const opts = [{ id:null, text:{en:'',som:''}, isCorrect:false }, { id:null, text:{en:'',som:''}, isCorrect:false }];

    function renderNewOpts(){
      const wr = document.getElementById('newOptsWrap');
      wr.innerHTML = '';
      opts.forEach((o,i) => {
        const div = document.createElement('div');
        div.style.display='flex'; div.style.alignItems='center'; div.style.gap='8px'; div.style.marginBottom='6px';
        div.innerHTML = `
          <input type="checkbox" class="opt-correct-new" data-i="${i}" ${o.isCorrect ? 'checked' : ''} title="Mark as correct">
          <input type="text" class="opt-text-en-new" data-i="${i}" value="${escapeHtml(o.text.en||'')}" placeholder="Option English">
          <input type="text" class="opt-text-som-new" data-i="${i}" value="${escapeHtml(o.text.som||'')}" placeholder="Option Somali (optional)">
          <button class="small-btn del-opt-new" data-i="${i}">Del</button>
        `;
        wr.appendChild(div);
      });
      wr.querySelectorAll('.opt-correct-new').forEach(ch => ch.onchange = e => opts[+e.target.dataset.i].isCorrect = e.target.checked);
      wr.querySelectorAll('.opt-text-en-new').forEach(inp => inp.oninput = e => opts[+e.target.dataset.i].text.en = e.target.value);
      wr.querySelectorAll('.opt-text-som-new').forEach(inp => inp.oninput = e => opts[+e.target.dataset.i].text.som = e.target.value);
      wr.querySelectorAll('.del-opt-new').forEach(b => b.onclick = e => { opts.splice(+e.target.dataset.i,1); renderNewOpts(); });
    }
    renderNewOpts();

    document.getElementById('addNewOptBtn').onclick = () => { opts.push({ id:null, text:{en:'',som:''}, isCorrect:false }); renderNewOpts(); };
    document.getElementById('cancelNewQBtn').onclick = () => { closeModal(); openLessonQuestionsModal(lessonId); };
    document.getElementById('saveNewQBtn').onclick = async () => {
      const qTextEn = (document.getElementById('newQTextEn').value || '').trim();
      const qTextSom = (document.getElementById('newQTextSom').value || '').trim();
      const qExplEn = (document.getElementById('newQExplEn').value || '').trim();
      if (!qTextEn) return alert('Question English text required');
      if (opts.filter(o=>o.text && o.text.en && o.text.en.trim()).length < 2) return alert('At least two options with English text required');

      // build normalized question object
      const qNormalized = {
        id: 'q_' + Math.random().toString(36).slice(2,8),
        text: { en: String(qTextEn), som: String(qTextSom || '') },
        explanation: { en: String(qExplEn || ''), som: '' },
        options: opts.map(o => ({ id: o.id || ('o_' + Math.random().toString(36).slice(2,8)), text: { en: String(o.text.en || ''), som: String(o.text.som || '') }, isCorrect: !!o.isCorrect })),
        pointsValue: 3
      };

      // append to first test or create new - IMPORTANT: operate on normalized shape and send consistent payload
      if (normalized.length > 0) {
        const t = normalized[0];
        t.questions.push(qNormalized);
        const payload = {
          questions: t.questions.map(q=>({
            id: q.id,
            text: { en: String(q.text.en || ''), som: String(q.text.som || '') },
            explanation: { en: String(q.explanation.en || ''), som: String(q.explanation.som || '') },
            options: q.options.map(o => ({ id: o.id, text: { en: String(o.text.en || ''), som: String(o.text.som || '') }, isCorrect: !!o.isCorrect })),
            pointsValue: q.pointsValue || 3
          }))
        };
        const rr = await fetchJson('/api/tests/' + encodeURIComponent(t.id), { method:'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
        if (!rr.ok) return alert('Save failed: ' + (rr.error||''));
        closeModal(); openLessonQuestionsModal(lessonId);
      } else {
        const payload = {
          title:'Lesson questions (auto)',
          folderId: currentFolderId || null,
          lessonId: lessonId,
          questions: [qNormalized].map(q=>({
            id: q.id,
            text: { en: String(q.text.en || ''), som: String(q.text.som || '') },
            explanation: { en: String(q.explanation.en || ''), som: String(q.explanation.som || '') },
            options: q.options.map(o => ({ id: o.id, text: { en: String(o.text.en || ''), som: String(o.text.som || '') }, isCorrect: !!o.isCorrect })),
            pointsValue: q.pointsValue || 3
          }))
        };
        const rr = await fetchJson('/api/tests', { method:'POST', headers: authHeaders(), body: JSON.stringify(payload) });
        if (!rr.ok) return alert('Create test failed: ' + (rr.error||''));
        closeModal(); openLessonQuestionsModal(lessonId);
      }
    };
  }

  // Edit single question modal (keeps multiline textareas)
  async function openEditQuestionModal(testId, qIndex){
    const rtest = await fetchJson('/api/tests/' + encodeURIComponent(testId), { headers: authHeaders(), method:'GET' });
    if (!rtest || !rtest.ok) return alert('Failed to load test: ' + (rtest && rtest.error ? rtest.error : ''));
    const test = rtest.data.test || rtest.data;
    const qRaw = test.questions[qIndex];
    if (!qRaw) return alert('Question not found');

    const q = normalizeQuestion(qRaw); // reuse same normalization

    const qTextEn = safeText(q.text.en || '');
    const qTextSom = safeText(q.text.som || '');
    const qExplEn = safeText(q.explanation.en || '');
    const opts = q.options.map(o => ({ id: o.id || null, text: { en: safeText(o.text.en || ''), som: safeText(o.text.som || '') }, isCorrect: !!o.isCorrect }));

    let html = `<h4>Edit Question</h4>
      <label>Question (English)</label><textarea id="editQText" rows="4">${escapeHtml(qTextEn)}</textarea>
      <label>Question (Somali)</label><textarea id="editQTextSom" rows="3">${escapeHtml(qTextSom)}</textarea>
      <label>Explanation (English)</label><textarea id="editQExpl" rows="3">${escapeHtml(qExplEn)}</textarea>
      <div id="editOpts" style="margin-top:8px"></div>
      <div style="display:flex;gap:8px;margin-top:10px"><button id="addOptBtn" class="small-btn">+ Option</button><button id="saveQBtn" class="small-btn">Save</button><button id="cancelQBtn" class="btn-ghost">Cancel</button></div>
    `;
    showModal(html);

    function renderOpts(){
      const wrap = document.getElementById('editOpts');
      wrap.innerHTML = '';
      opts.forEach((o,i) => {
        const div = document.createElement('div');
        div.style.display='flex'; div.style.alignItems='center'; div.style.gap='8px'; div.style.marginBottom='6px';
        div.innerHTML = `
          <input type="checkbox" class="opt-correct" data-i="${i}" ${o.isCorrect ? 'checked' : ''}>
          <input type="text" class="opt-text-en" data-i="${i}" value="${escapeHtml(o.text.en||'')}" placeholder="Option English">
          <input type="text" class="opt-text-som" data-i="${i}" value="${escapeHtml(o.text.som||'')}" placeholder="Option Somali (optional)">
          <button class="small-btn del-opt" data-i="${i}">Del</button>
        `;
        wrap.appendChild(div);
      });
      wrap.querySelectorAll('.opt-correct').forEach(ch => ch.onchange = (e)=> { opts[+e.target.dataset.i].isCorrect = e.target.checked; });
      wrap.querySelectorAll('.opt-text-en').forEach(inp => inp.oninput = (e)=> { opts[+e.target.dataset.i].text.en = e.target.value; });
      wrap.querySelectorAll('.opt-text-som').forEach(inp => inp.oninput = (e)=> { opts[+e.target.dataset.i].text.som = e.target.value; });
      wrap.querySelectorAll('.del-opt').forEach(b => b.onclick = (e)=> { opts.splice(+e.target.dataset.i,1); renderOpts(); });
    }
    renderOpts();

    document.getElementById('addOptBtn').onclick = ()=> { opts.push({ id:null, text:{en:'',som:''}, isCorrect:false }); renderOpts(); };
    document.getElementById('cancelQBtn').onclick = ()=> { closeModal(); openLessonQuestionsModal(lessonId); };
    document.getElementById('saveQBtn').onclick = async () => {
      const textNew = (document.getElementById('editQText').value || '').trim();
      const textSomNew = (document.getElementById('editQTextSom').value || '').trim();
      const explEnNew = (document.getElementById('editQExpl').value || '').trim();
      if (!textNew) return alert('Question text required');
      if (opts.filter(o=>o.text && o.text.en && o.text.en.trim()).length < 2) return alert('At least two options required');

      // Replace that question in server-shaped structure
      const newQ = {
        id: q.id || ('q_' + Math.random().toString(36).slice(2,8)),
        text: { en: String(textNew), som: String(textSomNew || '') },
        explanation: { en: String(explEnNew || ''), som: '' },
        options: opts.map(o => ({ id: o.id || ('o_' + Math.random().toString(36).slice(2,8)), text: { en: String(o.text.en||''), som: String(o.text.som||'') }, isCorrect: !!o.isCorrect })),
        pointsValue: q.pointsValue || 3
      };

      // fetch fresh test, replace question, PUT back
      const fresh = await fetchJson('/api/tests/' + encodeURIComponent(testId), { headers: authHeaders(), method: 'GET' });
      if (!fresh || !fresh.ok) return alert('Failed to load test before save');
      const testObj = fresh.data.test || fresh.data;
      if (!testObj || !Array.isArray(testObj.questions)) return alert('Malformed test data');
      testObj.questions[qIndex] = newQ;
      const payload = { questions: testObj.questions.map(q=>({ id:q.id, text:q.text, explanation:q.explanation, options:q.options, pointsValue:q.pointsValue||3 })) };
      const rr = await fetchJson('/api/tests/' + encodeURIComponent(testId), { method:'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
      if (!rr.ok) return alert('Save failed: ' + (rr.error||''));
      closeModal();
      openLessonQuestionsModal(lessonId);
    };
  }

  async function deleteQuestionFlow(testId, qIndex){
    if (!confirm('Delete this question?')) return;
    const rtest = await fetchJson('/api/tests/' + encodeURIComponent(testId), { headers: authHeaders(), method:'GET' });
    if (!rtest || !rtest.ok) return alert('Failed to load test: ' + (rtest && rtest.error ? rtest.error : ''));
    const test = rtest.data.test || rtest.data;
    if (!test) return alert('Test not found');
    if ((test.questions || []).length <= 1) {
      const rr = await fetchJson('/api/tests/' + encodeURIComponent(testId), { method:'DELETE', headers: authHeaders() });
      if (!rr.ok) return alert('Delete failed: ' + (rr.error||''));
      openLessonQuestionsModal(lessonId);
      return;
    }
    test.questions.splice(qIndex,1);
    const payload = { questions: test.questions.map(q => ({ id: q.id || q._id, text: q.text, explanation: q.explanation, options: q.options, pointsValue: q.pointsValue||3 })) };
    const rr = await fetchJson('/api/tests/' + encodeURIComponent(testId), { method:'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
    if (!rr.ok) return alert('Update failed: ' + (rr.error||''));
    openLessonQuestionsModal(lessonId);
  }

  render();
}

// DROP-IN REPLACEMENT: openAddTestModal (complete)
function openAddTestModal(folderId = null, lessonId = null) {
  if (!getToken()) return requireLoginModal('Please log in to add a test.');
  if (!isAdmin()) return alert('Only admins may create tests.');

  // Local store for new test being built
  const questions = [];

  // Helper: ensure question shape is consistent
  function normalizeLocalQuestion(q) {
    // Accept q possibly from server (string text or object)
    const safeText = (v) => {
      if (!v && v !== '') return '';
      if (typeof v === 'string') return v;
      if (typeof v === 'object') return String(v.en || v.som || '');
      return String(v);
    };
    return {
      id: q.id || null,
      text: { en: safeText(q.text && q.text.en !== undefined ? q.text.en : (typeof q.text === 'string' ? q.text : (q.text && q.text.en) || '')), som: safeText(q.text && q.text.som !== undefined ? q.text.som : (q.text && q.text.som) || '') },
      options: (q.options || []).map((o, oi) => ({
        id: o.id || null,
        text: { en: safeText(o.text && (o.text.en !== undefined ? o.text.en : (typeof o.text === 'string' ? o.text : (o.text && o.text.en) || ''))), som: safeText(o.text && (o.text.som !== undefined ? o.text.som : (o.text && o.text.som) || '')) },
        isCorrect: !!o.isCorrect
      })),
      pointsValue: q.pointsValue || 3
    };
  }

  // Render question list preview inside modal (uses tLocalized so Somali shows when chosen)
  function renderQuestionsList(container) {
    container.innerHTML = '';
    questions.forEach((q, idx) => {
      const div = document.createElement('div');
      div.style.border = '1px solid #eee';
      div.style.padding = '8px';
      div.style.borderRadius = '8px';
      div.style.marginBottom = '8px';

      const qtext = tLocalized(q.text);
      const optsHtml = q.options.map((o, i) => {
        const txt = tLocalized(o.text);
        return `<div>${i+1}. ${escapeHtml(txt || '')} ${o.isCorrect ? '<strong>(correct)</strong>' : ''}</div>`;
      }).join('');

      div.innerHTML = `<div style="font-weight:700">Q${idx+1}: ${escapeHtml(qtext || '')}</div>
        <div style="margin-top:6px">${optsHtml}</div>`;

      const editBtn = document.createElement('button'); editBtn.className = 'small-btn'; editBtn.innerText = 'Edit';
      editBtn.onclick = () => openQuestionEditor(idx);
      const removeBtn = document.createElement('button'); removeBtn.className = 'small-btn'; removeBtn.innerText = 'Remove';
      removeBtn.onclick = () => { questions.splice(idx, 1); renderQuestionsList(container); };

      div.appendChild(editBtn);
      div.appendChild(removeBtn);
      container.appendChild(div);
    });
  }

  // Show the create-test modal (preview + controls)
  function showTestModal(preservedTitle = '') {
    const folderNode = folderId ? findNodeById(folderId, treeCache) : null;
    const lessonOptions = (folderNode && Array.isArray(folderNode.lessons)) ? folderNode.lessons.slice() : [];
    const lessonSelectHtml = lessonOptions.length
      ? (`<label>Attach to lesson (optional)</label><select id="testLessonSelect"><option value="">-- none --</option>${lessonOptions.map(l => `<option value="${l._id}" ${lessonId && String(lessonId) === String(l._id) ? 'selected' : ''}>${escapeHtml(tLocalized(l.title) || (l.title && l.title.en) || 'Untitled')}</option>`).join('')}</select>`)
      : `<label>Attach to lesson (optional)</label><input id="testLessonInput" placeholder="paste lesson id (optional)" value="${lessonId ? escapeHtml(lessonId) : ''}">`;

    const html = `
      <h3>Create Test</h3>
      <label>Test title</label><input id="testTitle" value="${escapeHtml(preservedTitle)}" placeholder="e.g. Algebra Basics Quiz">
      ${lessonSelectHtml}
      <div style="margin-top:8px"><button id="addQuestionBtn" class="small-btn">+ Add question</button></div>
      <div id="questionsWrap" style="margin-top:10px"></div>
      <div style="display:flex;gap:8px;margin-top:12px"><button id="createTestBtn">Create Test</button><button id="cancelTestBtn" class="btn-ghost">Cancel</button></div>
      <p class="muted-note">Mark correct option with checkbox in editor. Each question needs at least two options. Questions and options are saved bilingual (English + Somali fields).</p>
    `;
    showModal(html);

    const wrap = document.getElementById('questionsWrap');
    renderQuestionsList(wrap);

    document.getElementById('addQuestionBtn').onclick = () => openQuestionEditor(null);
    document.getElementById('cancelTestBtn').onclick = closeModal;

    document.getElementById('createTestBtn').onclick = async () => {
      const title = (document.getElementById('testTitle').value || '').trim();
      if (!title) return alert('Test title required');
      if (questions.length === 0) return alert('Add at least one question');

      // Sanitize & coerce to strings before sending
      questions.forEach((q, qi) => {
        q.id = q.id || ('q_' + (qi+1) + '_' + Math.random().toString(36).slice(2,6));
        q.options.forEach((o, oi) => o.id = o.id || ('o' + (oi+1) + '_' + Math.random().toString(36).slice(2,6)));
      });

      const selectedLesson = document.getElementById('testLessonSelect') ? document.getElementById('testLessonSelect').value : (document.getElementById('testLessonInput') ? document.getElementById('testLessonInput').value.trim() : '');
      const payload = {
        title,
        folderId: folderId || null,
        lessonId: selectedLesson || null,
        questions: questions.map(q => ({
          id: q.id,
          text: { en: String(q.text.en || ''), som: String(q.text.som || '') },
          options: q.options.map(o => ({ id: o.id, text: { en: String(o.text.en || ''), som: String(o.text.som || '') }, isCorrect: !!o.isCorrect })),
          pointsValue: q.pointsValue || 3
        }))
      };

      const r = await fetchJson('/api/tests', { method: 'POST', headers: authHeaders(), body: JSON.stringify(payload) });
      if (!r.ok) return alert('Create test failed: ' + (r.error || ''));
      closeModal();
      alert('Test created');
      // refresh tree/list
      await loadTree();
    };
  }

  function openQuestionEditor(index) {
    const existing = (typeof index === 'number' && questions[index]) ? normalizeLocalQuestion(questions[index]) : null;
    const qTextEn = existing && existing.text ? existing.text.en : '';
    const qTextSom = existing && existing.text ? existing.text.som : '';
    const opts = existing ? existing.options.map(o => ({ id: o.id || null, text: { en: o.text.en || '', som: o.text.som || '' }, isCorrect: !!o.isCorrect })) : [{ id: null, text: { en: '', som: '' }, isCorrect: false }, { id: null, text: { en: '', som: '' }, isCorrect: false }];

    const html = `
      <h4>${existing ? 'Edit Question' : 'New Question'}</h4>
      <label>Question text ‚Äî English</label><textarea id="qTextEn" rows="3" placeholder="e.g. 2+2=?">${escapeHtml(qTextEn)}</textarea>
      <label>Question text ‚Äî Somali (optional)</label><textarea id="qTextSom" rows="2" placeholder="e.g. 2+2=? (Somali)">${escapeHtml(qTextSom)}</textarea>
      <label>Options</label>
      <div id="optsWrap" style="margin-top:8px"></div>
      <div style="display:flex;gap:8px;margin-top:10px"><button id="addOptBtn" class="small-btn">+ Option</button><button id="saveQBtn">Save</button><button id="cancelQBtn" class="btn-ghost">Cancel</button></div>
    `;
    showModal(html);

    function renderOpts() {
      const wrap = document.getElementById('optsWrap');
      wrap.innerHTML = '';
      opts.forEach((o, i) => {
        const div = document.createElement('div');
        div.className = 'opt-row';
        div.style.display = 'flex';
        div.style.alignItems = 'center';
        div.style.gap = '8px';
        div.style.marginBottom = '6px';
        div.innerHTML = `<input type="checkbox" class="opt-correct" data-i="${i}" ${o.isCorrect ? 'checked' : ''} aria-label="Mark option ${i+1} as correct">
          <input type="text" class="opt-text-en" data-i="${i}" value="${escapeHtml(o.text.en||'')}" placeholder="Option English">
          <input type="text" class="opt-text-som" data-i="${i}" value="${escapeHtml(o.text.som||'')}" placeholder="Option Somali (optional)">
          <button class="small-btn del-opt" data-i="${i}">Del</button>`;
        wrap.appendChild(div);
      });
      wrap.querySelectorAll('.opt-correct').forEach(ch => ch.onchange = (e) => { opts[+e.target.dataset.i].isCorrect = e.target.checked; });
      wrap.querySelectorAll('.opt-text-en').forEach(inp => inp.oninput = (e) => { opts[+e.target.dataset.i].text.en = e.target.value; });
      wrap.querySelectorAll('.opt-text-som').forEach(inp => inp.oninput = (e) => { opts[+e.target.dataset.i].text.som = e.target.value; });
      wrap.querySelectorAll('.del-opt').forEach(b => b.onclick = (e) => { opts.splice(+e.target.dataset.i, 1); renderOpts(); });
    }
    renderOpts();

    document.getElementById('addOptBtn').onclick = () => { opts.push({ id: null, text: { en: '', som: '' }, isCorrect: false }); renderOpts(); };
    document.getElementById('cancelQBtn').onclick = () => { showTestModal(document.getElementById('testTitle') ? document.getElementById('testTitle').value : ''); };

    document.getElementById('saveQBtn').onclick = () => {
      const text = (document.getElementById('qTextEn').value || '').trim();
      const textSomNew = (document.getElementById('qTextSom').value || '').trim();
      if (!text) return alert('Question text required');
      if (opts.filter(o => o.text && o.text.en && o.text.en.trim()).length < 2) return alert('At least two options with text required');

      // Build a clean plain-string question object
      const qObj = {
        id: existing && existing.id ? existing.id : null,
        text: { en: String(text), som: String(textSomNew || '') },
        options: opts.map(o => ({ id: o.id || null, text: { en: String(o.text.en || ''), som: String(o.text.som || '') }, isCorrect: !!o.isCorrect })),
        pointsValue: existing ? existing.pointsValue : 3
      };

      if (existing && typeof index === 'number') questions[index] = qObj; else questions.push(qObj);
      showTestModal(document.getElementById('testTitle') ? document.getElementById('testTitle').value : '');
    };

    // focus first field
    setTimeout(() => {
      const f = document.getElementById('qTextEn'); if (f) f.focus();
    }, 30);
  }

  // initial show
  showTestModal();
}

/* Admin: Edit existing test (full modal) */
async function openEditTestModal(testId){
  if (!getToken()) return requireLoginModal('Please log in as an admin to edit tests.');
  if (!isAdmin()) return alert('Not allowed');
  const r = await fetchJson('/api/tests/'+encodeURIComponent(testId), { headers: authHeaders(), method: 'GET' });
  if (!r.ok) return alert('Failed to load test: '+(r.error||''));
  const test = r.data.test || r.data;
  // populate edit modal using same UI pieces as add
  const questions = (test.questions || []).map(q => ({ id: q.id || q._id, text: { en: (q.text && q.text.en) || (typeof q.text==='string'?q.text:''), som: (q.text && q.text.som) || '' }, options: (q.options||[]).map(o=>({ id: o.id || o._id, text: { en: (o.text && o.text.en) || (typeof o.text==='string'?o.text:''), som: (o.text && o.text.som) || '' }, isCorrect: !!o.isCorrect })), pointsValue: q.pointsValue || 3 })) ;

  const folderId = test.folderId || test.folder || null;
  const lessonId = test.lessonId || test.lesson || null;

  function renderQuestionsList(container){
    container.innerHTML = '';
    questions.forEach((q, idx) => {
      const div = document.createElement('div');
      div.style.border = '1px solid #eee'; div.style.padding='8px'; div.style.borderRadius='8px'; div.style.marginBottom='8px';
      div.innerHTML = `<div style="font-weight:700">Q${idx+1}: ${escapeHtml(q.text.en||'')}</div><div style="margin-top:6px">${q.options.map((o,i)=>`<div>${i+1}. ${escapeHtml(o.text.en||'')} ${o.isCorrect?'<strong>(correct)</strong>':''}</div>`).join('')}</div>`;
      const editBtn = document.createElement('button'); editBtn.className='small-btn'; editBtn.innerText='Edit'; editBtn.onclick = ()=> openQuestionEditorLocal(idx);
      const removeBtn = document.createElement('button'); removeBtn.className='small-btn'; removeBtn.innerText='Remove'; removeBtn.onclick = ()=> { questions.splice(idx,1); renderQuestionsList(container); };
      div.appendChild(editBtn); div.appendChild(removeBtn);
      container.appendChild(div);
    });
  }

  function openQuestionEditorLocal(index){
    const existing = questions[index];
    const qTextEn = existing ? existing.text.en : '';
    const qTextSom = existing ? existing.text.som : '';
    const opts = existing ? existing.options.map(o=>({ id:o.id, text:{en:o.text.en||'',som:o.text.som||''}, isCorrect: o.isCorrect })) : [{id:null,text:{en:'',som:''},isCorrect:false},{id:null,text:{en:'',som:''},isCorrect:false}];
    const html = `
      <h4>${existing ? 'Edit Question' : 'New Question'}</h4>
      <label>Question text ‚Äî English</label><input id="qTextEn" value="${escapeHtml(qTextEn)}">
      <label>Question text ‚Äî Somali (optional)</label><input id="qTextSom" value="${escapeHtml(qTextSom)}">
      <label>Options</label>
      <div id="optsWrap" style="margin-top:8px"></div>
      <div style="display:flex;gap:8px;margin-top:10px"><button id="addOptBtn" class="small-btn">+ Option</button><button id="saveQBtn">Save</button><button id="cancelQBtn" class="btn-ghost">Cancel</button></div>
    `;
    showModal(html);
    function renderOpts(){ const wrap=document.getElementById('optsWrap'); wrap.innerHTML=''; opts.forEach((o,i)=>{ const div=document.createElement('div'); div.className='opt-row'; div.innerHTML = `<input type="checkbox" class="opt-correct" data-i="${i}" ${o.isCorrect?'checked':''}> <input type="text" class="opt-text-en" data-i="${i}" value="${escapeHtml(o.text.en||'')}" placeholder="Option English"> <input type="text" class="opt-text-som" data-i="${i}" value="${escapeHtml(o.text.som||'')}" placeholder="Option Somali (optional)"> <button class="small-btn del-opt" data-i="${i}">Del</button>`; wrap.appendChild(div); });
      wrap.querySelectorAll('.opt-correct').forEach(ch=>ch.onchange=(e)=>opts[+e.target.dataset.i].isCorrect=e.target.checked);
      wrap.querySelectorAll('.opt-text-en').forEach(inp=>inp.oninput=(e)=>opts[+e.target.dataset.i].text.en=e.target.value);
      wrap.querySelectorAll('.opt-text-som').forEach(inp=>inp.oninput=(e)=>opts[+e.target.dataset.i].text.som=e.target.value);
      wrap.querySelectorAll('.del-opt').forEach(b=>b.onclick=(e)=>{ opts.splice(+e.target.dataset.i,1); renderOpts(); });
    }
    document.getElementById('addOptBtn').onclick = ()=> { opts.push({ id:null, text:{en:'',som:''}, isCorrect:false }); renderOpts(); };
    document.getElementById('cancelQBtn').onclick = ()=> { renderEditModal(); };
    document.getElementById('saveQBtn').onclick = ()=>{
      const textEn = (document.getElementById('qTextEn').value||'').trim();
      const textSom = (document.getElementById('qTextSom').value||'').trim();
      if (!textEn) return alert('Question English text required');
      if (opts.filter(o=>o.text && o.text.en && o.text.en.trim()).length < 2) return alert('At least two options with English text required');
      const qObj = { id: existing && existing.id ? existing.id : null, text: { en: textEn, som: textSom }, options: opts.map(o=>({ id:o.id||null, text:{en:o.text.en||'', som:o.text.som||''}, isCorrect: !!o.isCorrect })), pointsValue: existing?existing.pointsValue:3 };
      if (existing) questions[index] = qObj; else questions.push(qObj);
      renderEditModal();
    };
    renderOpts();
  }

  function renderEditModal(){
    const html = `
      <h3>Edit Test</h3>
      <label>Title</label><input id="editTestTitle" value="${escapeHtml(test.title||'')}">
      <label>Attach to lesson (optional)</label><input id="editTestLesson" value="${escapeHtml(lessonId||'')}">
      <div style="margin-top:8px"><button id="addQuestionBtn" class="small-btn">+ Add question</button></div>
      <div id="questionsWrap" style="margin-top:10px"></div>
      <div style="display:flex;gap:8px;margin-top:12px"><button id="saveTestBtn">Save Changes</button><button id="cancelEditTest" class="btn-ghost">Cancel</button></div>
      <p class="muted-note">You can add/edit/remove questions. Saving will send a PUT /api/tests/:id request (backend must support this). Questions and options are bilingual.</p>
    `;
    showModal(html);
    document.getElementById('questionsWrap').innerHTML = '';
    renderQuestionsList(document.getElementById('questionsWrap'));
    document.getElementById('addQuestionBtn').onclick = ()=> openQuestionEditorLocal(questions.length);
    document.getElementById('cancelEditTest').onclick = closeModal;
    document.getElementById('saveTestBtn').onclick = async ()=>{
      const newTitle = (document.getElementById('editTestTitle').value||'').trim();
      const newLesson = (document.getElementById('editTestLesson').value||'').trim()||null;
      if (!newTitle) return alert('Title required');
      const payload = {
        title: newTitle,
        folderId: folderId||null,
        lessonId: newLesson,
        questions: questions.map(q=>({ id:q.id, text:{ en:q.text.en||'', som:q.text.som||'' }, options: q.options.map(o=>({ id:o.id, text:{ en:o.text.en||'', som:o.text.som||'' }, isCorrect: !!o.isCorrect })), pointsValue: q.pointsValue||3 }))
      };
      let rr = await fetchJson('/api/tests/'+encodeURIComponent(testId), { method:'PUT', headers: authHeaders(), body: JSON.stringify(payload) });
      if (!rr.ok) {
        const cr = await fetchJson('/api/tests', { method:'POST', headers: authHeaders(), body: JSON.stringify(payload) });
        if (!cr.ok) return alert('Save failed: '+(rr.error||cr.error||''));
        alert('Saved as new test; consider deleting the old one.');
      }
      closeModal();
      await loadTree();
    };
  }

  renderEditModal();
}

/* ===================== TEST TAKING (unchanged except keyboard/progress) ===================== */
/* ... keep showPaginatedRunner, showTestRunner, aggregate runner from previous file ... */
/* For brevity I reference your existing runner code here ‚Äî it's already present above in previous version and unchanged except that Take Test buttons were removed from folder cards. */
/* (If you want I can paste the full runner code again ‚Äî but current file already contains the runner functions from earlier which we kept.) */

/* ===================== TEST TAKING (folder aggregation + paginated runner w/progress + keyboard) ===================== */
/* ===================== FRONTEND PATCH ===================== */
/* Replace collectLessonIdsFromFolderNode and gatherTestsForFolder with these versions */

/**
 * collectFolderIdsRecursive(node)
 * Returns array of folder._id strings for node and all descendants.
 */

 function collectFolderIdsRecursive(node){
  const ids = [];
  if (!node) return ids;
  ids.push(String(node._id));
  if (Array.isArray(node.children)) {
    node.children.forEach(c => ids.push(...collectFolderIdsRecursive(c)));
  }
  return ids;
}

/**
 * collectLessonIdsFromFolderNode recursively collects lesson ids for a node and all descendants.
 */
function collectLessonIdsFromFolderNode(node){
  const ids = [];
  if (!node) return ids;
  if (Array.isArray(node.lessons)) {
    node.lessons.forEach(l => ids.push(String(l._id)));
  }
  if (Array.isArray(node.children)) {
    node.children.forEach(c => {
      ids.push(...collectLessonIdsFromFolderNode(c));
    });
  }
  return ids;
}

/**
 * gatherTestsForFolder(folderId)
 * - Fetches tests for every folder id in subtree AND for every lesson id in subtree.
 * - Deduplicates by test._id / id.
 */

 

 async function gatherTestsForFolder(folderId){
  const tests = [];
  const seen = new Set();
  if (!folderId) return tests;

  // Find folder node in treeCache
  const rootNode = findNodeById(folderId, treeCache);
  if (!rootNode) {
    // fallback: try server-level query for folder
    const rFolderOnly = await fetchJson(`/api/tests?folderId=${encodeURIComponent(folderId)}`, { headers: authHeaders(), method: 'GET' });
    if (rFolderOnly.ok) {
      const arr = Array.isArray(rFolderOnly.data) ? rFolderOnly.data : (rFolderOnly.data && rFolderOnly.data.tests) ? rFolderOnly.data.tests : [];
      arr.forEach(t => { if (t && (t._id || t.id) && !seen.has(String(t._id||t.id))) { seen.add(String(t._id||t.id)); tests.push(t); } });
    }
    return tests;
  }

  // Collect all folder ids in subtree
  const folderIds = collectFolderIdsRecursive(rootNode);

  // For each folder id, fetch tests attached to that folder
  for (const fid of folderIds) {
    const r = await fetchJson(`/api/tests?folderId=${encodeURIComponent(fid)}`, { headers: authHeaders(), method:'GET' });
    if (!r.ok) continue;
    const arr = Array.isArray(r.data) ? r.data : (r.data && r.data.tests) ? r.data.tests : (r.data ? (Array.isArray(r.data)?r.data:[]) : []);
    arr.forEach(t => { if (t && (t._id || t.id) && !seen.has(String(t._id||t.id))) { seen.add(String(t._id||t.id)); tests.push(t); } });
  }



 // Collect all lesson ids in subtree and fetch tests for each lesson
  const lessonIds = collectLessonIdsFromFolderNode(rootNode);
  for (const lid of lessonIds) {
    const r = await fetchJson(`/api/tests?lessonId=${encodeURIComponent(lid)}`, { headers: authHeaders(), method:'GET' });
    if (!r.ok) continue;
    const arr = Array.isArray(r.data) ? r.data : (r.data && r.data.tests) ? r.data.tests : (r.data ? (Array.isArray(r.data)?r.data:[]) : []);
    arr.forEach(t => { if (t && (t._id || t.id) && !seen.has(String(t._id||t.id))) { seen.add(String(t._id||t.id)); tests.push(t); } });
  }

  return tests;
}

async function openTakeTest(folderId=null, lessonId=null){
  let tests = [];
  if (lessonId) {
    const r = await fetchJson(`/api/tests?lessonId=${encodeURIComponent(lessonId)}`, { headers: authHeaders(), method:'GET' });
    if (r && r.ok) tests = Array.isArray(r.data) ? r.data : (r.data.tests || r.data || []);
  }
  if ((!tests||tests.length===0) && folderId) tests = await gatherTestsForFolder(folderId);
  if (!tests || tests.length===0) return alert('No tests found for this folder/lesson.');

  // If multiple tests and no explicit folder, let user pick
  if (tests.length > 1 && !folderId) {
    const html = `<h3>Select Test</h3>
      <div style="max-height:50vh;overflow:auto">
        ${tests.map(t=>`<div style="padding:8px;border-bottom:1px solid #eee">
          <strong>${escapeHtml(t.title||'Untitled')}</strong>
          <div style="margin-top:6px">
            <button class="small-btn pick-test" data-id="${escapeHtml(t._id||t.id)}">Take</button>
            ${isAdmin() ? `<button class="small-btn edit-test" data-id="${escapeHtml(t._id||t.id)}">Edit</button>` : ''}
          </div>
        </div>`).join('')}
      </div>
      <div style="margin-top:10px"><button id="closePick" class="btn-ghost">Close</button></div>`;

    const modalRef = safeShowModal(html);
    // attach handlers - robust close
    const closeBtn = document.getElementById('closePick') || (modalRef.box && modalRef.box.querySelector('#closePick'));
    if (closeBtn) closeBtn.onclick = () => safeCloseModal();

    // pick buttons
    const pickEls = document.querySelectorAll('.pick-test');
    pickEls.forEach(btn => {
      btn.onclick = async (e) => {
        e.preventDefault();
        const id = btn.dataset.id;
        safeCloseModal();
        await showTestRunner(id);
      };
    });

    const editEls = document.querySelectorAll('.edit-test');
    editEls.forEach(btn => {
      btn.onclick = async (e) => {
        e.preventDefault();
        const id = btn.dataset.id;
        safeCloseModal();
        if (typeof openEditTestModal === 'function') openEditTestModal(id);
        else alert('Edit modal not implemented');
      };
    });
    return;
  }

  if (folderId && tests.length > 1) { await showAggregatedTestRunner(tests); return; }
  const testId = tests[0]._id || tests[0].id;
  await showTestRunner(testId);
}

async function showTestRunner(testId){
  const r = await fetchJson('/api/tests/'+encodeURIComponent(testId), { headers: authHeaders(), method:'GET' });
  if (!r || !r.ok) return alert('Failed to load test: '+(r && r.error ? r.error : 'Server error'));
  const test = (r.data && (r.data.test || r.data)) || null;
  if (!test) return alert('Test data malformed');
  const qs = (test.questions||[]).map((q,idx)=>({
    ...q,
    __testId: test._id || test.id,
    __origIndex: idx,
    textStr: (q.text && (q.text.en||q.text)) || (typeof q.text==='string' ? q.text : '')
  }));
  await showPaginatedRunner([{ testId: test._id||test.id, title: test.title||'', questions: qs }], false);
}

async function showAggregatedTestRunner(testsArray){
  const normalized = [];
  const concurrency = 6;
  async function fetchOne(t){
    try {
      const tId = t._id || t.id;
      if (!tId) return null;
      const r = await fetchJson('/api/tests/' + encodeURIComponent(tId), { headers: authHeaders(), method:'GET' });
      if (!r || !r.ok) return null;
      const test = (r.data && (r.data.test || r.data)) || null;
      if (!test) return null;
      const qs = (test.questions||[]).map((q, idx) => ({
        ...q,
        __testId: tId,
        __origIndex: idx,
        textStr: safeText((q.text && (q.text.en || q.text)) || q.text || '')
      }));
      return { testId: tId, title: test.title || '', questions: qs };
    } catch(e){
      return null;
    }
  }

  for (let i=0; i<testsArray.length; i+=concurrency) {
    const chunk = testsArray.slice(i, i+concurrency);
    const res = await Promise.all(chunk.map(fetchOne));
    res.filter(Boolean).forEach(x => normalized.push(x));
  }

  // dedupe by testId
  const seen = new Set();
  const unique = [];
  normalized.forEach(n => {
    if (!n || !n.testId) return;
    if (!seen.has(String(n.testId))) { seen.add(String(n.testId)); unique.push(n); }
  });

  if (!unique.length) return alert('No valid tests to run.');
  await showPaginatedRunner(unique, true);
}

async function showPaginatedRunner(testsNormalized, aggregatedFlag){
  // Build blocks and question order
  const blocks = testsNormalized.map(t => ({ testId: t.testId, title: t.title, questions: t.questions }));
  let flat = [];
  blocks.forEach(b => b.questions.forEach(q => flat.push({ ...q, __testId: b.testId, __origIndex: q.__origIndex })));

  // Shuffle questions (Fisher-Yates)
  for (let i = flat.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [flat[i], flat[j]] = [flat[j], flat[i]];
  }
  const questionOrder = flat;

  // Answer storage
  const answersMap = {};
  const attemptMap = {};
  blocks.forEach(b => { answersMap[b.testId] = Array(b.questions.length).fill(null); });

  let currentIndex = 0;
  let timer = null;
  const QUESTION_SECONDS_DEFAULT = QUESTION_SECONDS || 30;
  let timeLeft = QUESTION_SECONDS_DEFAULT;
  let alreadySubmitted = false;

  const POINTS_FOR_CORRECT = 3;
  const POINTS_FOR_INCORRECT = -1;

  // streak state
let currentStreak = 0;
// track the highest streak reached during THIS run (so final display shows the max reached even if broken later)
let bestDuringRun = 0;

const testIdForThisRun = (blocks.length && blocks[0].testId) ? blocks[0].testId : (questionOrder[0] && questionOrder[0].__testId);

  // load authoritative global best initially
  
  let bestGlobal = { streak: 0, name: null };
  try { bestGlobal = await loadBestStreak(testIdForThisRun); } catch(e){ console.warn('loadBestStreak init failed', e); }

  let warningPlayed = false;

  // toast
  function showToastMessage(msg, tone='neutral'){
    const el = document.createElement('div');
    el.className = 'toast-msg';
    Object.assign(el.style, { position:'fixed', right:'12px', top:'12px', zIndex:11000, padding:'8px 12px', borderRadius:'8px', boxShadow:'0 6px 18px rgba(0,0,0,0.06)' });
    el.style.background = tone==='good' ? '#e6ffed' : (tone==='bad' ? '#ffe6e6' : '#fff7cc');
    el.innerText = msg;
    document.body.appendChild(el);
    setTimeout(()=> el.remove(), 2400);
  }

  async function updateStreakDisplay(containerEl){
    if (!containerEl) containerEl = document.getElementById('streakBlock');
    if (!containerEl) return;

    const testIdNow = (questionOrder[currentIndex] && questionOrder[currentIndex].__testId) || testIdForThisRun;
    let bestRec = { streak: 0, name: null };
    try { bestRec = await loadBestStreak(testIdNow); } catch(e){ console.warn('loadBestStreak failed', e); }
    const name = bestRec.name || '‚Äî';
    const best = bestRec.streak || 0;

    // personal best
    let yourBest = 0;
    try {
      const raw = localStorage.getItem('yourBest:' + testIdNow);
      if (raw) yourBest = Number(JSON.parse(raw).streak || 0);
      else yourBest = Number(localStorage.getItem('yourBestGlobal') || 0);
    } catch(e) { yourBest = Number(localStorage.getItem('yourBestGlobal') || 0); }

    const cur = currentStreak || 0;
    const runBest = bestDuringRun || 0;

    containerEl.innerHTML = `
      <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
        <div style="font-size:13px;color:#666">Highest streak: <strong style="font-size:14px">${escapeHtml(String(best))}</strong> <span style="color:#444">by</span> <strong style="font-size:13px">${escapeHtml(name || '')}</strong></div>
        <div style="font-size:13px;color:#666">Your highest: <strong style="font-size:14px">${escapeHtml(String(yourBest))}</strong></div>
        <div style="font-size:13px;color:#666">This run highest: <strong style="font-size:14px">${escapeHtml(String(runBest))}</strong></div>
        <div style="margin-left:auto;display:flex;align-items:center;gap:8px">
          <div style="font-size:13px;color:#666">Current streak:</div>
          ${streakBadgeHtml('cur', cur)}
        </div>
      </div>
    `;
  }


  function showFeedbackForOption(optionObj, qObj){
    document.querySelectorAll('.test-option .opt-feedback').forEach(e=> { e.innerHTML = ''; e.style.color = ''; });
    document.querySelectorAll('.test-option').forEach(div => {
      const optId = div.dataset.optid;
      const fb = div.querySelector('.opt-feedback');
      if (!fb) return;
      if (String(optId) === String(optionObj.id || optionObj._id)) {
        if (optionObj.isCorrect) { fb.innerHTML = ' ‚úì Correct'; fb.style.color = 'green'; }
        else { fb.innerHTML = ' ‚úñ Incorrect'; fb.style.color = 'red'; }
      }
    });

    const explainArea = document.getElementById('explainArea');
    if (!explainArea) return;
    if (optionObj.isCorrect) {
      const explText = safeText((qObj.explanation && (qObj.explanation.en || qObj.explanation)) || '');
      if (explText && explText.trim()) explainArea.innerHTML = `<div style="padding:8px;border-radius:6px;border:1px solid #eee;background:#eaffea"><strong>Explanation:</strong><div style="white-space:pre-wrap;margin-top:6px">${escapeHtml(explText)}</div></div>`;
      else explainArea.innerHTML = `<div style="padding:8px;border-radius:6px;border:1px solid #eee;background:#eaffea"><strong>Correct.</strong></div>`;
    } else {
      const correctOpt = (qObj.options||[]).find(o => o.isCorrect);
      if (correctOpt) explainArea.innerHTML = `<div style="padding:8px;border-radius:6px;border:1px solid #eee;background:#fff7f7"><strong>Correct answer:</strong> ${escapeHtml(safeText((correctOpt.text && (correctOpt.text.en || correctOpt.text)) || ''))}</div>`;
      else explainArea.innerHTML = `<div style="padding:8px;border-radius:6px;border:1px solid #eee;background:#fff7f7"><strong>Incorrect.</strong></div>`;
    }
  }

  // record answer and update streaks
  async function saveCurrentAnswerOnce(selectedOptionId, fromTimeout=false, qObj){
    if (!qObj) qObj = questionOrder[currentIndex];
    const tId = qObj.__testId;
    const qIndexLocal = qObj.__origIndex;
    const existing = answersMap[tId][qIndexLocal];
    if (existing && existing.selectedOptionId) {
      showToastMessage('Answer already recorded. Use Next to continue.', 'neutral');
      const chosen = (qObj.options||[]).find(o => String(o.id||o._id) === String(selectedOptionId));
      if (chosen) showFeedbackForOption(chosen, qObj);
      return;
    }

    const answeredAt = (new Date()).toISOString();
    if (timer) { clearInterval(timer); timer = null; }
    const answerObj = { questionId: qObj.id || qObj._id || String(Math.random()), selectedOptionId: selectedOptionId||null, questionIndex: qIndexLocal, answeredAt, fromTimeout: !!fromTimeout };
    answersMap[tId][qIndexLocal] = answerObj;

    const chosenOpt = (qObj.options || []).find(o => String(o.id || o._id) === String(selectedOptionId));
    const isCorrect = !!(chosenOpt && chosenOpt.isCorrect);

    if (selectedOptionId) {
      if (isCorrect) {
        currentStreak++;
          // update the bestDuringRun (this run) immediately
  bestDuringRun = Math.max(bestDuringRun, currentStreak);


        playModernSound('correct');

        // If new global best reached ‚Äî persist to server (await so other devices see it)
        if (currentStreak > (bestGlobal && bestGlobal.streak ? Number(bestGlobal.streak) : 0)) {
          const gu = (typeof getUser === 'function') ? getUser() : null;
          const name = gu && gu.fullName ? gu.fullName : (gu && gu.username ? gu.username : 'Unknown');
          try {
            // await server update if logged in, otherwise local only
            const saved = await saveBestStreak(qObj.__testId || tId, currentStreak, name);
            // reload authoritative server value (bestGlobal) if possible
            try { bestGlobal = await loadBestStreak(qObj.__testId || tId); } catch(e){}
          } catch(e){ console.warn('saveBestStreak failed', e); }
          try { localStorage.setItem('yourBest:' + (qObj.__testId || tId), JSON.stringify({ streak: currentStreak, updatedAt: new Date().toISOString() })); } catch(e){}
          showToastMessage(`New best streak! x${currentStreak}`, 'good');
        } else {
          showToastMessage(`Nice! Streak x${currentStreak}`, 'good');
        }
      } else {
        playModernSound('incorrect');
        if (currentStreak > 0) showToastMessage(`Streak broken (x${currentStreak}) ‚Äî keep trying!`, 'bad');
        currentStreak = 0;
      }
    }

    // show feedback & disable options
    if (chosenOpt) showFeedbackForOption(chosenOpt, qObj);
    else {
      const corr = (qObj.options||[]).find(o => o.isCorrect);
      if (corr) showFeedbackForOption(corr, qObj);
    }
    document.querySelectorAll('.options input[name="qopt"]').forEach(el => el.disabled = true);

    // refresh streak UI
    const streakContainer = document.getElementById('streakBlock');
    if (streakContainer) await updateStreakDisplay(streakContainer);
  }

  // render one question UI into modal
  function renderQuestionUI(){
    if (currentIndex < 0) currentIndex = 0;
    if (currentIndex >= questionOrder.length) currentIndex = questionOrder.length - 1;
    const q = questionOrder[currentIndex];
    const testBlock = blocks.find(b => b.testId === q.__testId) || {};
    const qTitle = q.textStr || safeText((q.text && (q.text.en || q.text)) || q.text || '');
    const total = questionOrder.length;
    const progressPercent = Math.round(((currentIndex+1)/total)*100);

    const optsHtml = (q.options||[]).map((o,oi)=> {
      const optId = `opt_${currentIndex}_${oi}`;
      return `<div class="test-option" data-optid="${escapeHtml(o.id||o._id||oi)}" data-idx="${oi}">
        <label for="${optId}">
          <input type="radio" id="${optId}" name="qopt" value="${escapeHtml(o.id||o._id||oi)}">
          <span class="opt-text">${escapeHtml(safeText((o.text && (o.text.en || o.text)) || o.text || ''))}</span>
        </label>
        <span class="opt-feedback" id="fb_${optId}" aria-hidden="true"></span>
      </div>`;
    }).join('');

    const html = `
      <div class="runner-header" style="display:flex;flex-direction:column;gap:8px">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <h3 style="margin:0">${escapeHtml(testBlock.title || 'Test')}</h3>
          <div style="font-size:13px;color:#666">Question ${currentIndex+1} of ${total}</div>
        </div>
        <div style="display:flex;gap:12px;align-items:center">
          <div style="display:flex;gap:8px;align-items:center">
            <div style="font-size:13px;color:#666">Time left:</div><div id="timerDisplay" class="timer" style="font-weight:700">${timeLeft}s</div>
            <div style="width:160px;margin-left:12px"><div class="progress-wrap" role="progressbar" style="background:#f3f3f3;border-radius:6px;height:8px;overflow:hidden"><div id="progressBar" style="height:100%;width:${progressPercent}%;background:linear-gradient(90deg,#4ade80,#06b6d4)"></div></div></div>
          </div>
          <div id="streakBlock" style="margin-left:auto"></div>
        </div>
      </div>

      <div id="questionWrap" style="margin-top:10px">
        <div class="test-question">
          <h4 style="white-space:pre-wrap">${escapeHtml(qTitle)}</h4>
          <div class="options">${optsHtml}</div>
          <div id="explainArea" style="margin-top:10px"></div>
        </div>
      </div>

      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="prevQ" class="small-btn" ${currentIndex===0? 'disabled':''}>Prev</button>
        <button id="nextQ" class="small-btn" ${currentIndex===questionOrder.length-1? 'disabled':''}>Next</button>
        <button id="finishQ" class="btn-ghost">Finish</button>
        <button id="cancelQ" class="btn-ghost" style="margin-left:8px">Cancel</button>
      </div>
      <div style="margin-top:8px" class="muted-note">Each question has ${QUESTION_SECONDS_DEFAULT} seconds. When timer expires it auto-advances. Use ‚Üê and ‚Üí keys to navigate.</div>
    `;

    const modalRef = safeShowModal(html);

    // update streak UI
    updateStreakDisplay(document.getElementById('streakBlock')).catch(()=>{});

    // restore previous answer & disable if needed
    const prevAns = answersMap[q.__testId][q.__origIndex];
    if (prevAns && prevAns.selectedOptionId) {
      setTimeout(()=> {
        const el = document.querySelector(`input[name="qopt"][value="${prevAns.selectedOptionId}"]`);
        if (el) el.checked = true;
        const opt = (q.options || []).find(o => String(o.id || o._id) === String(prevAns.selectedOptionId));
        if (opt) showFeedbackForOption(opt, q);
        document.querySelectorAll('.options input[name="qopt"]').forEach(e=> e.disabled = true);
      }, 30);
    }

    // start timer
    timeLeft = QUESTION_SECONDS_DEFAULT;
    warningPlayed = false;
    if (timer) clearInterval(timer);
    timer = setInterval(()=> {
      timeLeft--;
      const tEl = document.getElementById('timerDisplay');
      if (tEl) tEl.innerText = `${timeLeft}s`;
      if (!warningPlayed && timeLeft <= 5 && timeLeft > 0) {
        warningPlayed = true;
        playModernSound('warning');
        showToastMessage('Hurry ‚Äî less than 5s left!', 'neutral');
      }
      if (timeLeft <= 0) {
        clearInterval(timer);
        const selected = getSelectedOption();
        saveCurrentAnswerOnce(selected, true, q).catch(()=>{});
        if (currentIndex < questionOrder.length - 1) { currentIndex++; renderQuestionUI(); }
        else { submitAllAnswers(); }
      }
    }, 1000);

    // button handlers
    document.getElementById('prevQ').onclick = ()=> { if (currentIndex > 0) { currentIndex--; renderQuestionUI(); } };
    document.getElementById('nextQ').onclick = ()=> { if (currentIndex < questionOrder.length - 1) { currentIndex++; renderQuestionUI(); } };
    document.getElementById('finishQ').onclick = async ()=> { await saveCurrentAnswerOnce(getSelectedOption(), false, q); await submitAllAnswers(); };
    const cancelBtn = document.getElementById('cancelQ');
    if (cancelBtn) cancelBtn.onclick = () => { if (confirm('Cancel this run? Your progress will be lost.')) { safeCloseModal(); } };

    // radio change handlers
    document.querySelectorAll('.options input[type="radio"]').forEach(inp => {
      inp.addEventListener('change', (ev) => {
        const val = ev.currentTarget.value;
        saveCurrentAnswerOnce(val, false, q);
      });
    });

    function getSelectedOption(){ const checked = document.querySelector('input[name="qopt"]:checked'); return checked ? checked.value : null; }
  } // renderQuestionUI

  // submit answers aggregated (optimized & parallel)
  async function submitAllAnswers(){
    if (alreadySubmitted) return alert('Submitting ‚Äî please wait');
    alreadySubmitted = true;
    if (timer) { clearInterval(timer); timer = null; }

    // 1) compute local summary counts immediately (no network)
    const summary = { totalQuestions:0, correct:0, incorrect:0, unanswered:0, perTest: [], localPointsDelta:0 };

    for (const b of blocks) {
      const tId = b.testId;
      const answersArr = (answersMap[tId] || []).map((a, idx) => {
        const qObj = b.questions[idx];
        const questionId = a ? a.questionId : (qObj.id || qObj._id);
        const picked = a ? a.selectedOptionId : null;
        const opt = (qObj.options||[]).find(o => String(o.id||o._id) === String(picked));
        const isCorrect = !!(opt && opt.isCorrect);
        summary.totalQuestions++;
        if (!picked) summary.unanswered++;
        else if (isCorrect) { summary.correct++; summary.localPointsDelta += POINTS_FOR_CORRECT; }
        else { summary.incorrect++; summary.localPointsDelta += POINTS_FOR_INCORRECT; }
        return { questionId, selectedOptionId: picked, questionIndex: idx, answeredAt: a ? a.answeredAt : null };
      });

      summary.perTest.push({ testId: tId, answersArr, title: b.title, result: null }); // placeholder for results
    }

    // Active title for UI
    const activeTestTitle = (questionOrder[currentIndex] && (blocks.find(b => b.testId === questionOrder[currentIndex].__testId) || {}).title) || (testsNormalized && testsNormalized.length && testsNormalized[0].title) || 'Competition';

    // 2) Render skeleton result modal immediately for snappy UX
    const perTestRowsSkeleton = summary.perTest.map((p, i) =>
      `<div id="perTestRow_${i}" style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid #f3f3f3">
         <div><strong>${escapeHtml(p.title||p.testId)}</strong></div>
         <div style="font-size:13px"><em>Submitting‚Ä¶</em></div>
       </div>`
    ).join('');

    const gu = (typeof getUser === 'function') ? getUser() : null;
    const userFullName = gu && (gu.fullName || gu.username) ? (gu.fullName || gu.username) : (getToken() ? 'Logged-in user' : 'Guest');

    const skeletonHtml = `
      <div style="max-width:720px;padding:18px;font-family:system-ui,Segoe UI,Roboto,Arial;background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(10,20,30,0.08)">
        <div style="display:flex;align-items:center;gap:12px">
          <h2 style="margin:0">${escapeHtml(activeTestTitle)}</h2>
          <div style="margin-left:auto;font-size:13px;color:#666">User: <strong>${escapeHtml(userFullName)}</strong></div>
        </div>

        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-top:14px">
          <div style="padding:12px;border-radius:8px;background:#f8fafc;text-align:center"><div style="font-size:12px;color:#666">Total</div><div style="font-weight:700;font-size:18px">${summary.totalQuestions}</div></div>
          <div style="padding:12px;border-radius:8px;background:#e6ffed;text-align:center"><div style="font-size:12px;color:#666">Correct</div><div style="font-weight:700;font-size:18px">${summary.correct}</div></div>
          <div style="padding:12px;border-radius:8px;background:#fff7f7;text-align:center"><div style="font-size:12px;color:#666">Incorrect</div><div style="font-weight:700;font-size:18px">${summary.incorrect}</div></div>
          <div style="padding:12px;border-radius:8px;background:#f3f4f6;text-align:center"><div style="font-size:12px;color:#666">Unanswered</div><div style="font-weight:700;font-size:18px">${summary.unanswered}</div></div>
        </div>

        <div style="display:flex;align-items:center;gap:12px;margin-top:12px">
          <div style="font-size:13px;color:#666">Local points delta:</div><div style="font-weight:700">${summary.localPointsDelta}</div>
          <div style="margin-left:auto">
            <div id="runStreakDisplay" style="font-size:13px;color:#666">Your streak: ${streakBadgeHtml('', currentStreak)}</div>
            <div id="runBestDisplay" style="font-size:13px;color:#666;margin-top:6px">This run highest: <strong>${escapeHtml(String(bestDuringRun||0))}</strong></div>
            <div id="globalBestDisplay" style="font-size:13px;color:#666;margin-top:6px">Highest streak: <strong>‚Äî</strong></div>
          </div>
        </div>

        <div style="margin-top:14px;padding-top:12px;border-top:1px solid #f3f3f3">
          <strong>Server per-test results</strong>
          <div id="perTestRows" style="margin-top:8px">${perTestRowsSkeleton}</div>
        </div>

        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:18px">
          <button id="closeResult" class="btn-ghost" disabled>Close</button>
        </div>
      </div>
    `;

    const modalRef = safeShowModal(skeletonHtml);
    const closeBtn = (modalRef.box && modalRef.box.querySelector('#closeResult')) || document.getElementById('closeResult');

    // 3) For each test perform start->submit chain concurrently (map -> Promise.all)
    const submitPromises = summary.perTest.map(async (p, idx) => {
      try {
        // try to start (optional)
        let attemptId = null;
        try {
          const sr = await fetchJson('/api/tests/' + encodeURIComponent(p.testId) + '/start', { method:'POST', headers: authHeaders() });
          if (sr && sr.ok && sr.data) attemptId = sr.data.attemptId || sr.data.attemptId;
        } catch(e){ /* ignore - server may allow direct submit */ }

        // submit
        let submitResp = null;
        if (attemptId) {
          submitResp = await fetchJson('/api/tests/' + encodeURIComponent(p.testId) + '/submit', { method:'POST', headers: authHeaders(), body: JSON.stringify({ attemptId, answers: p.answersArr }) });
        } else {
          // if server doesn't use attemptId, try to submit with answers only (some APIs accept it)
          submitResp = await fetchJson('/api/tests/' + encodeURIComponent(p.testId) + '/submit', { method:'POST', headers: authHeaders(), body: JSON.stringify({ answers: p.answersArr }) });
        }

        // update the perTest row in modal
        const rowEl = (modalRef.box && modalRef.box.querySelector('#perTestRow_' + idx)) || document.getElementById('perTestRow_' + idx);
        if (rowEl) {
          if (submitResp && submitResp.ok && submitResp.data) {
            const data = submitResp.data || submitResp;
            rowEl.innerHTML = `<div><strong>${escapeHtml(p.title||p.testId)}</strong></div><div style="font-size:13px">scoreDelta: ${escapeHtml(String(data.scoreDelta != null ? data.scoreDelta : '‚Äî'))} ${data.totalAfter != null ? `(totalAfter: ${escapeHtml(String(data.totalAfter))})` : ''}</div>`;
            p.result = { ok:true, data };
          } else {
            rowEl.innerHTML = `<div><strong>${escapeHtml(p.title||p.testId)}</strong></div><div style="font-size:13px;color:#c33">Failed: ${escapeHtml((submitResp && submitResp.error) || 'no-response')}</div>`;
            p.result = { ok:false, error: submitResp && submitResp.error };
          }
        }
        return p;
      } catch(err){
        const rowEl = (modalRef.box && modalRef.box.querySelector('#perTestRow_' + idx)) || document.getElementById('perTestRow_' + idx);
        if (rowEl) rowEl.innerHTML = `<div><strong>${escapeHtml(p.title||p.testId)}</strong></div><div style="font-size:13px;color:#c33">Network error</div>`;
        p.result = { ok:false, error: 'network' };
        return p;
      }
    });

    // wait for all per-test submissions to finish
    await Promise.all(submitPromises);

    // 4) fetch final authoritative best streak (if server available) and update modal
    try {
      const activeTestId = (questionOrder[currentIndex] && questionOrder[currentIndex].__testId) || testIdForThisRun;
      const bestRecFinal = await loadBestStreak(activeTestId);
      // update global best display
      const globalEl = (modalRef.box && modalRef.box.querySelector('#globalBestDisplay')) || document.getElementById('globalBestDisplay');
      if (globalEl) {
        globalEl.innerHTML = `Highest streak: <strong>${escapeHtml(String(bestRecFinal.streak||0))}</strong> ${bestRecFinal.name ? `by ${escapeHtml(bestRecFinal.name)}` : ''}`;
      }
    } catch(e){
      // ignore
    }

    // enable close button
    if (closeBtn) {
      closeBtn.disabled = false;
      closeBtn.onclick = ()=> { safeCloseModal(); if (typeof loadTree === 'function') loadTree(); };
    }

    // also show run best in place (update runStreakDisplay if present)
    const runBestDisplay = (modalRef.box && modalRef.box.querySelector('#runBestDisplay')) || document.getElementById('runBestDisplay');
    if (runBestDisplay) runBestDisplay.innerHTML = `This run highest: <strong>${escapeHtml(String(bestDuringRun || 0))}</strong>`;

  } // submitAllAnswers

  // keyboard navigation
  function keyHandler(e){
    if (e.key === 'ArrowLeft') { e.preventDefault(); document.getElementById('prevQ') && document.getElementById('prevQ').click(); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); document.getElementById('nextQ') && document.getElementById('nextQ').click(); }
    else if (e.key === 'Enter') {
      const finishBtn = document.getElementById('finishQ');
      if (finishBtn) finishBtn.click();
    }
  }
  document.addEventListener('keydown', keyHandler);

  if (questionOrder.length === 0) return alert('No questions to run.');
  renderQuestionUI();
} // end showPaginatedRunner

/* ===================== RECYCLE / RESTORE (unchanged) ===================== */

async function openRecycleModal(){ 
  if (!getToken()) return requireLoginModal('Please log in as an admin to view the recycle bin.'); 
  if (!isAdmin()) 
  return alert('Only admins may access the recycle bin.'); 
const r = await fetchJson('/api/lessons/recycle', { headers: authHeaders(), method: 'GET' }); if (r.ok) { const folders = r.data.folders||[]; 
  const lessons = r.data.lessons||[]; 
  return showRecycleList(folders, lessons); 

} 
const fallbackFolders = await fetchJson('/api/lessons/folders?deleted=1', { 
  headers: authHeaders(), method: 'GET' }); 

const fallbackLessons = await fetchJson('/api/lessons?deleted=1', { 
  headers: authHeaders(), method: 'GET' }); 
  if ((fallbackFolders.ok && (Array.isArray
  (fallbackFolders.data) || Array.isArray(fallbackFolders.data.folders)))
   || (fallbackLessons.ok && (Array.isArray(fallbackLessons.data) 
   || Array.isArray(fallbackLessons.data.lessons)))) {
     const folders = (fallbackFolders.ok && Array.isArray(fallbackFolders.data)) ? fallbackFolders.data : (fallbackFolders.ok && fallbackFolders.data && fallbackFolders.data.folders) ? fallbackFolders.data.folders : []; 
     const lessons = (fallbackLessons.ok && Array.isArray(fallbackLessons.data)) ? fallbackLessons.data : (fallbackLessons.ok && fallbackLessons.data && fallbackLessons.data.lessons) ? fallbackLessons.data.lessons : [];
   return showRecycleList(folders, lessons); 
  } const scanned = collectDeletedFromTree(treeCache); 
if (scanned.folders.length || scanned.lessons.length) { return showRecycleList(scanned.folders, scanned.lessons, { source: 'local' });
 } 
 const html = `<h3>Recycle Bin ‚Äî Error</h3><div class="muted-note">Could not load recycle bin: ${escapeHtml(String(r.error || r.rawText || 'Server error'))}</div><div style="margin-top:10px" class="muted-note">Server responses (for debugging):<pre style="white-space:pre-wrap">${escapeHtml(JSON.stringify({r, fallbackFolders, fallbackLessons}, null, 2))}</pre></div><div style="display:flex;gap:8px;margin-top:12px"><button id="retryRecycle">Retry</button><button id="showLocal" class="small-btn">Show locally-deleted</button><button id="closeRecycle" class="btn-ghost">Close</button></div>`; showModal(html); 
document.getElementById('retryRecycle').onclick = ()=>{ closeModal(); openRecycleModal(); }; 
document.getElementById('showLocal').onclick = ()=>{ closeModal(); const s = collectDeletedFromTree(treeCache); showRecycleList(s.folders, s.lessons, { source: 'local' }); }; 
document.getElementById('closeRecycle').onclick = closeModal; }
function collectDeletedFromTree(nodes){ const folders=[]; 
  const lessons=[]; function walk(n){ 
    if (!n) return; 
    if (n.isDeleted) folders.push(n); 
    if (Array.isArray(n.lessons)) for (const l of n.lessons) 
    if (l.isDeleted) lessons.push(l); 
    if (Array.isArray(n.children)) for (const c of n.children) walk(c); 
    
  } if (Array.isArray(nodes)) for (const n of nodes) walk(n); else walk(nodes); return { folders, lessons }; }

// ---------------- RECYLCE UI (client) ----------------


function showRecycleList(folders, lessons, opts = {}) {
  let sourceNote = opts && opts.source ? ` (source: ${opts.source})` : '';
  let html = `<h3>Recycle Bin${sourceNote}</h3><div style="max-height:55vh;overflow:auto">`;

  html += `<h4>Folders (${folders.length})</h4>`;
  folders.forEach(f => {
    const displayName = tLocalized(f.name) || (typeof f.name === 'string' ? f.name : '');
    html += `<div style="display:flex;justify-content:space-between;align-items:center;padding:6px;border-bottom:1px solid #eee">
      <div>
        <strong>${escapeHtml(displayName)}</strong>
        <div class="muted-note" style="font-size:12px">${escapeHtml(String(f._id))}</div>
      </div>
      <div style="display:flex;gap:6px">
        <button class="small-btn recycle-restore" data-id="${f._id}" data-type="folder">Restore</button>
        <button class="small-btn recycle-delete" data-id="${f._id}" data-type="folder">Delete permanently</button>
      </div>
    </div>`;
  });

  html += `<h4>Lessons (${lessons.length})</h4>`;
  lessons.forEach(l => {
    const title = tLocalized(l.title) || (l.title && l.title.en) || (typeof l.title === 'string' ? l.title : 'Untitled');
    html += `<div style="display:flex;justify-content:space-between;align-items:center;padding:6px;border-bottom:1px solid #eee">
      <div>
        <strong>${escapeHtml(title)}</strong>
        <div class="muted-note" style="font-size:12px">${escapeHtml(String(l._id))}</div>
      </div>
      <div style="display:flex;gap:6px">
        <button class="small-btn recycle-restore" data-id="${l._id}" data-type="lesson">Restore</button>
        <button class="small-btn recycle-delete" data-id="${l._id}" data-type="lesson">Delete permanently</button>
      </div>
    </div>`;
  });

  html += `</div>
    <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
      <button id="closeRecycle" class="btn-ghost">Close</button>
    </div>`;

  showModal(html);

  document.getElementById('closeRecycle').onclick = closeModal;

  // restore buttons
  document.querySelectorAll('.recycle-restore').forEach(b => {
    b.onclick = async (ev) => {
      const id = b.dataset.id;
      const type = b.dataset.type;
      if (!confirm('Restore this item?')) return;
      const ok = await tryRestoreItem(type, id);
      if (!ok) return alert('Restore failed (server). See console.');
      alert('Restored');
      closeModal();
      await loadTree();
    };
  });

  // permanent delete buttons
  document.querySelectorAll('.recycle-delete').forEach(b => {
    b.onclick = async (ev) => {
      const id = b.dataset.id;
      const type = b.dataset.type;
      if (!confirm('Permanently delete this item? This cannot be undone.')) return;
      try {
        if (type === 'folder') {
          const rr = await fetchJson(`/api/lessons/folders/${encodeURIComponent(id)}?permanent=1`, { method: 'DELETE', headers: authHeaders() });
          if (!rr.ok) return alert('Delete failed: ' + (rr.error || 'Server error'));
        } else {
          const rr = await fetchJson(`/api/lessons/${encodeURIComponent(id)}?permanent=1`, { method: 'DELETE', headers: authHeaders() });
          if (!rr.ok) return alert('Delete failed: ' + (rr.error || 'Server error'));
        }
        alert('Permanently deleted');
        closeModal();
        await loadTree();
      } catch (err) {
        console.error('permanent delete failed', err);
        alert('Delete failed (see console).');
      }
    };
  });
}

async function tryRestoreItem(type,id){ try { if (type==='folder'){ let rr=await fetchJson(`/api/lessons/folders/${encodeURIComponent(id)}/restore`,{ method:'POST', headers: authHeaders() }); if (rr.ok) return true; rr=await fetchJson(`/api/lessons/folders/${encodeURIComponent(id)}`,{ method:'PUT', 
headers: authHeaders(), body: JSON.stringify({ isDeleted:false }) }); if (rr.ok) return true; } else { let rr=await fetchJson(`/api/lessons/${encodeURIComponent(id)}/restore`,{ method:'POST', headers: authHeaders() }); 
if (rr.ok) return true; rr=await fetchJson(`/api/lessons/${encodeURIComponent(id)}`,{ method:'PUT', headers: authHeaders(), body: JSON.stringify({ isDeleted:false }) }); 
if (rr.ok) return true; } console.warn('Restore endpoints returned errors.'); return false;
 } catch(err){ console.error('Restore attempt failed', err); 
 return false; 

} }

/* ===================== UTILITIES ===================== */
function escapeHtml(s){ if (s === 0) return '0'; if (!s) return ''; return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m])); }
function pickIconForName(name){ if (!name) return 'üìÅ'; const n=name.toLowerCase(); if (n.includes('math') || n.includes('xisaab')) return 'üßÆ'; if (n.includes('computer')||n.includes('cs')||n.includes('program')||n.includes('kombuter')) return 'üíª'; if (n.includes('network')) return 'üåê'; if (n.includes('basic')||n.includes('aas')) return 'üî∞'; if (n.includes('advanced')||n.includes('mediate')||n.includes('horumarsan')) return 'üöÄ'; if (n.includes('science')) return 'üî¨'; if (n.includes('english')||n.includes('language')) return 'üìö'; return 'üìÅ'; }



/* ---------- Config & helpers ---------- */
const MIN_WITHDRAW = 30.0;
const WITHDRAWAL_24H_CAP = 100.0; // client-side UX cap

  /* helper: strict money format for summary (2 decimals) */
  function moneyFmt2(n){ return '$' + Number(n || 0).toFixed(2); }

/* safe extractor: cope with many response shapes for withdrawals */
function extractWithdrawals(resNormalized) {
  // resNormalized is what normalizeApiResponse returns (or raw fetchJson envelope)
  if (!resNormalized) return [];
  // if normalizeApiResponse returned error
  if (resNormalized.ok === false) return [];

  // try several common locations:
  // 1) normalizeApiResponse returned { ok:true, data: { withdrawals: [...] } }
  if (resNormalized.data && Array.isArray(resNormalized.data.withdrawals)) return resNormalized.data.withdrawals;

  // 1b) double-nested data.data.withdrawals (some servers)
  if (resNormalized.data && resNormalized.data.data && Array.isArray(resNormalized.data.data.withdrawals)) return resNormalized.data.data.withdrawals;

  // 2) some responses are plain { withdrawals: [...] } (not inside data)
  if (Array.isArray(resNormalized.withdrawals)) return resNormalized.withdrawals;
  if (resNormalized.data && Array.isArray(resNormalized.data)) return resNormalized.data;

  // 3) raw fetchJson envelope: { ok:true, data: <payload> } where payload may be withdrawals
  if (resNormalized.data && (Array.isArray(resNormalized.data) || Array.isArray(resNormalized.data.withdrawals))) {
    return Array.isArray(resNormalized.data) ? resNormalized.data : resNormalized.data.withdrawals;
  }

  // 4) last resort: if resNormalized itself is an array
  if (Array.isArray(resNormalized)) return resNormalized;

  return [];
}

function moneyFmt(n){ return '$' + (Number(n||0)).toFixed(3); }
function numFmt(n){ return (Number(n||0)).toLocaleString(); }

function getToken(){ return (window.Auth && window.Auth.getToken) ? window.Auth.getToken() : localStorage.getItem('token'); }
function getUser(){ return (window.Auth && window.Auth.getUser) ? window.Auth.getUser() : (()=>{ const s=localStorage.getItem('user'); return s?JSON.parse(s):null; })(); }
function isAdmin(){ const u=getUser(); return u && u.role==='admin'; }
function authHeaders(json=true){
  const t=getToken();
  const h = {};
  if (t) h['Authorization']='Bearer '+t;
  if (json) h['Content-Type']='application/json';
  return h;
}





/* ---------- Robust helper: computeWithdrawCount24 (replace old) ----------
   Counts requests made in the last 24h (based on requestedAt/createdAt/ObjectId timestamp).
   Returns { count, nextAllowedAtIso } where nextAllowedAtIso is the earliest time when
   the count will drop below `limit`. */
   function computeWithdrawCount24(list = [], limit = 5) {
  try {
    const now = Date.now();
    const windowStart = now - 24 * 3600 * 1000;

    const recent = (list || [])
      .map(w => {
        // normalize timestamp extraction carefully
        let ts = 0;
        try {
          if (w.requestedAt) ts = new Date(w.requestedAt).getTime();
          else if (w.createdAt) ts = new Date(w.createdAt).getTime();
          else if (w._id && typeof w._id.getTimestamp === 'function') ts = w._id.getTimestamp().getTime();
          else if (typeof w._id === 'string' && w._id.length === 24) {
            // best-effort: try to decode ObjectId hex timestamp (first 4 bytes)
            try {
              const hex = w._id.slice(0, 8);
              ts = parseInt(hex, 16) * 1000;
            } catch(e){ ts = 0; }
          }
        } catch (e) {
          ts = 0;
        }
        return { ts: ts || 0, w };
      })
      .filter(x => x.ts && x.ts >= windowStart && x.ts <= now)
      .sort((a, b) => a.ts - b.ts); // ascending

    const count = recent.length;
    let nextAllowedAtIso = null;
    if (count >= limit && recent.length) {
      // earliest index that will expire to bring count below limit
      const idx = Math.max(0, recent.length - limit);
      const earliestTs = recent[idx].ts;
      nextAllowedAtIso = new Date(earliestTs + 24 * 3600 * 1000).toISOString();
    }
    return { count, nextAllowedAtIso };
  } catch (e) {
    return { count: 0, nextAllowedAtIso: null };
  }
}

/**
 * computeWithdrawalStats(list, cap)
 * - list: array of withdrawal objects (may include fields: amount, status, requestedAt, createdAt, verifiedAt)
 * - cap: numeric 24h cap
 *
 * returns {
 *   spent24, pending24, remainingVerified, remainingIncludingPending, nextAllowedAtIso
 * }
 */


 // compute 24h totals from a withdrawals list (client-side authoritative UI)
function compute24WindowTotals(list = [], cap = (typeof WITHDRAWAL_24H_CAP !== 'undefined' ? WITHDRAWAL_24H_CAP : 100), requestLimit = 5) {
  try {
    const now = Date.now();
    const since = now - 24 * 3600 * 1000;
    const verifiedRecent = [];
    const pendingRecent = [];
    const requestedRecent = [];

    (list || []).forEach(w => {
      if (!w) return;
      const status = String((w.status || '')).toLowerCase();
      // requestedAt fallback: requestedAt || createdAt || ObjectId timestamp
      let reqTs = 0;
      if (w.requestedAt) reqTs = (new Date(w.requestedAt)).getTime();
      else if (w.createdAt) reqTs = (new Date(w.createdAt)).getTime();
      else if (w._id && typeof w._id.getTimestamp === 'function') {
        try { reqTs = w._id.getTimestamp().getTime(); } catch (e) { reqTs = 0; }
      }
      const verTs = w.verifiedAt ? (new Date(w.verifiedAt)).getTime() : null;

      if (reqTs && reqTs >= since && reqTs <= now) requestedRecent.push({ ts: reqTs, w });
      if (status === 'pending' && reqTs && reqTs >= since && reqTs <= now) pendingRecent.push({ ts: reqTs, amount: safeNum(w.amount) });
      if (status === 'verified' && verTs && verTs >= since && verTs <= now) verifiedRecent.push({ ts: verTs, amount: safeNum(w.amount) });
    });

    const spent24 = verifiedRecent.reduce((s, r) => s + (r.amount || 0), 0);
    const pending24 = pendingRecent.reduce((s, r) => s + (r.amount || 0), 0);
    const requestCount24 = requestedRecent.length;

    const remainingVerified = Math.max(0, cap - spent24);
    const remainingIncludingPending = Math.max(0, cap - (spent24 + pending24));

    // nextAllowedAt (money cap): earliest event among verified/pending within window -> +24h
    let nextAllowedAt = null;
    const combinedTs = [];
    verifiedRecent.forEach(r => combinedTs.push(r.ts));
    pendingRecent.forEach(r => combinedTs.push(r.ts));
    combinedTs.sort((a, b) => a - b);
    if ((spent24 + pending24) >= cap || spent24 >= cap) {
      if (combinedTs.length) {
        nextAllowedAt = new Date(combinedTs[0] + 24 * 3600 * 1000).toISOString();
      }
    }

    // nextRequestAllowedAt (count limit)
    let nextRequestAllowedAt = null;
    if (requestCount24 >= requestLimit && requestedRecent.length) {
      requestedRecent.sort((a, b) => a.ts - b.ts);
      // index that will expire earliest so count < limit
      const idx = Math.max(0, requestedRecent.length - requestLimit);
      const earliestToExpire = requestedRecent[idx];
      if (earliestToExpire && earliestToExpire.ts) {
        nextRequestAllowedAt = new Date(earliestToExpire.ts + 24 * 3600 * 1000).toISOString();
      }
    }

    return {
      spent24: Number(spent24.toFixed(3)),
      pending24: Number(pending24.toFixed(3)),
      remainingVerified: Number(remainingVerified.toFixed(3)),
      remainingIncludingPending: Number(remainingIncludingPending.toFixed(3)),
      requestCount24,
      nextAllowedAt,
      nextRequestAllowedAt
    };
  } catch (e) {
    return {
      spent24: 0,
      pending24: 0,
      remainingVerified: Number((cap).toFixed(3)),
      remainingIncludingPending: Number((cap).toFixed(3)),
      requestCount24: 0,
      nextAllowedAt: null,
      nextRequestAllowedAt: null
    };
  }
}


 function computeWithdrawalStats(list = [], cap = WITHDRAWAL_24H_CAP) {
  const now = Date.now();
  const windowStart = now - 24 * 3600 * 1000;

  // normalize and filter by relevant timestamps
  const verifieds = (list || [])
    .filter(w => _statusLower(w.status) === 'verified')
    .map(w => ({ amount: safeNum(w.amount), ts: (new Date(w.verifiedAt || w.updatedAt || w.createdAt || w.requestedAt || 0)).getTime() }))
    .filter(w => w.ts && w.ts >= windowStart && w.ts <= now)
    .sort((a,b) => a.ts - b.ts); // ascending by time

  const pendings = (list || [])
    .filter(w => _statusLower(w.status) === 'pending')
    .map(w => ({ amount: safeNum(w.amount), ts: (new Date(w.requestedAt || w.createdAt || 0)).getTime() }))
    .filter(w => w.ts && w.ts >= windowStart && w.ts <= now);

  const spent24 = verifieds.reduce((s, w) => s + w.amount, 0);
  const pending24 = pendings.reduce((s, w) => s + w.amount, 0);

  const remainingVerified = Math.max(0, cap - spent24);
  const remainingIncludingPending = Math.max(0, cap - (spent24 + pending24));

  // compute nextAllowedAtIso: the earliest expiry of verifieds such that after that expiry spent24 < cap
  let nextAllowedAtIso = null;
  if (spent24 >= cap && verifieds.length) {
    // total spent in window
    const total = spent24;
    // prefix sums of verified amounts
    let prefix = 0;
    for (let i = 0; i < verifieds.length; i++) {
      // consider the moment when verifieds[i] expires (verifieds[i].ts + 24h)
      prefix += verifieds[i].amount;
      const remainingAfterExpiry = total - prefix; // spent after this earliest item expires
      if (remainingAfterExpiry < cap) {
        // earliest time where cap will no longer be reached is verifieds[i].ts + 24h
        nextAllowedAtIso = new Date(verifieds[i].ts + 24*3600*1000).toISOString();
        break;
      }
    }
    // if loop ends without break, set it to last verified expiry (fallback)
    if (!nextAllowedAtIso) {
      const lastTs = verifieds[verifieds.length - 1].ts;
      nextAllowedAtIso = new Date(lastTs + 24*3600*1000).toISOString();
    }
  }

  return {
    spent24,
    pending24,
    remainingVerified,
    remainingIncludingPending,
    nextAllowedAtIso
  };
}


/* safe wrapper for low-level fetchJson */
async function fetchJson(path, opts={}) {
  try {
    const url = path.startsWith('http') ? path : ( (typeof API_BASE === 'string' && API_BASE) ? API_BASE + path : path );
    const res = await fetch(url, opts);
    const text = await res.text();
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch(e) { data = null; }
    if (!res.ok) {
      return { ok:false, status: res.status, error: (data && (data.error||data.message)) ? (data.error||data.message) : res.statusText, data, rawText: text };
    }
    return { ok:true, status: res.status, data, rawText: text };
  } catch (err) {
    return { ok:false, error: err.message || 'Network error' };
  }
}

async function safeFetchJson(url, opts={}) {
  try {
    return await fetchJson(url, opts);
  } catch (err) {
    console.error('safeFetchJson error', url, err);
    return { ok: false, error: err && err.message ? err.message : 'Network error' };
  }
}

/**
 * normalizeApiResponse(res)
 * Produces a single shape:
 *   { ok: true, data: {...} } or { ok:false, error: '...' }
 *
 * Supports:
 * - fetchJson envelope: { ok:true, data: <apiBody> }
 * - api body envelope: { ok:true, data: {...} }
 * - legacy body: { balance:..., user:... }
 * - error shapes: { ok:false, error:... } or { error:... }
 */

/* safer normalizeApiResponse (handles server envelopes like { ok:true, withdrawals: [...] } ) */
function normalizeApiResponse(res) {
  if (!res) return { ok: false, error: 'No response' };

  // If res is the fetchJson envelope (it has boolean ok)
  if (typeof res.ok === 'boolean') {
    if (!res.ok) {
      const err = res.error || (res.data && (res.data.error || res.data.message)) || 'Network or server error';
      return { ok: false, error: err };
    }

    // payload is the server response body (res.data)
    const payload = res.data || {};

    // If server returned its own envelope { ok: boolean, ... } we should accept other keys
    if (typeof payload.ok === 'boolean') {
      if (!payload.ok) {
        return { ok: false, error: payload.error || payload.message || 'Server error' };
      }
      // Prefer returning payload.data if present (legacy).
      // If payload contains meaningful fields like withdrawals/balance/user etc, return payload itself.
      if (payload.data && (typeof payload.data === 'object')) {
        return { ok: true, data: payload.data };
      }
      // If payload has known top-level fields, return payload as data (fix for your server shape)
      const knownFields = ['withdrawals','balance','user','spent24','remaining','cap','nextAllowedAt','convertedPoints','addedDollar'];
      for (const k of knownFields) {
        if (Object.prototype.hasOwnProperty.call(payload, k)) {
          return { ok: true, data: payload };
        }
      }
      // Nothing known - return empty data object
      return { ok: true, data: {} };
    }

    // Legacy shapes: top-level fields directly (payload has withdrawals,balance,user etc)
    if (payload.withdrawals || payload.balance || payload.user || payload.convertedPoints !== undefined || payload.addedDollar !== undefined) {
      return { ok: true, data: payload };
    }

    // Fallback: return payload as data
    return { ok: true, data: payload };
  }

  // If res doesn't have boolean ok (rare): treat as server data
  if (typeof res === 'object') {
    if (res.error || res.message) return { ok: false, error: res.error || res.message };
    if (res.balance || res.user || res.data) return { ok: true, data: res.data || res };
    return { ok: true, data: res };
  }

  return { ok: false, error: 'Unexpected response shape' };
}

/* safe extractor for withdrawals (robust) */
function extractWithdrawals(resNormalized) {
  if (!resNormalized) return [];
  if (resNormalized.ok === false) return [];
  // normalized shape -> r.data may hold fields
  const d = resNormalized.data || {};
  if (Array.isArray(d.withdrawals)) return d.withdrawals;
  if (Array.isArray(resNormalized.withdrawals)) return resNormalized.withdrawals;
  if (Array.isArray(d)) return d;
  return [];
}

/* animate number with easing */
function animateNumber({ el, start = 0, end = 0, duration = 1200, decimals = 0, onFrame = null }) {
  const startTime = performance.now();
  const easeOut = t => 1 - Math.pow(1 - t, 3);
  return new Promise(resolve => {
    function step(now) {
      const t = Math.min(1, (now - startTime) / duration);
      const v = start + (end - start) * easeOut(t);
      const display = (decimals === 0) ? Math.round(v) : v.toFixed(decimals);
      el.textContent = display;
      if (onFrame) onFrame(v);
      if (t < 1) requestAnimationFrame(step);
      else resolve();
    }
    requestAnimationFrame(step);
  });
}


// ---------- Withdraw-count helper ----------
// Count how many withdrawal *requests* (any status) were made in last 24h.
// Returns { count, nextAllowedAtIso } where nextAllowedAtIso is the earliest time
// when count will drop below `limit` (i.e. when user can make another request).
function computeWithdrawCount24(list = [], limit = 5) {
  try {
    const now = Date.now();
    const windowStart = now - 24 * 3600 * 1000;
    const recent = (list || [])
      .map(w => {
        const ts = new Date(w.requestedAt || w.createdAt || w._id && w._id.getTimestamp && w._id.getTimestamp() || 0).getTime();
        return { ts: ts || 0 };
      })
      .filter(x => x.ts && x.ts >= windowStart && x.ts <= now)
      .sort((a, b) => a.ts - b.ts); // ascending by time

    const count = recent.length;
    let nextAllowedAtIso = null;
    if (count >= limit && recent.length) {
      // find index i such that after recent[i] expires, count < limit
      // earliest expiry index = recent.length - limit
      const idx = Math.max(0, recent.length - limit);
      const earliestTs = recent[idx].ts;
      nextAllowedAtIso = new Date(earliestTs + 24 * 3600 * 1000).toISOString();
    }
    return { count, nextAllowedAtIso };
  } catch (e) {
    return { count: 0, nextAllowedAtIso: null };
  }
}

/* ---------- Utilities (add/replace) ---------- */

function parseApiArray(resp, key) {
  // Try multiple shapes where the array may live
  if (!resp) return [];
  if (resp.data && Array.isArray(resp.data[key])) return resp.data[key];
  if (Array.isArray(resp.data)) return resp.data;
  if (Array.isArray(resp[key])) return resp[key];
  if (resp.data && Array.isArray(resp.data.withdrawals) && key === 'withdrawals') return resp.data.withdrawals;
  return [];
}

function safeNum(v) { const n = Number(v); return Number.isFinite(n) ? n : 0; }

function formatHHMMSS(ms) {
  if (ms <= 0) return '00:00:00';
  const s = Math.floor(ms / 1000);
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = s % 60;
  return `${String(h).padStart(2,'0')}h:${String(m).padStart(2,'0')}m:${String(sec).padStart(2,'0')}s`;
}

function playTick() {
  try {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return; // no audio supported

    const ctx = new Ctx();
    // resume if suspended (some browsers require user interaction)
    if (ctx.state === 'suspended' && typeof ctx.resume === 'function') {
      ctx.resume().catch(()=>{ /* silent */ });
    }

    Promise.resolve(ctx.resume()).then(() => {
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.value = 900;
      // tiny ramp to avoid pops
      g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.06, ctx.currentTime + 0.01);
      o.connect(g); g.connect(ctx.destination);
      o.start();
      setTimeout(()=>{
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.04);
        setTimeout(()=>{ try { o.stop(); ctx.close(); } catch(e){} }, 60);
      }, 80);
    }).catch(()=>{/* ignore resume failures */});
  } catch(e) {
    // ignore audio errors
  }
}

/* local conversion history */
const LOCAL_CONV_KEY = 'app_convert_history_v1';
function saveConvertHistory(entry) {
  try {
    const list = JSON.parse(localStorage.getItem(LOCAL_CONV_KEY) || '[]');
    list.unshift(entry);
    localStorage.setItem(LOCAL_CONV_KEY, JSON.stringify(list.slice(0,200)));
  } catch(e){}
}
function loadConvertHistory() {
  try { return JSON.parse(localStorage.getItem(LOCAL_CONV_KEY) || '[]'); } catch(e) { return []; }
}



function _normalizeWithdrawListShape(rawRes) {
  // returns array of withdrawals (safe)
  try {
    const nr = normalizeApiResponse(rawRes);
    if (!nr.ok) return [];
    const d = nr.data || {};
    if (Array.isArray(d.withdrawals)) return d.withdrawals;
    if (Array.isArray(d)) return d;
    // some responses: { withdrawals: [...] } at top-level inside fetch envelope
    if (Array.isArray(rawRes.data && rawRes.data.withdrawals)) return rawRes.data.withdrawals;
    if (Array.isArray(rawRes.withdrawals)) return rawRes.withdrawals;
  } catch(e){}
  return [];
}

function _statusLower(v){
  try { return (v||'').toString().toLowerCase(); } catch(e){ return ''; }
}



async function openConvertModal(){
  const raw = await safeFetchJson('/api/account/balance', { headers: authHeaders() });
  const r = normalizeApiResponse(raw);
  if (!r.ok) return alert(r.error || 'Failed to load');

  const pts = Number((r.data && r.data.balance && r.data.balance.pointsCurrent) || 0);
  const estAll = pts * 0.003;

  const html = `
    <div class="balance-modal">
      <h3>Convert Points</h3>
      <div style="margin-top:8px">
        <div class="small-muted">Points available</div>
        <div style="font-weight:700; font-size:18px">${numFmt(pts)}</div>
        <div class="small-muted" style="margin-top:6px">If convert all ‚Üí ${moneyFmt(estAll)}</div>
        <label style="display:block;margin-top:12px">Points to convert (leave blank to convert all)</label>
        <input id="conv_points" type="number" min="0" placeholder="${pts}" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button id="conv_cancel" class="btn-ghost">Cancel</button>
          <button id="conv_do" class="btn">Convert</button>
        </div>
        <div class="small-muted" style="margin-top:8px">Note: Minimum 100 points required to convert.</div>
      </div>
    </div>
  `;
  showModal(html);
  document.getElementById('conv_cancel').onclick = closeModal;
  document.getElementById('conv_do').onclick = async () => {
    const pVal = (document.getElementById('conv_points').value || '').trim();
    const toConvert = pVal ? Number(pVal) : pts;
    if (!Number.isFinite(toConvert) || toConvert <= 0) return alert('Enter points to convert');
    if (toConvert < 100) return alert('Minimum 100 points required to convert to dollars.');
    if (toConvert > pts) return alert('You do not have that many points.');

    const rawRes = await safeFetchJson('/api/account/convert', {
      method: 'POST',
      headers: authHeaders(true),
      body: JSON.stringify({ points: toConvert })
    });
    const res = normalizeApiResponse(rawRes);
    if (!res.ok) return alert(res.error || 'Convert failed');

    const convertedPoints = (res.data && (res.data.convertedPoints !== undefined)) ? res.data.convertedPoints : toConvert;
    const addedDollar = (res.data && (res.data.addedDollar !== undefined)) ? res.data.addedDollar : (convertedPoints * 0.003);

    saveConvertHistory({
      id: 'conv_' + Date.now(),
      requestedAt: new Date().toISOString(),
      points: Number(convertedPoints),
      dollars: Number(addedDollar),
      serverResponse: res.data || {}
    });

    alert('Converted: ' + numFmt(convertedPoints) + ' points ‚Üí ' + moneyFmt(addedDollar));
    closeModal();
    if (typeof applyNavUI === 'function') applyNavUI();
  };
}

async function openConvertBackModal(){
  const raw = await safeFetchJson('/api/account/balance', { headers: authHeaders() });
  const r = normalizeApiResponse(raw);
  if (!r.ok) return alert(r.error || 'Failed to load');

  const balanceDollar = Number((r.data && r.data.balance && r.data.balance.balanceDollar) || 0);
  const estPoints = Math.floor(balanceDollar / 0.003);

  const html = `
    <div class="balance-modal">
      <h3>Convert Dollars ‚Üí Points</h3>
      <div style="margin-top:8px">
        <div class="small-muted">Dollar balance</div>
        <div style="font-weight:700; font-size:18px">${moneyFmt(balanceDollar)}</div>
        <div class="small-muted" style="margin-top:6px">Estimate points if converting all: ${numFmt(estPoints)}</div>
        <label style="display:block;margin-top:12px">Amount to convert (leave blank to convert all)</label>
        <input id="convback_amount" type="number" min="0" placeholder="${moneyFmt(balanceDollar)}" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button id="convback_cancel" class="btn-ghost">Cancel</button>
          <button id="convback_do" class="btn">Convert to Points</button>
        </div>
        <div class="small-muted" style="margin-top:8px">Server endpoint: POST /api/account/convert-back</div>
      </div>
    </div>
  `;
  showModal(html);
  document.getElementById('convback_cancel').onclick = closeModal;
  document.getElementById('convback_do').onclick = async () => {
    const amtRaw = (document.getElementById('convback_amount').value || '').trim();
    const payload = {};
    if (amtRaw) payload.amount = Number(amtRaw);

    const rawRes = await safeFetchJson('/api/account/convert-back', {
      method: 'POST',
      headers: authHeaders(true),
      body: JSON.stringify(payload)
    });
    const res = normalizeApiResponse(rawRes);
    if (!res.ok) return alert(res.error || 'Server does not support convert-back.');

    saveConvertHistory({
      id: 'convback_' + Date.now(),
      requestedAt: new Date().toISOString(),
      points: (res.data && res.data.addedPoints) || 0,
      dollars: -((res.data && res.data.deductedDollar) || (payload.amount || 0)),
      serverResponse: res.data || {}
    });
    alert('Converted dollars to points successfully.');
    closeModal();
  };
}

async function openBalanceModal(){
  // load balance + summary + withdrawals concurrently
  const [rawBal, rawSummary, rawList] = await Promise.all([
    safeFetchJson('/api/account/balance', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdrawals', { headers: authHeaders() })
  ]);

  const balRes = normalizeApiResponse(rawBal);
  if (!balRes.ok) {
    if (!getToken()) return alert('No authorization token found ‚Äî please log in.');
    return alert(balRes.error || 'Failed to load balance');
  }

  const b = (balRes.data && balRes.data.balance) ? balRes.data.balance : {};
  const user = (balRes.data && balRes.data.user) ? balRes.data.user : getUser() || {};
  const points = Number(b.pointsCurrent || 0);
  const balanceDollar = Number(b.balanceDollar || 0);

  const sumRes = normalizeApiResponse(rawSummary);

  // --- Normalize canonical withdrawals list robustly (cover shapes)
  let list = _normalizeWithdrawListShape(rawList);
  if (!Array.isArray(list)) {
    // fallback attempts
    if (Array.isArray(rawList)) list = rawList;
    else if (rawList && rawList.data && Array.isArray(rawList.data.withdrawals)) list = rawList.data.withdrawals;
    else if (rawList && Array.isArray(rawList.data)) list = rawList.data;
    else if (rawList && Array.isArray(rawList.withdrawals)) list = rawList.withdrawals;
    else list = [];
  }

  // compute totals from list client-side (reliable for UI)
  const capFromServer = (sumRes && sumRes.data && sumRes.data.cap) ? Number(sumRes.data.cap) : WITHDRAWAL_24H_CAP;
  const computedTotals = compute24WindowTotals(list || [], capFromServer, 5) || {};

  // prefer computedTotals then server summary then safe defaults
  const capVal = capFromServer;
  const spent24 = (typeof computedTotals.spent24 === 'number') ? computedTotals.spent24 :
                  ((sumRes && sumRes.data && typeof sumRes.data.spent24 === 'number') ? Number(sumRes.data.spent24) : 0);
  const pending24 = (typeof computedTotals.pending24 === 'number') ? computedTotals.pending24 :
                    ((sumRes && sumRes.data && typeof sumRes.data.pending24 === 'number') ? Number(sumRes.data.pending24) : 0);

  const remainingVerified = (typeof computedTotals.remainingVerified === 'number') ? computedTotals.remainingVerified :
                            ((sumRes && sumRes.data && sumRes.data.remainingVerified !== undefined) ? Number(sumRes.data.remainingVerified) : Math.max(0, capVal - spent24));
  const remainingIncludingPending = (typeof computedTotals.remainingIncludingPending === 'number') ? computedTotals.remainingIncludingPending :
                                     ((sumRes && sumRes.data && sumRes.data.remainingIncludingPending !== undefined) ? Number(sumRes.data.remainingIncludingPending) : Math.max(0, capVal - (spent24 + pending24)));

  // COUNT logic: prefer server summary.requestCount24 when present,
  // otherwise prefer computedTotals.requestCount24 (from list),
  // otherwise fallback to computeWithdrawCount24(list)
  const serverRequestCount = (sumRes && sumRes.data && typeof sumRes.data.requestCount24 === 'number') ? Number(sumRes.data.requestCount24) : null;
  const serverNextRequestAllowed = (sumRes && sumRes.data && sumRes.data.nextRequestAllowedAt) ? sumRes.data.nextRequestAllowedAt : null;

  const localCountInfo = computeWithdrawCount24(list || [], 5) || { count: 0, nextAllowedAtIso: null };
  const count24 = (serverRequestCount !== null) ? serverRequestCount :
                  ((typeof computedTotals.requestCount24 === 'number') ? computedTotals.requestCount24 : localCountInfo.count);

  const nextAllowedAtIsoCount = serverNextRequestAllowed || computedTotals.nextRequestAllowedAt || localCountInfo.nextAllowedAtIso || null;

  // nextAllowedAt for money cap (prefer computedTotals then server)
  const nextAllowedAtIsoMoney = computedTotals.nextAllowedAt || (sumRes && sumRes.data && sumRes.data.nextAllowedAt) || null;

  // withdraw disabled if money cap exhausted OR count cap reached
  const withdrawDisabled = (remainingIncludingPending <= 0 && !(safeNum(spent24) === 0 && safeNum(pending24) === 0)) || (count24 >= 5);

  // --- Build UI HTML (unchanged)
  const html = `
    <div class="balance-modal" role="dialog" aria-modal="true" aria-labelledby="bal_title">
      <h3 id="bal_title">Your Balance</h3>
      <div class="balance-user">
        <div class="balance-avatar">${escapeHtml((user.fullName||user.username||'U').slice(0,2)).toUpperCase()}</div>
        <div style="flex:1">
          <div style="font-weight:700">${escapeHtml(user.fullName || user.username || '')}</div>
          <div class="small-muted">${escapeHtml(user.email || '')}</div>
        </div>
      </div>

      <div class="balance-row" style="margin-top:14px">
        <div class="balance-col">
          <div class="small-muted">Points</div>
          <div class="counter" id="bal_points">0</div>
          <div class="counter-sub">Current points</div>
        </div>
        <div style="width:14px"></div>
        <div class="balance-col" style="text-align:right">
          <div class="small-muted">Dollar Balance</div>
          <div class="counter" id="bal_dollars">0.000</div>
          <div class="counter-sub">Available dollars</div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div id="bal_remaining_box" class="small-muted"></div>
      </div>

      <div class="btn-row" style="margin-top:8px">
        <button id="bal_convert" class="btn-ghost small-cta">Convert Points ‚Üí $</button>
        <button id="bal_withdraw" class="btn small-cta btn-withdraw" style="background:#2563eb;color:#fff;border-color:#2563eb" ${withdrawDisabled ? 'disabled' : ''}>Withdraw</button>
        <button id="bal_requests" class="btn-ghost small-cta">My Requests</button>
        <button id="bal_close" class="btn-ghost small-cta">Close</button>
      </div>
      <div class="small-muted" style="margin-top:6px">
        Tip: convert only if you have at least 100 points. Withdrawals require at least $${MIN_WITHDRAW} available and max $${WITHDRAWAL_24H_CAP} verified per 24 hours.
      </div>
    </div>
  `;
  showModal(html);

  // render remaining box with both money and count information + live countdowns
  const remBox = document.getElementById('bal_remaining_box');
  let balCountdown = null;
  function clearBalCountdown(){ if (balCountdown) { clearInterval(balCountdown); balCountdown = null; } }

  const renderRemainingBox = () => {
    let out = `<div style="margin-bottom:6px">Withdrawals in last 24h: <strong>${count24}/5</strong></div>`;

    if ((safeNum(spent24) + safeNum(pending24)) <= 0) {
      out += `<div style="color:#15803d;font-weight:700">Remaining verified allowance in last 24h: <strong>$${Number(capVal).toFixed(3)}</strong></div>`;
    } else if (remainingIncludingPending > 0) {
      out += `<div>24h used: <strong>${moneyFmt(spent24)}</strong> ‚Ä¢ pending: <strong>${moneyFmt(pending24)}</strong></div>
              <div>Remaining (including pending): <strong>$${Number(remainingIncludingPending).toFixed(3)}</strong></div>`;
    } else {
      out += `<div style="color:#b91c1c;font-weight:700">Remaining (including pending): $0.000 (cap reached)</div>`;
    }

    remBox.innerHTML = out;

    if (count24 >= 5) {
      const box = document.createElement('div');
      box.style.marginTop = '6px';
      box.style.color = '#b91c1c';
      box.style.fontWeight = '700';
      remBox.appendChild(box);

      if (nextAllowedAtIsoCount) {
        const target = new Date(nextAllowedAtIsoCount).getTime();
        const update = () => {
          const left = target - Date.now();
          if (left <= 0) {
            clearBalCountdown();
            box.textContent = 'You can make withdrawals again (count reset).';
            const bw = document.getElementById('bal_withdraw'); if (bw) bw.disabled = false;
            return;
          }
          const total = Math.floor(left/1000);
          const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
          const pad = v => String(v).padStart(2,'0');
          box.textContent = `Next withdrawal allowed in: ${pad(h)}:${pad(m)}:${pad(s)} (count limit reached)`;
        };
        update(); balCountdown = setInterval(update, 1000);
      } else {
        box.textContent = 'Withdraw count limit reached ‚Äî next allowed in 24h from earliest recent request.';
      }
    } else if (remainingIncludingPending <= 0 && nextAllowedAtIsoMoney) {
      const box = document.createElement('div');
      box.style.marginTop = '6px';
      box.style.color = '#b91c1c';
      box.style.fontWeight = '700';
      remBox.appendChild(box);
      const target = new Date(nextAllowedAtIsoMoney).getTime();
      const updateMoney = () => {
        const left = target - Date.now();
        if (left <= 0) {
          clearBalCountdown();
          box.textContent = '24h money cap reset ‚Äî you can make a verified withdrawal now.';
          const bw = document.getElementById('bal_withdraw'); if (bw) bw.disabled = false;
          return;
        }
        const total = Math.floor(left/1000);
        const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
        const pad = v => String(v).padStart(2,'0');
        box.textContent = `Next money-allowance reset in: ${pad(h)}:${pad(m)}:${pad(s)}`;
      };
      updateMoney(); balCountdown = setInterval(updateMoney, 1000);
    }
  };
  renderRemainingBox();

  // wire buttons
  document.getElementById('bal_close').onclick = () => { clearBalCountdown(); closeModal(); };
  document.getElementById('bal_requests').onclick = async () => { clearBalCountdown(); closeModal(); await openMyRequests(); };
  document.getElementById('bal_convert').onclick = async () => { clearBalCountdown(); closeModal(); await openConvertModal(); };
  document.getElementById('bal_withdraw').onclick = async () => { clearBalCountdown(); closeModal(); await openWithdrawModal(); };

  // animate numbers
  try {
    const pointsEl = document.getElementById('bal_points');
    const dollarsEl = document.getElementById('bal_dollars');
    await Promise.all([
      animateNumber({ el: pointsEl, start: 0, end: Math.round(points), duration: 900, decimals:0, onFrame: v=>{pointsEl.textContent=numFmt(Math.round(v));} }),
      animateNumber({ el: dollarsEl, start: 0, end: balanceDollar, duration: 1200, decimals:3, onFrame: v=>{dollarsEl.textContent=Number(v).toFixed(3);} })
    ]);
    try{ playTick(); }catch(e){}
  } catch(e){
    const pointsEl = document.getElementById('bal_points'); const dollarsEl = document.getElementById('bal_dollars');
    if (pointsEl) pointsEl.textContent = numFmt(Math.round(points));
    if (dollarsEl) dollarsEl.textContent = Number(balanceDollar).toFixed(3);
  }

  // helpful debug (uncomment if still wrong)
  // console.debug('openBalanceModal debug', { listLen: list.length, computedTotals, serverRequestCount, localCountInfo, count24 });
}

/* ---------------- Admin button wiring (use addEventListener to be robust) ---------------- */

/* ---------- Withdraw modal (updated UX: disable, red countdown, explicit messages) ---------- */

async function openAdminWithdrawals(){
  const raw = await safeFetchJson('/api/admin/withdrawals', { headers: authHeaders() });

  if (!raw || (typeof raw.ok === 'boolean' && !raw.ok && raw.status === 401)) {
    return alert('Not allowed ‚Äî please log in as admin.');
  }
  if (!raw || (typeof raw.ok === 'boolean' && !raw.ok && raw.status === 403)) {
    return alert('Not allowed ‚Äî admin access required.');
  }

  const rr = normalizeApiResponse(raw);
  if (!rr.ok) {
    console.error('admin.withdrawals.load error raw:', raw);
    return alert(rr.error || 'Failed to load admin withdrawals');
  }

  // rr.withdrawals is expected to be the enhanced list from server
  const list = rr.withdrawals || rr.data && rr.data.withdrawals ? (rr.withdrawals || rr.data.withdrawals) : (rr || []).withdrawals || [];
  // fallback earlier parsing
  const rowsHtml = (list && list.length) ? list.map(w => {
    const status = String((w.status || 'pending')).toLowerCase();
    const statusClass = status === 'pending' ? 'status-pending' : (status === 'verified' ? 'status-verified' : 'status-rejected');

    // user display
    const requester = (w.userId && typeof w.userId === 'object')
      ? (w.userId.fullName || w.userId.username || w.userId.email || '')
      : (w.userId || '');

    // user stats provided by the server (may be missing if older server)
    const stats = w._userStats || { verifiedAmount24: 0, verifiedCount24: 0, requestCount24: 0 };
    const verifiedAmount24 = Number(stats.verifiedAmount24 || 0);
    const verifiedCount24 = Number(stats.verifiedCount24 || 0);
    const requestCount24 = Number(stats.requestCount24 || 0);

    // decide if verify button should be allowed (verifying should not push user over cap)
    const wouldBeAfterVerify = Number((verifiedAmount24 + safeNum(w.amount)).toFixed(6));
    const exceedCap = wouldBeAfterVerify > WITHDRAWAL_24H_CAP;

    // short human for timestamps
    const when = new Date(w.requestedAt || w.createdAt || Date.now()).toLocaleString();

    // warning text for verify button if verifying would exceed cap
    const verifyWarn = exceedCap ? `<div style="color:#b91c1c;font-size:12px;margin-top:6px">Can't Verify ‚Äî would exceed 24h cap (after verify: ${moneyFmt(wouldBeAfterVerify)} of ${moneyFmt(WITHDRAWAL_24H_CAP)})</div>` : '';

    return ` 
      <div class="admin-wd-item" data-id="${escapeHtml(w._id || w.id || '')}" style="display:flex;gap:12px;align-items:center;padding:10px;border-bottom:1px solid #f0f0f0">
        <div style="flex:1">
          <div><strong>${moneyFmt(w.amount)}</strong> ‚Äî ${escapeHtml(w.phone || '')}</div>
          <div class="small-muted">${escapeHtml(requester)} ‚Ä¢ ${escapeHtml(when)}</div>
          <div class="small-muted" style="margin-top:6px">
            Verified (24h): <strong>${moneyFmt(verifiedAmount24)}</strong> ‚Ä¢ Verified count (24h): <strong>${verifiedCount24}</strong> ‚Ä¢ Requests (24h): <strong>${requestCount24}</strong>
          </div>
          ${verifyWarn}
        </div>
        <div style="text-align:right">
          <div class="request-status ${statusClass}">${escapeHtml(w.status || 'pending')}</div>
          <div style="margin-top:8px; display:flex; gap:6px; justify-content:flex-end;">
            <button class="btn-ghost admin-verify-btn" data-id="${escapeHtml(w._id || w.id || '')}" ${status!=='pending' || exceedCap ? 'disabled' : ''}>Verify</button>
            <button class="btn-ghost admin-reject-btn" data-id="${escapeHtml(w._id || w.id || '')}">Reject</button>
            ${status === 'pending' ? `<button class="btn-ghost admin-remove-btn" data-id="${escapeHtml(w._id || w.id || '')}">Remove</button>` : ''}
          </div>
        </div>
      </div>
    `;
  }).join('') : `<div class="small-muted" style="padding:12px">No withdrawals found.</div>`;

  const html = `
    <div class="balance-modal" role="dialog" aria-modal="true">
      <h3>Admin ‚Äî Withdrawals</h3>
      <div style="margin-top:8px">
        <div style="max-height:480px; overflow:auto">${rowsHtml}</div>
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button id="admin_wd_close" class="btn-ghost">Close</button>
        </div>
      </div>
    </div>
  `;
  showModal(html);

  // wire remove buttons (same as before)
  Array.from(document.getElementsByClassName('admin-remove-btn')).forEach(btn => {
    btn.onclick = async (ev) => {
      const btnEl = ev.currentTarget || ev.target;
      const id = btnEl && btnEl.dataset && btnEl.dataset.id;
      if (!id) return alert('Missing id');

      if (!confirm('Permanently remove this pending withdrawal?')) return;

      try {
        if (btnEl) btnEl.disabled = true;

        const raw = await safeFetchJson(`/api/account/withdraw/${encodeURIComponent(id)}`, {
          method: 'DELETE',
          headers: authHeaders(true)
        });

        const resp = normalizeApiResponse(raw);
        if (!raw || (typeof raw.ok === 'boolean' && !raw.ok)) {
          alert(resp.error || 'Failed to remove withdrawal');
          if (btnEl && document.body.contains(btnEl)) btnEl.disabled = false;
          return;
        }

        alert('Withdrawal removed.');
        closeModal();
        await openAdminWithdrawals();
      } catch (e) {
        console.error('admin remove failed', e);
        alert('Failed to remove (network/server).');
        if (btnEl && document.body.contains(btnEl)) btnEl.disabled = false;
      }
    };
  });

  document.getElementById('admin_wd_close').onclick = closeModal;

  // VERIFY handler: now includes client-side pre-check (server still authoritative)
  Array.from(document.getElementsByClassName('admin-verify-btn')).forEach(btn => {
    btn.onclick = async (ev) => {
      const id = ev.currentTarget.dataset.id;
      if (!id) return alert('Missing id for this withdrawal');

      if (!confirm('Mark withdrawal as VERIFIED?')) return;

      // disable while processing
      ev.currentTarget.disabled = true;

      try {
        const rawResp = await safeFetchJson(`/api/admin/withdrawals/${encodeURIComponent(id)}/verify`, {
          method: 'POST',
          headers: authHeaders(true)
        });

        console.log('verify rawResp:', rawResp);
        const resp = normalizeApiResponse(rawResp);
        if (!rawResp || (typeof rawResp.ok === 'boolean' && !rawResp.ok)) {
          // server may return structured info with remaining/nextAllowedAt
          if (rawResp && rawResp.remaining !== undefined) {
            alert((rawResp.error || 'Failed to verify') + ` ‚Äî Remaining verified allowance: $${Number(rawResp.remaining).toFixed(3)}.` + (rawResp.nextAllowedAt ? ` Next allowed: ${new Date(rawResp.nextAllowedAt).toLocaleString()}` : ''));
          } else {
            alert(resp.error || 'Failed to verify withdrawal. Check server logs for details.');
          }
          return;
        }

        alert('Withdrawal marked verified.');
        closeModal();
        if (typeof applyNavUI === 'function') applyNavUI();
      } catch (e) {
        console.error('verify failed', e);
        alert('Failed to verify (network/server).');
      } finally {
        // re-open list to get fresh stats
        await openAdminWithdrawals();
      }
    };
  });

  // REJECT handler (same but re-open list after)
  Array.from(document.getElementsByClassName('admin-reject-btn')).forEach(btn => {
    btn.onclick = async (ev) => {
      const id = ev.currentTarget.dataset.id;
      if (!id) return alert('Missing id for this withdrawal');

      const reason = prompt('Enter rejection note (optional):', '');
      if (!confirm('Reject withdrawal?')) return;

      try {
        const rawResp = await safeFetchJson(`/api/admin/withdrawals/${encodeURIComponent(id)}/reject`, {
          method: 'POST',
          headers: authHeaders(true),
          body: JSON.stringify({ note: reason || '' })
        });

        const resp = normalizeApiResponse(rawResp);
        if (!rawResp || (typeof rawResp.ok === 'boolean' && !rawResp.ok)) {
          alert(resp.error || 'Failed to reject withdrawal. Check server logs.');
          return;
        }

        alert('Withdrawal rejected.');
        closeModal();
        if (typeof applyNavUI === 'function') applyNavUI();
        await openAdminWithdrawals();
      } catch (e) {
        console.error('reject failed', e);
        alert('Failed to reject (network/server).');
      }
    };
  });

}


async function openWithdrawModal() {
  // load balance + summary + withdrawals
  const [rawBal, rawSummary, rawList] = await Promise.all([
    safeFetchJson('/api/account/balance', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdrawals', { headers: authHeaders() })
  ]);

  const balRes = normalizeApiResponse(rawBal);
  if (!balRes.ok) {
    if (!getToken()) return alert('Please login.');
    return alert(balRes.error || 'Failed to load balance');
  }

  // extract user & balances
  const user = (balRes.data && balRes.data.user) ? balRes.data.user : getUser() || {};
  const bal = Number((balRes.data && balRes.data.balance && balRes.data.balance.balanceDollar) || 0);

  const sumRes = normalizeApiResponse(rawSummary);
  const list = _normalizeWithdrawListShape(rawList);
  // -------- compute authoritative 24h stats (client-side from the list)
  // prefer server summary if you want server authoritative; but computing from the list is
  // reliable for UI correctness (counts based on timestamps in the list).
  const computedTotals = compute24WindowTotals(list || [], (sumRes && sumRes.data && sumRes.data.cap) ? Number(sumRes.data.cap) : WITHDRAWAL_24H_CAP, 5);

  // money-cap fields (prefer computedTotals for accurate 24h window)
  const capVal = (sumRes && sumRes.data && sumRes.data.cap) ? Number(sumRes.data.cap) : WITHDRAWAL_24H_CAP;
  const spent24 = (typeof computedTotals.spent24 === 'number') ? computedTotals.spent24 : ((sumRes && sumRes.data && typeof sumRes.data.spent24 === 'number') ? Number(sumRes.data.spent24) : 0);
  const pending24 = (typeof computedTotals.pending24 === 'number') ? computedTotals.pending24 : ((sumRes && sumRes.data && typeof sumRes.data.pending24 === 'number') ? Number(sumRes.data.pending24) : 0);
  const remainingVerified = (typeof computedTotals.remainingVerified === 'number') ? computedTotals.remainingVerified : ((sumRes && sumRes.data && sumRes.data.remainingVerified !== undefined) ? Number(sumRes.data.remainingVerified) : Math.max(0, capVal - spent24));
  const remainingIncludingPending = (typeof computedTotals.remainingIncludingPending === 'number') ? computedTotals.remainingIncludingPending : ((sumRes && sumRes.data && sumRes.data.remainingIncludingPending !== undefined) ? Number(sumRes.data.remainingIncludingPending) : Math.max(0, capVal - (spent24 + pending24)));
  let nextAllowedAtIso = computedTotals.nextAllowedAt || (sumRes && sumRes.data && sumRes.data.nextAllowedAt) ? (computedTotals.nextAllowedAt || sumRes.data.nextAllowedAt) : null;

  // count-based rule (5 requests / 24h) ‚Äî prefer computed from list
  const count24 = (typeof computedTotals.requestCount24 === 'number') ? computedTotals.requestCount24 : (sumRes && sumRes.data && typeof sumRes.data.requestCount24 === 'number' ? Number(sumRes.data.requestCount24) : computeWithdrawCount24(list || [], 5).count);
  const nextAllowedAtCount = computedTotals.nextRequestAllowedAt || (sumRes && sumRes.data && sumRes.data.nextRequestAllowedAt) ? (computedTotals.nextRequestAllowedAt || sumRes.data.nextRequestAllowedAt) : computeWithdrawCount24(list || [], 5).nextAllowedAtIso;


  const html = `
    <div class="balance-modal">
      <h3>Withdraw</h3>
      <div style="margin-top:8px">
        <div class="small-muted">Available</div>
        <div style="font-weight:700; font-size:18px">${moneyFmt(bal)}</div>

        <label style="display:block;margin-top:12px">Phone / Account number</label>
        <input id="wd_phone" placeholder="+2519xxxxxxxx" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">

        <label style="display:block;margin-top:8px">Amount (leave blank for full)</label>
        <input id="wd_amount" type="number" min="0" placeholder="${moneyFmt(bal)}" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">

        <div id="withdraw_info" style="margin-top:8px" class="small-muted"></div>

        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button id="wd_cancel" class="btn-ghost">Cancel</button>
          <button id="wd_submit" class="btn btn-withdraw">Request Withdraw</button>
        </div>

        <div class="small-muted" style="margin-top:8px">Minimum: $${MIN_WITHDRAW}. 24h cap (verified): $${capVal}.</div>
      </div>
    </div>
  `;
  showModal(html);

  // helper to show inline toast inside modal (and also call global toasts if exists)
  const infoEl = document.getElementById('withdraw_info');
  function showInline(msg, type='info') {
    try {
      infoEl.style.color = (type === 'error' ? '#b91c1c' : (type === 'warn' ? '#b45309' : ''));
      infoEl.innerHTML = `<div style="font-weight:${type==='error'?700:400}">${escapeHtml(String(msg))}</div>`;
    } catch(e){}
    if (type === 'error') {
      if (typeof showError === 'function') try{ showError(String(msg)); }catch(e){}
      else if (typeof showWarn === 'function') try{ showWarn(String(msg)); }catch(e){}
    } else if (type === 'success') {
      if (typeof showSuccess === 'function') try{ showSuccess(String(msg)); }catch(e){}
    } else {
      if (typeof showInfo === 'function') try{ showInfo(String(msg)); }catch(e){}
    }
  }

  // element refs (declare before any use to avoid TDZ)
  const phoneInput = document.getElementById('wd_phone');
  const amountInput = document.getElementById('wd_amount');
  const submitBtn = document.getElementById('wd_submit');
  const cancelBtn = document.getElementById('wd_cancel');

  // safe countdown handling
  let countdownInterval = null;
  function clearCountdown(){ if (countdownInterval){ clearInterval(countdownInterval); countdownInterval = null; } }

  // Phone behavior: show registered phone as note, do NOT prefill so user can choose to leave blank.
  const registeredPhone = (user && (user.phoneNumber || user.phone || user.mobile)) ? (user.phoneNumber || user.phone || user.mobile) : '';
  if (registeredPhone) {
    // show the registered phone above the input and instruct the user they can leave input blank
    const note = document.createElement('div');
    note.className = 'small-muted';
    note.style.marginTop = '6px';
    note.innerHTML = `Registered phone: <strong>${escapeHtml(registeredPhone)}</strong> ‚Äî leave the input blank to send this registered number.`;
    phoneInput.parentNode.insertBefore(note, phoneInput);
    phoneInput.placeholder = `${registeredPhone} (leave blank to use registered)`;
  } else {
    // no registered phone: prompt the user to enter phone; block submit until filled
    showInline('No phone found in your profile ‚Äî please enter a phone/account number or add it to your profile.', 'warn');
  }


  // Render initial summary + count info
  const renderSummary = () => {
    const lines = [];
    lines.push(`<div>24h verified used: <strong>${moneyFmt(spent24)}</strong></div>`);
    lines.push(`<div>24h pending: <strong>${moneyFmt(pending24)}</strong></div>`);
    lines.push(`<div>Requests in last 24h: <strong>${count24}/5</strong></div>`);
    lines.push(`<div>Remaining (verified only): <strong>$${Number(remainingVerified).toFixed(3)}</strong></div>`);
    lines.push(`<div>Remaining (including pending): <strong>$${Number(remainingIncludingPending).toFixed(3)}</strong></div>`);
    infoEl.style.color = (remainingIncludingPending <= 0 || count24 >= 5) ? '#b91c1c' : '';
    infoEl.innerHTML = lines.join('');
  };
  renderSummary();

  // If count-based limit reached, disable submit and show countdown
  if (count24 >= 5) {
    submitBtn.disabled = true;
    if (nextAllowedAtCount) {
      const target = new Date(nextAllowedAtCount).getTime();
      const update = () => {
        const left = target - Date.now();
        if (left <= 0) { clearCountdown(); submitBtn.disabled = false; showInline('24h request count reset ‚Äî you can request again.', 'info'); return; }
        const total = Math.floor(left/1000);
        const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
        const pad = v=>String(v).padStart(2,'0');
        showInline(`Request-count cooldown ‚Äî Next allowed in: ${pad(h)}:${pad(m)}:${pad(s)} ‚Äî Requests: ${count24}/5`, 'warn');
      };
      update(); countdownInterval = setInterval(update, 1000);
    } else {
      showInline(`You have reached the 5-request limit in the last 24 hours (${count24}/5).`, 'warn');
    }
  } else if (remainingIncludingPending <= 0) {
    // money-cap case
    submitBtn.disabled = true;
    if (nextAllowedAtIso) {
      const target = new Date(nextAllowedAtIso).getTime();
      const updateMoney = () => {
        const left = target - Date.now();
        if (left <= 0) { clearCountdown(); submitBtn.disabled = false; showInline('24h money cap reset ‚Äî you can make a verified withdrawal now.', 'info'); return; }
        const total = Math.floor(left/1000);
        const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
        const pad = v=>String(v).padStart(2,'0');
        showInline(`Next money-allowance reset in: ${pad(h)}:${pad(m)}:${pad(s)}`, 'warn');
      };
      updateMoney(); countdownInterval = setInterval(updateMoney, 1000);
    } else {
      showInline('Remaining verified allowance for making withdrawal: unknown (cap reached).', 'warn');
    }
  }

  // wire cancel
  cancelBtn.onclick = () => { clearCountdown(); closeModal(); };

  // submit handler (declared once)
  submitBtn.onclick = async () => {
    try {
      // disable immediately to avoid duplicates
      submitBtn.disabled = true;
      submitBtn.innerText = 'Requesting...';
      clearCountdown();


         // send request
         const phoneEntered = (phoneInput.value || '').trim();
      const phoneToSend = phoneEntered || registeredPhone || '';

      if (!phoneToSend) {
        showInline('Phone required ‚Äî please enter your phone/account number or add a registered phone to your profile.', 'error');
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
        return;
      }

      const phone = (phoneInput.value || '').trim();
      let amtRaw = (amountInput.value || '').trim();

      // phone auto-fill fallback: if empty and registered phone exists, use it
      if (!phone && registeredPhone) {
        phoneInput.value = registeredPhone;
      }
      if (!phoneInput.value || !phoneInput.value.trim()) {
        showInline('Phone required ‚Äî please enter your phone/account number.', 'error');
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
        return;
      }

      // re-check fresh summary + withdrawals + balance before submitting (server-authoritative)
      const [freshSummaryRaw, freshListRaw, freshBalRaw] = await Promise.all([
        safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() }),
        safeFetchJson('/api/account/withdrawals', { headers: authHeaders() }),
        safeFetchJson('/api/account/balance', { headers: authHeaders() })
      ]);
      const freshSummary = normalizeApiResponse(freshSummaryRaw);
      const freshList = _normalizeWithdrawListShape(freshListRaw);
      const freshBal = normalizeApiResponse(freshBalRaw);
      const freshCap = (freshSummary && freshSummary.data && freshSummary.data.cap) ? Number(freshSummary.data.cap) : capVal;
      const freshSpent = (freshSummary && freshSummary.data && typeof freshSummary.data.spent24 === 'number') ? Number(freshSummary.data.spent24) : 0;
      const freshPending = (freshSummary && freshSummary.data && typeof freshSummary.data.pending24 === 'number') ? Number(freshSummary.data.pending24) :
                           ( (freshList||[]).filter(w=>_statusLower(w.status)==='pending').reduce((s,w)=>s+safeNum(w.amount),0) );
      const freshRemainingIncluding = Math.max(0, freshCap - (freshSpent + freshPending));
      const freshBalance = (freshBal && freshBal.data && freshBal.data.balance) ? Number(freshBal.data.balance.balanceDollar || 0) : bal;

      // parse amount: if blank => full balance
      let amount = null;
      if (!amtRaw) {
        amount = freshBalance;
      } else {
        amount = Number(amtRaw);
      }

      // validations: numeric, min, max cap, sufficient balance
      if (!Number.isFinite(amount) || amount <= 0) {
        showInline('Enter a valid amount (or leave blank for full).', 'error');
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
        return;
      }
      if (amount < MIN_WITHDRAW) {
        showInline(`Amount must be at least $${MIN_WITHDRAW}.`, 'error');
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
        return;
      }
      // per your UI/cap you wanted a "can't be more than $100" style message
      if (amount > freshCap) {
        showInline(`Requested amount cannot be more than $${Number(freshCap).toFixed(0)}.`, 'error');
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
        return;
      }
      if (amount > freshBalance) {
        showInline('Insufficient balance for this request.', 'error');
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
        return;
      }
      if (freshRemainingIncluding <= 0) {
        showInline(`Cannot request: you've reached the verified 24h cap of $${freshCap}.`, 'error');
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
        return;
      }
      if (amount > freshRemainingIncluding) {
        showInline(`Request would exceed your remaining verified allowance ($${freshRemainingIncluding.toFixed(3)}). Reduce amount or wait.`, 'error');
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
        return;
      }

   
      // later send payload:
      const payload = { phone: phoneToSend, amount: Number(amount.toFixed(3)) };
      const rawRes = await safeFetchJson('/api/account/withdraw', {
        method: 'POST',
        headers: authHeaders(true),
        body: JSON.stringify(payload)
      });

      // handle server refusal with remaining/nextAllowedAt
      if (!rawRes || (typeof rawRes.ok === 'boolean' && !rawRes.ok)) {
        const rem = rawRes && (rawRes.remaining !== undefined ? Number(rawRes.remaining) : (rawRes.remainingIncludingPending !== undefined ? Number(rawRes.remainingIncludingPending) : null));
        const nxt = rawRes && rawRes.nextAllowedAt ? rawRes.nextAllowedAt : (rawRes.data && rawRes.data.nextAllowedAt ? rawRes.data.nextAllowedAt : null);
        if (rem !== null || nxt) {
          let msg = (rawRes && rawRes.error) ? rawRes.error : 'Withdraw blocked';
          if (rem !== null) msg += ` ‚Äî Remaining verified allowance: $${rem.toFixed(3)}.`;
          if (nxt) msg += ` Next allowed around: ${new Date(nxt).toLocaleString()}`;
          showInline(msg, 'error');
          submitBtn.disabled = false;
          submitBtn.innerText = 'Request Withdraw';
          return;
        }
        const resp = normalizeApiResponse(rawRes);
        showInline(resp.error || 'Failed to request withdraw', 'error');
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
        return;
      }

      // success path
      const respNorm = normalizeApiResponse(rawRes);
      showInline('Withdrawal requested and is pending admin verification.', 'success');
      try { if (typeof showSuccess === 'function') showSuccess('Withdrawal requested and is pending admin verification.'); } catch(e){}

      // update UI / nav
      clearCountdown();
      closeModal();
      if (typeof applyNavUI === 'function') applyNavUI();

      return;
    } catch (err) {
      console.error('withdraw submit failed', err);
      showInline('Request failed due to network or server error.', 'error');
    } finally {
      // restore submit button state
      try {
        submitBtn.disabled = false;
        submitBtn.innerText = 'Request Withdraw';
      } catch(e){}
    }
  }; // submitBtn.onclick
}

/* ---------- openMyRequests (updated counting / normalization) ---------- */
async function openMyRequests(){
  const [rawList, rawSummary] = await Promise.all([
    safeFetchJson('/api/account/withdrawals', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() })
  ]);
  const listRes = normalizeApiResponse(rawList);
  const sumRes = normalizeApiResponse(rawSummary);

  // Normalize withdrawals list robustly
  let withdrawals = extractWithdrawals(listRes);
  if (!Array.isArray(withdrawals) || withdrawals.length === 0) {
    if (listRes && listRes.data && Array.isArray(listRes.data)) withdrawals = listRes.data;
    else if (rawList && rawList.data && Array.isArray(rawList.data.withdrawals)) withdrawals = rawList.data.withdrawals;
    else if (Array.isArray(rawList)) withdrawals = rawList;
    else withdrawals = _normalizeWithdrawListShape(rawList) || [];
  }

  const conversions = loadConvertHistory();

  const totalAll = (withdrawals || []).length;
  const verifiedList = (withdrawals || []).filter(w => _statusLower(w.status) === 'verified');
  const pendingList = (withdrawals || []).filter(w => _statusLower(w.status) === 'pending');
  const rejectedList = (withdrawals || []).filter(w => _statusLower(w.status) === 'rejected');
  const totalVerifiedAmount = verifiedList.reduce((s,w) => s + safeNum(w.amount), 0);

  // compute 24h totals client-side (preferred for UI accuracy)
  const capFromServer = (sumRes && sumRes.data && sumRes.data.cap) ? Number(sumRes.data.cap) : WITHDRAWAL_24H_CAP;
  const computedTotalsReq = compute24WindowTotals(withdrawals || [], capFromServer, 5) || {};

  // fallback computeWithdrawalStats if older code expects it (keeps compatibility)
  const computedFallback = computeWithdrawalStats(withdrawals || [], capFromServer) || {};

  const spent24 = (typeof computedTotalsReq.spent24 === 'number') ? computedTotalsReq.spent24 : ((sumRes && sumRes.data && typeof sumRes.data.spent24 === 'number') ? Number(sumRes.data.spent24) : (computedFallback.spent24 || 0));
  const pending24 = (typeof computedTotalsReq.pending24 === 'number') ? computedTotalsReq.pending24 : ((sumRes && sumRes.data && typeof sumRes.data.pending24 === 'number') ? Number(sumRes.data.pending24) : (computedFallback.pending24 || 0));
  const remainingVerified = (typeof computedTotalsReq.remainingVerified === 'number') ? computedTotalsReq.remainingVerified : ((sumRes && sumRes.data && sumRes.data.remainingVerified !== undefined) ? Number(sumRes.data.remainingVerified) : (computedFallback.remainingVerified || Math.max(0, capFromServer - spent24)));
  const remainingIncludingPending = (typeof computedTotalsReq.remainingIncludingPending === 'number') ? computedTotalsReq.remainingIncludingPending : ((sumRes && sumRes.data && sumRes.data.remainingIncludingPending !== undefined) ? Number(sumRes.data.remainingIncludingPending) : (computedFallback.remainingIncludingPending || Math.max(0, capFromServer - (spent24 + pending24))));

  // COUNT logic: prefer server summary.requestCount24 when present, otherwise use computedTotalsReq.requestCount24, otherwise compute from list
  const serverRequestCount = (sumRes && sumRes.data && typeof sumRes.data.requestCount24 === 'number') ? Number(sumRes.data.requestCount24) : null;
  const localCountInfo = computeWithdrawCount24(withdrawals || [], 5) || { count: 0, nextAllowedAtIso: null };
  const count24 = (serverRequestCount !== null) ? serverRequestCount : ((typeof computedTotalsReq.requestCount24 === 'number') ? computedTotalsReq.requestCount24 : localCountInfo.count);

  const nextAllowedAtRaw = computedTotalsReq.nextAllowedAt || (sumRes && sumRes.data && sumRes.data.nextAllowedAt) || (computedFallback.nextAllowedAtIso || null);
  const nextAllowedCountRaw = computedTotalsReq.nextRequestAllowedAt || (sumRes && sumRes.data && sumRes.data.nextRequestAllowedAt) || localCountInfo.nextAllowedAtIso;

  let remainingHtml = '';
  remainingHtml += `<div>24h used: <strong>${moneyFmt(spent24)}</strong> ‚Ä¢ pending: <strong>${moneyFmt(pending24)}</strong></div>`;
  remainingHtml += `<div>Requests in last 24h: <strong>${count24}/5</strong></div>`;
  if (remainingIncludingPending <= 0) {
    remainingHtml += `<div style="color:#b91c1c;font-weight:700">Remaining (including pending): $0.000 (cap reached)</div>`;
  } else {
    remainingHtml += `<div>Remaining (including pending): <strong>$${remainingIncludingPending.toFixed(3)}</strong></div>`;
  }
  remainingHtml += `<div>Remaining (verified only): <strong>$${remainingVerified.toFixed(3)}</strong></div>`;

  const summaryHtml = `
    <div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:8px">
      <div class="small-muted">Total requests: <strong>${totalAll}</strong></div>
      <div class="small-muted">Verified: <strong>${verifiedList.length}</strong></div>
      <div class="small-muted">Pending: <strong>${pendingList.length}</strong></div>
      <div class="small-muted">Rejected: <strong>${rejectedList.length}</strong></div>
      <div class="small-muted">Total Verified: <strong>${moneyFmt(totalVerifiedAmount)}</strong></div>
      ${remainingHtml}
      ${(nextAllowedAtRaw ? `<div id="next_allowed_box" class="small-muted">Next money allowance: <strong id="next_allowed_countdown">${nextAllowedAtRaw}</strong></div>` : '')}
      ${(nextAllowedCountRaw ? `<div id="next_count_box" class="small-muted">Next request allowed: <strong id="next_countdown">${nextAllowedCountRaw}</strong></div>` : '')}
    </div>
  `;

  const wdHtml = (withdrawals.length ? withdrawals.map(w => {
    const status = String((w.status || 'pending')).toLowerCase();
    const statusClass = status === 'pending' ? 'status-pending' : (status === 'verified' ? 'status-verified' : 'status-rejected');
    const when = new Date(w.requestedAt || w.createdAt || Date.now()).toLocaleString();
    const note = escape((w.note || '').toString());
    const verifiedBy = (w.verifiedBy && typeof w.verifiedBy === 'object') ? (w.verifiedBy.fullName || w.verifiedBy.username || '') : (w.verifiedBy || '');
    const verifiedAt = w.verifiedAt ? ` ‚Ä¢ Verified at: ${new Date(w.verifiedAt).toLocaleString()}` : '';

    const removeBtnHtml = status === 'pending' ? `<button class="btn-ghost req-remove-btn" data-id="${escapeHtml(w._id || w.id || '')}">Remove</button>` : '';

    return `
      <div class="request-item" data-id="${escapeHtml(w._id || w.id || '')}">
        <div class="request-left">
          <div><strong>${moneyFmt(w.amount)}</strong> ‚Äî ${escape(w.phone || '')}</div>
          <div class="small-muted">${when}${verifiedAt}</div>
        </div>
        <div style="text-align:right">
          <div class="request-status ${statusClass}">${escape(w.status || 'pending')}</div>
          <div style="margin-top:8px; display:flex; gap:6px; justify-content:flex-end;">
            ${removeBtnHtml}
          </div>
          <div style="margin-top:8px"><small>${note}${verifiedBy ? (' ‚Ä¢ By: ' + escape(verifiedBy)) : ''}</small></div>
        </div>
      </div>
    `;
  }).join('') : `<div class="small-muted">No withdrawals found.</div>`);

  const html = `
    <div class="balance-modal">
      <h3>My Requests & History</h3>
      ${summaryHtml}
      <div style="margin-top:6px"><strong>Withdrawals</strong></div>
      <div class="requests-list">${wdHtml}</div>

      <div style="margin-top:12px"><strong>Conversions (local history)</strong></div>
      <div class="requests-list">${conversions.length ? conversions.map(c => {
        const when = new Date(c.requestedAt || Date.now()).toLocaleString();
        return `<div class="request-item"><div class="request-left"><div><strong>${numFmt(c.points||0)} pts</strong> ‚Üí ${moneyFmt(c.dollars||0)}</div><div class="small-muted">${when}</div></div><div style="text-align:right"><div class="small-muted">Converted</div></div></div>`;
      }).join('') : `<div class="small-muted">No local conversions performed yet.</div>`}</div>

      <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
        <button id="req_close" class="btn-ghost">Close</button>
        <button id="req_convert_back" class="btn-ghost">Convert $ ‚Üí pts</button>
      </div>
    </div>
  `;
  showModal(html);

  document.getElementById('req_close').onclick = closeModal;
  document.getElementById('req_convert_back').onclick = () => { closeModal(); openConvertBackModal(); };

  Array.from(document.getElementsByClassName('req-remove-btn')).forEach(btn => {
    btn.onclick = async (ev) => {
      const btnEl = ev.currentTarget || ev.target;
      const id = btnEl && btnEl.dataset && btnEl.dataset.id;
      if (!id) return alert('Missing id for this withdrawal.');

      if (!confirm('Remove this pending withdrawal?')) return;

      try {
        if (btnEl) btnEl.disabled = true;

        const raw = await safeFetchJson(`/api/account/withdraw/${encodeURIComponent(id)}`, {
          method: 'DELETE',
          headers: authHeaders(true)
        });

        if (!raw || (typeof raw.ok === 'boolean' && !raw.ok)) {
          const resp = normalizeApiResponse(raw);
          alert(resp.error || 'Failed to remove withdrawal.');
          if (btnEl && document.body.contains(btnEl)) btnEl.disabled = false;
          return;
        }

        closeModal();
        if (typeof applyNavUI === 'function') applyNavUI();
        await openMyRequests();
        return;
      } catch (e) {
        console.error('remove request failed', e);
        alert('Failed to remove withdrawal (network/server).');
        if (btnEl && document.body.contains(btnEl)) btnEl.disabled = false;
      }
    };
  });

  // start nextAllowedAt countdown if present
  const nextBox = document.getElementById('next_allowed_box');
  if (nextBox && nextAllowedAtRaw) {
    const el = document.getElementById('next_allowed_countdown');
    try {
      const target = new Date(nextAllowedAtRaw).getTime();
      if (!isNaN(target)) {
        let nextAllowedTimer = setInterval(()=>{
          const left = target - Date.now();
          if (left <= 0) {
            el.textContent = 'Now';
            clearInterval(nextAllowedTimer);
            return;
          }
          const h = Math.floor(left / 3600000);
          const m = Math.floor((left % 3600000) / 60000);
          const s = Math.floor((left % 60000) / 1000);
          el.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }, 1000);
      }
    } catch(e){}
  }

  // start nextAllowedCount countdown if present
  const nextCountBox = document.getElementById('next_count_box');
  if (nextCountBox && nextAllowedCountRaw) {
    const el = document.getElementById('next_countdown');
    try {
      const target = new Date(nextAllowedCountRaw).getTime();
      if (!isNaN(target)) {
        let nextAllowedTimer2 = setInterval(()=>{
          const left = target - Date.now();
          if (left <= 0) {
            el.textContent = 'Now';
            clearInterval(nextAllowedTimer2);
            return;
          }
          const h = Math.floor(left / 3600000);
          const m = Math.floor((left % 3600000) / 60000);
          const s = Math.floor((left % 60000) / 1000);
          el.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }, 1000);
      }
    } catch(e){}
  }

  // debug
  // console.debug('openMyRequests debug', { withdrawalsLen: withdrawals.length, computedTotalsReq, sumRes, localCountInfo, count24 });
}

/* ---------------- Improved openAdminWithdrawals (frontend) ---------------- */

// async function openAdminWithdrawals(){
//   const raw = await safeFetchJson('/api/admin/withdrawals', { headers: authHeaders() });

//   if (!raw || (typeof raw.ok === 'boolean' && !raw.ok && raw.status === 401)) {
//     return alert('Not allowed ‚Äî please log in as admin.');
//   }
//   if (!raw || (typeof raw.ok === 'boolean' && !raw.ok && raw.status === 403)) {
//     return alert('Not allowed ‚Äî admin access required.');
//   }

//   const rr = normalizeApiResponse(raw);
//   if (!rr.ok) {
//     console.error('admin.withdrawals.load error raw:', raw);
//     return alert(rr.error || 'Failed to load admin withdrawals');
//   }

//   const list = rr.data && rr.data.withdrawals ? rr.data.withdrawals : (rr.withdrawals || []);
//   const rowsHtml = list.length ? list.map(w => {
//     const statusClass = w.status === 'pending' ? 'status-pending' : (w.status === 'verified' ? 'status-verified' : 'status-rejected');

//     // Support populated userId (object) or plain userId string
//     const requester = (w.userId && typeof w.userId === 'object')
//       ? (w.userId.fullName || w.userId.username || w.userId.email || '')
//       : '';

// // when building rowsHtml in openAdminWithdrawals()
// return ` 
//   <div class="admin-wd-item" data-id="${escapeHtml(w._id || w.id || '')}" style="display:flex;gap:12px;align-items:center;padding:10px;border-bottom:1px solid #f0f0f0">
//     <div style="flex:1">
//       <div><strong>${moneyFmt(w.amount)}</strong> ‚Äî ${escapeHtml(w.phone || '')}</div>
//       <div class="small-muted">${escapeHtml(requester)} ‚Ä¢ ${new Date(w.requestedAt || w.createdAt || Date.now()).toLocaleString()}</div>
//     </div>
//     <div style="text-align:right">
//       <div class="request-status ${statusClass}">${escapeHtml(w.status || 'pending')}</div>
//       <div style="margin-top:8px; display:flex; gap:6px; justify-content:flex-end;">
//         <button class="btn-ghost admin-verify-btn" data-id="${escapeHtml(w._id || w.id || '')}">Verify</button>
//         <button class="btn-ghost admin-reject-btn" data-id="${escapeHtml(w._id || w.id || '')}">Reject</button>
//         ${status === 'pending' ? `<button class="btn-ghost admin-remove-btn" data-id="${escapeHtml(w._id || w.id || '')}">Remove</button>` : ''}
//       </div>
//     </div>
//   </div>
// `;

//   }).join('') : `<div class="small-muted" style="padding:12px">No withdrawals found.</div>`;

//   const html = `
//     <div class="balance-modal" role="dialog" aria-modal="true">
//       <h3>Admin ‚Äî Withdrawals</h3>
//       <div style="margin-top:8px">
//         <div style="max-height:380px; overflow:auto">${rowsHtml}</div>
//         <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
//           <button id="admin_wd_close" class="btn-ghost">Close</button>
//         </div>
//       </div>
//     </div>
//   `;
//   showModal(html);

//   Array.from(document.getElementsByClassName('admin-remove-btn')).forEach(btn => {
//   btn.onclick = async (ev) => {
//     const btnEl = ev.currentTarget || ev.target;
//     const id = btnEl && btnEl.dataset && btnEl.dataset.id;
//     if (!id) return alert('Missing id');

//     if (!confirm('Permanently remove this pending withdrawal?')) return;

//     try {
//       if (btnEl) btnEl.disabled = true;

//       const raw = await safeFetchJson(`/api/account/withdraw/${encodeURIComponent(id)}`, {
//         method: 'DELETE',
//         headers: authHeaders(true)
//       });

//       const resp = normalizeApiResponse(raw);
//       if (!raw || (typeof raw.ok === 'boolean' && !raw.ok)) {
//         alert(resp.error || 'Failed to remove withdrawal');
//         if (btnEl && document.body.contains(btnEl)) btnEl.disabled = false;
//         return;
//       }

//       alert('Withdrawal removed.');
//       closeModal();
//       await openAdminWithdrawals();
//     } catch (e) {
//       console.error('admin remove failed', e);
//       alert('Failed to remove (network/server).');
//       if (btnEl && document.body.contains(btnEl)) btnEl.disabled = false;
//     }
//   };
// });

//   document.getElementById('admin_wd_close').onclick = closeModal;

//   // VERIFY handler
//   Array.from(document.getElementsByClassName('admin-verify-btn')).forEach(btn => {
//     btn.onclick = async (ev) => {
//       const id = ev.currentTarget.dataset.id;
//       if (!id) return alert('Missing id for this withdrawal');

//       if (!confirm('Mark withdrawal as VERIFIED?')) return;

//       // POST verify
//       const rawResp = await safeFetchJson(`/api/admin/withdrawals/${encodeURIComponent(id)}/verify`, {
//         method: 'POST',
//         headers: authHeaders(true)
//       });

//       // Print raw response to console for debugging
//       console.log('verify rawResp:', rawResp);

//       // normalize and show useful message
//       const resp = normalizeApiResponse(rawResp);
//       if (!resp.ok) {
//         // prefer server-provided details
//         let serverMsg = rawResp && rawResp.data && (rawResp.data.error || rawResp.data.message) ? (rawResp.data.error || rawResp.data.message) : null;
//         // if rawText exists (maybe stack or HTML), include it in console only
//         if (rawResp && rawResp.rawText) console.error('verify rawText:', rawResp.rawText);
//         return alert(serverMsg || resp.error || 'Failed to verify withdrawal. Check server logs for details.');
//       }

//       alert('Withdrawal marked verified.');
//       closeModal();
//       if (typeof applyNavUI === 'function') applyNavUI();
//     };
//   });

//   // REJECT handler
//   Array.from(document.getElementsByClassName('admin-reject-btn')).forEach(btn => {
//     btn.onclick = async (ev) => {
//       const id = ev.currentTarget.dataset.id;
//       if (!id) return alert('Missing id for this withdrawal');

//       const reason = prompt('Enter rejection note (optional):', '');
//       if (!confirm('Reject withdrawal?')) return;

//       const rawResp = await safeFetchJson(`/api/admin/withdrawals/${encodeURIComponent(id)}/reject`, {
//         method: 'POST',
//         headers: authHeaders(true),
//         body: JSON.stringify({ note: reason || '' })
//       });

//       console.log('reject rawResp:', rawResp);
//       const resp = normalizeApiResponse(rawResp);
//       if (!resp.ok) {
//         let serverMsg = rawResp && rawResp.data && (rawResp.data.error || rawResp.data.message) ? (rawResp.data.error || rawResp.data.message) : null;
//         if (rawResp && rawResp.rawText) console.error('reject rawText:', rawResp.rawText);
//         return alert(serverMsg || resp.error || 'Failed to reject withdrawal. Check server logs.');
//       }

//       alert('Withdrawal rejected.');
//       closeModal();
//       if (typeof applyNavUI === 'function') applyNavUI();
//     };
//   });
// }

/* attach global buttons (if present) ‚Äî declare element refs first, then wire handlers */
const balBtn = document.getElementById('btn-balance');
const convBtn = document.getElementById('btn-convert');
const convBackBtn = document.getElementById('btn-convert-back');
const adminCheckBtn = document.getElementById('btn-check-withdrawals');

if (balBtn) {
  balBtn.addEventListener('click', openBalanceModal);
}
if (convBtn) {
  convBtn.addEventListener('click', openConvertModal);
}
if (convBackBtn) {
  convBackBtn.addEventListener('click', openConvertBackModal);
}
if (adminCheckBtn) {
  adminCheckBtn.addEventListener('click', openAdminWithdrawals);
}



// run once at app startup (if socket.io client is available)
try {
  const socketClient = (typeof io === 'function') ? io() : (window.socket || null);
  if (socketClient) {
    socketClient.on('withdrawals:deleted', (data) => {
      if (!data || !data.id) return;
      const id = String(data.id);

      // If My Requests modal is open, remove that item from the DOM (or refresh)
      const myItem = document.querySelector(`.request-item[data-id="${id}"]`);
      if (myItem) {
        myItem.remove();
        // update nav/UI counts
        if (typeof applyNavUI === 'function') applyNavUI();
      }

      // If admin modal is open, remove that item from admin list
      const adminItem = document.querySelector(`.admin-wd-item[data-id="${id}"]`);
      if (adminItem) {
        adminItem.remove();
      }

      // Optionally, if you prefer server-to-authoritative refresh:
      // if (document.querySelector('.balance-modal')) openBalanceModal();
      // if (document.querySelector('.admin-wd-item')) openAdminWithdrawals();
    });
  }
} catch(e){ console.warn('socket init failed', e); }

// Ensure API_BASE, fetchJson, getToken, getUser, authHeaders, escapeHtml are defined above this snippet


// Open edit profile modal


async function openEditProfile(){
  const token = getToken();
  if (!token) return requireLoginModal('Please login to edit your profile.');

  const r = await fetchJson('/api/auth/me', { headers: authHeaders(), method: 'GET' });
  if (!r || !r.ok) return alert('Failed to load profile: ' + (r && r.error ? r.error : ''));

  const user = r.data && r.data.user ? r.data.user : (r.data || {});
  const countrySelectHtml = buildCountrySelectHtml(user.country || '');
  const cityHtml = buildCitySelectHtml(user.country || '', user.city || '');

  const html = `
    <h3>Edit Profile</h3>
    <label>Full name</label><input id="ep_fullName" value="${escapeHtml(user.fullName||'')}" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">
    <label>Email (optional)</label><input id="ep_email" value="${escapeHtml(user.email||'')}" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">
    <label>Phone</label><input id="ep_phone" value="${escapeHtml(user.phoneNumber||user.phone||'')}" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">
    <label>Country</label>${countrySelectHtml}
    <label>City</label><div id="ep_city_container">${cityHtml}</div>
    <label>New password (leave blank to keep)</label><input id="ep_password" type="password" placeholder="New password" style="width:100%;padding:8px;border-radius:8px;border:1px solid #eef2ff">
    <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
      <button id="ep_cancel" class="btn-ghost">Cancel</button>
      <button id="ep_save" class="btn">Save</button>
    </div>
  `;
  showModal(html);

  // country change updates available city select
  document.getElementById('profile_country').addEventListener('change', (ev) => {
    const code = ev.target.value;
    document.getElementById('ep_city_container').innerHTML = buildCitySelectHtml(code, '');
  });

  document.getElementById('ep_cancel').onclick = closeModal;
  document.getElementById('ep_save').onclick = async () => {
    const fullName = (document.getElementById('ep_fullName').value || '').trim();
    const email = (document.getElementById('ep_email').value || '').trim();
    const phone = (document.getElementById('ep_phone').value || '').trim();
    const country = (document.getElementById('profile_country').value || '').trim();
    const cityEl = document.getElementById('profile_city') || document.querySelector('#ep_city_container input') || document.querySelector('#ep_city_container select');
    const city = cityEl ? (cityEl.value || '').trim() : '';
    const password = (document.getElementById('ep_password').value || '');

    if (!fullName) return alert('Full name required');
    if (phone && !/^\+?[0-9\-\s()]{7,20}$/.test(phone)) return alert('Enter a valid phone number with country code');
    if (password && password.length < 6) return alert('New password must be at least 6 characters');

    const countryFlagEmoji = codeToFlagEmoji(country);
    const countryName = (COUNTRIES.find(c => c.code === country) || {}).name || country || '';

    const payload = {
      fullName,
      email: email || undefined,
      phoneNumber: phone || undefined,
      country: country || undefined,
      countryName: countryName || undefined,
      countryFlagEmoji: countryFlagEmoji || undefined,
      city: city || undefined
    };
    if (password) payload.password = password;

    const upd = await fetchJson('/api/auth/me', {
      method: 'PUT',
      headers: authHeaders(true),
      body: JSON.stringify(payload)
    });

    if (!upd || !upd.ok) return alert('Save failed: ' + (upd && (upd.error || (upd.data && upd.data.error)) ? (upd.error || upd.data.error) : ''));
    const updatedUser = upd.data && upd.data.user ? upd.data.user : (upd.user || null);
    if (updatedUser) {
      const localUser = getUser() || {};
      const mergedUser = Object.assign({}, localUser, updatedUser);
      localStorage.setItem('user', JSON.stringify(mergedUser));
    }
    alert('Profile updated');
    closeModal();
    if (typeof applyNavUI === 'function') applyNavUI();
  };
}

// ---------- Bell UI & actions ----------

async function fetchHelpUnreadCount(announcementsForContext = []) {
  try {
    const res = await fetchJson('/api/help/unread-count', { headers: authHeaders(), method: 'GET' });
    if (!res.ok) { console.warn('unread-count', res.error); return; }
    let serverUnread = (res.data && typeof res.data.unread === 'number') ? res.data.unread : 0;
    const badge = document.getElementById('help_unread_badge');
    if (!badge) return;

    // compute how many of the server-side unread are already opened locally (best-effort)
    let localOpenedOverlap = 0;
    if (Array.isArray(announcementsForContext) && announcementsForContext.length) {
      const opened = getOpenedSet();
      for (const a of announcementsForContext) {
        if (!a) continue;
        if ((a.isUnread === false) || a._read === true) continue; // if server marks as read
        if (opened.has(String(a._id))) localOpenedOverlap++;
      }
    } else {
      // no context; we can estimate by counting local opened items but avoid going negative
      // don't apply overlap if we don't know the server list (safer to show server value)
      localOpenedOverlap = 0;
    }

    const displayCount = Math.max(0, serverUnread - localOpenedOverlap);
    if (displayCount > 0) { badge.innerText = (displayCount > 99 ? '99+' : String(displayCount)); badge.style.display = ''; }
    else badge.style.display = 'none';
  } catch (e) { console.warn('fetchHelpUnreadCount err', e); }
}

// Open a small modal (bell) showing announcements and (for admin) create/edit/delete controls
async function openBellModal() {
  // Load announcements
  const r = await fetchJson('/api/help/announcements?limit=100', { method: 'GET' });
  if (!r.ok) return alert('Failed to load announcements: ' + (r.error || ''));
  const ann = r.data.announcements || [];

  const is_admin = isAdmin();
  // Build HTML
  const rows = ann.map(a => {
    const date = new Date(a.createdAt).toLocaleString();
    let adminControls = '';
    if (is_admin) {
      adminControls = `
        <div style="margin-top:6px">
          <button class="ann-edit" data-id="${a._id}">Edit</button>
          <button class="ann-delete" data-id="${a._id}">Delete</button>
        </div>`;
    }
    return `
      <div style="padding:10px;border-bottom:1px solid #eee">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">${escapeHtml(a.title || 'Announcement')}</div>
          <div style="color:#666;font-size:12px">${escapeHtml(date)}</div>
        </div>
        <div style="margin-top:6px;color:#111">${escapeHtml(a.text)}</div>
        ${adminControls}
      </div>`;
  }).join('');

  const adminCreateHtml = is_admin ? `
    <hr>
    <div style="margin-top:8px">
      <div><input id="ann_title" placeholder="Title (optional)" style="width:100%;padding:8px;margin-bottom:6px"></div>
      <div><textarea id="ann_text" placeholder="Write announcement..." style="width:100%;min-height:80px;padding:8px"></textarea></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="ann_create">Create</button>
        <button id="ann_mark_read" class="btn-ghost">Mark all read</button>
      </div>
    </div>` : `<div style="padding:8px"><button id="ann_mark_read">Mark all read</button></div>`;

  const html = `
    <h3>Announcements</h3>
    <div style="max-height:50vh;overflow:auto;border:1px solid #f0f0f0;border-radius:8px;margin-top:8px">${rows || '<div style="padding:12px;color:#666">No announcements</div>'}</div>
    ${adminCreateHtml}
    <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
      <button id="bell_close" class="btn-ghost">Close</button>
    </div>
  `;
  showModal(html);

  // handlers
  document.getElementById('bell_close').onclick = closeModal;

  // Mark read button available to all logged-in users (or guests it will call mark-read but fail auth)
  const markBtn = document.getElementById('ann_mark_read');
  if (markBtn) markBtn.onclick = async () => {
    if (!getToken()) {
      // guests: just close (they can't mark as read)
      alert('Please login to mark announcements read.');
      return;
    }
    const rr = await fetchJson('/api/help/mark-read', { method: 'POST', headers: authHeaders() });
    if (!rr.ok) return alert('Failed to mark read: ' + (rr.error || ''));
    await fetchHelpUnreadCount();
    alert('Marked announcements as read');
    closeModal();
  };

  // Admin create
  if (is_admin) {
    document.getElementById('ann_create').onclick = async () => {
      const title = document.getElementById('ann_title').value.trim();
      const text = document.getElementById('ann_text').value.trim();
      if (!text) return alert('Text required');
      const res = await fetchJson('/api/help/announcements', { method: 'POST', headers: authHeaders(true), body: JSON.stringify({ title, text }) });
      if (!res.ok) return alert('Create failed: ' + (res.error || ''));
      alert('Created');
      closeModal();
      // refresh badge + re-open
      await fetchHelpUnreadCount();
      openBellModal();
    };
  }

  // admin edit/delete bindings
  document.querySelectorAll('.ann-delete').forEach(b => b.onclick = async (e) => {
    const id = e.target.dataset.id;
    if (!confirm('Delete this announcement?')) return;
    const res = await fetchJson('/api/help/announcements/' + encodeURIComponent(id), { method: 'DELETE', headers: authHeaders() });
    if (!res.ok) return alert('Delete failed: ' + (res.error || ''));
    alert('Deleted');
    closeModal();
    await fetchHelpUnreadCount();
    openBellModal();
  });

  document.querySelectorAll('.ann-edit').forEach(b => b.onclick = async (e) => {
    const id = e.target.dataset.id;
    // simple prompt edit (quick). You can replace with nicer modal edit UI
    const current = ann.find(x => x._id === id);
    const newText = prompt('Edit text', current ? current.text : '');
    if (newText === null) return;
    const newTitle = prompt('Edit title (optional)', current ? current.title : '');
    const res = await fetchJson('/api/help/announcements/' + encodeURIComponent(id), {
      method: 'PUT',
      headers: authHeaders(true),
      body: JSON.stringify({ text: newText, title: newTitle })
    });
    if (!res.ok) return alert('Edit failed: ' + (res.error || ''));
    alert('Updated');
    closeModal();
    await fetchHelpUnreadCount();
    openBellModal();
  });
}

/* ----------------- Improved Bell / Announcements module ----------------- */

/*
  Requires in-page helpers:
    - fetchJson(path, opts)
    - authHeaders(json=true)
    - getToken()
    - isAdmin()
    - showModal(html)
    - closeModal()
    - escapeHtml(s)
  If you have them named differently, adapt those calls.
*/


  // localStorage key to track which announcements the current browser/user opened
  const OPENED_KEY = 'openedAnnouncements';

  function getOpenedSet() {
  try {
    const s = localStorage.getItem(OPENED_KEY);
    return s ? new Set(JSON.parse(s)) : new Set();
  } catch (e) { return new Set(); }
}
function addOpened(id) {
  try {
    const s = getOpenedSet();
    s.add(String(id));
    localStorage.setItem(OPENED_KEY, JSON.stringify(Array.from(s)));
  } catch (e) { /* ignore */ }
}
function openedHas(id) { return getOpenedSet().has(String(id)); }

/* --- format text with safe escaping + preserve newlines --- */
function escapeHtml(s){
  if (s === 0) return '0';
  if (!s) return '';
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}
function formatAnnouncementText(text) {
  // escape then convert newlines to <br> ‚Äî preserves multi-line content
  return escapeHtml(text).replace(/\r\n?/g, '\n').replace(/\n/g, '<br>');
}

function buildAnnouncementsListHTML(announcements = []) {
  const openedSet = getOpenedSet();
  if (!announcements.length) {
    return `<div style="padding:12px;color:#666">No announcements</div>`;
  }
  return announcements.map(a => {
    const date = a.createdAt ? new Date(a.createdAt).toLocaleString() : '';
    const isOpened = openedSet.has(String(a._id));
    const unreadClass = isOpened ? '' : 'ann-unopened';

    // Preview: show only the first line (trimmed). If there are more lines, show ellipsis.
    const rawText = (a.text || '');
    const firstLine = rawText.split(/\r?\n/)[0] || '';              // first line only
    const hasMoreLines = rawText.split(/\r?\n/).length > 1;
    // short preview length guard
    const previewShort = firstLine.length > 200 ? firstLine.slice(0, 200) + '‚Ä¶' : firstLine + (hasMoreLines && firstLine.length < 200 ? '‚Ä¶' : '');
    const previewHtml = escapeHtml(previewShort); // do not convert newlines to <br> in preview

    // New badge for unopened announcements
    const newBadgeHtml = isOpened ? '' : `<span class="ann-new-badge">New</span>`;

    return `
      <div class="ann-row ${unreadClass}" data-id="${escapeHtml(a._id)}" style="">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:8px">
          <div style="flex:1;min-width:0">
            <div style="display:flex;align-items:center;gap:8px">
              <div class="ann-title">${escapeHtml(a.title || 'Announcement')}</div>
              ${newBadgeHtml}
            </div>
            <div class="ann-meta">${escapeHtml(date)}</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="ann-open small-btn" data-id="${escapeHtml(a._id)}">Open</button>
            ${isAdmin() ? `<button class="ann-edit-btn small-btn" data-id="${escapeHtml(a._id)}">Edit</button>` : ''}
            ${isAdmin() ? `<button class="ann-delete-btn small-btn" data-id="${escapeHtml(a._id)}">Delete</button>` : ''}
          </div>
        </div>
        <div class="ann-text">${previewHtml}</div>
      </div>
    `;
  }).join('');
}


/* --- open announcement detail, attempt to mark this announcement as read on server --- */
async function openAnnouncementDetail(ann, announcementsContext = []) {
  // mark opened locally
  addOpened(ann._id);

  // remove 'new' styling immediately for a snappy UI (client-side)
  try {
    const row = document.querySelector(`.ann-row[data-id="${ann._id}"]`);
    if (row) {
      row.classList.remove('ann-unopened');
      const badge = row.querySelector('.ann-new-badge');
      if (badge) badge.remove();
      // optionally update preview to reflect opened state (no-op here since we removed new badge)
    }
  } catch (e) { /* ignore DOM errors */ }

  // (rest of your existing code: render modal, tryMarkSingleRead, etc.)
  const html = `
    <h3 style="margin:0">${escapeHtml(ann.title || 'Announcement')}</h3>
    <div style="color:#6b7280;font-size:13px;margin-top:6px">${escapeHtml(new Date(ann.createdAt || Date.now()).toLocaleString())}</div>
    <div style="margin-top:12px" class="ann-text">${formatAnnouncementText(ann.text || '')}</div>
    
    <div style="margin-top:16px;display:flex;justify-content:space-between;align-items:center;gap:8px">
      <div style="display:flex;gap:8px">
        ${isAdmin() ? `<button id="ann_detail_edit" class="small-btn">Edit</button>` : ''}
        <button id="ann_detail_close" class="small-btn">Close</button>
      </div>
      <div>
        <button id="ann_detail_mark_read" class="btn-ghost">Mark all read</button>
      </div>
    </div>
  `;
  showModal(html);


  // attempt to mark this announcement as read on the server for the logged-in user.
  // Many backends support "mark-read" (all) only ‚Äî so try per-id payload first, fallback to nothing.
  async function tryMarkSingleRead(id) {
    if (!getToken()) return false; // guest can't mark on server
    try {
      // try per-id marking (server should accept { ids: [id] } or { id })
      const try1 = await fetchJson('/api/help/mark-read', {
        method: 'POST',
        headers: authHeaders(true),
        body: JSON.stringify({ ids: [id] })
      });
      if (try1.ok) return true;
      // attempt alternate key 'id'
      const try2 = await fetchJson('/api/help/mark-read', {
        method: 'POST',
        headers: authHeaders(true),
        body: JSON.stringify({ id })
      });
      if (try2.ok) return true;
    } catch (e) { /* ignore */ }
    return false;
  }

  // run best-effort marking: if backend can mark single, badge will be refreshed from server
  const singleMarked = await tryMarkSingleRead(ann._id);
  if (singleMarked) {
    await fetchHelpUnreadCount(announcementsContext);
  } else {
    // fallback ‚Äî server unchanged: update badge by re-fetching server count and subtracting local opened overlap
    await fetchHelpUnreadCount(announcementsContext);
  }

  // handlers
  document.getElementById('ann_detail_close').onclick = () => { closeModal(); fetchHelpUnreadCount(announcementsContext); };

  document.getElementById('ann_detail_mark_read').onclick = async () => {
    if (!getToken()) { alert('Please login to mark announcements read.'); return; }
    const rr = await fetchJson('/api/help/mark-read', { method: 'POST', headers: authHeaders(true) });
    if (!rr.ok) return alert('Failed to mark read: ' + (rr.error || ''));
    // server updated ‚Äî clear local opened set (they are now read on server)
    try { localStorage.removeItem(OPENED_KEY); } catch(e) {}
    await fetchHelpUnreadCount(announcementsContext);
    alert('Marked announcements as read');
    closeModal();
  };

  // admin edit
  if (isAdmin()) {
    const editBtn = document.getElementById('ann_detail_edit');
    if (editBtn) editBtn.onclick = () => {
      const editHtml = `
        <h3>Edit announcement</h3>
        <div style="display:flex;flex-direction:column;gap:8px">
          <input id="admin_edit_title" placeholder="Title (optional)" value="${escapeHtml(ann.title || '')}" style="padding:8px;border-radius:6px;border:1px solid #e6e6e6">
          <textarea id="admin_edit_text" style="min-height:160px;padding:8px;border-radius:6px;border:1px solid #e6e6e6">${escapeHtml(ann.text || '')}</textarea>
          <div style="display:flex;gap:8px;justify-content:flex-end">
            <button id="admin_edit_cancel" class="btn-ghost">Cancel</button>
            <button id="admin_edit_save" class="btn-primary">Save</button>
          </div>
        </div>
      `;
      showModal(editHtml);
      document.getElementById('admin_edit_cancel').onclick = closeModal;
      document.getElementById('admin_edit_save').onclick = async () => {
        const newTitle = document.getElementById('admin_edit_title').value.trim();
        const newText = document.getElementById('admin_edit_text').value;
        if (!newText.trim()) return alert('Text required');
        const r = await fetchJson('/api/help/announcements/' + encodeURIComponent(ann._id), {
          method: 'PUT',
          headers: authHeaders(true),
          body: JSON.stringify({ title: newTitle, text: newText })
        });
        if (!r.ok) return alert('Save failed: ' + (r.error || ''));
        alert('Updated');
        closeModal();
        await fetchHelpUnreadCount();
        openBellModal(); // refresh list
      };
    };
  }  
}

/* --- openBellModal (list + admin create + mark all read) --- */
async function openBellModal() {
  const r = await fetchJson('/api/help/announcements?limit=200', { method: 'GET' });
  if (!r.ok) return alert('Failed to load announcements: ' + (r.error || ''));
  const ann = r.data.announcements || [];
  const is_admin = isAdmin();

  const adminCreateHtml = is_admin ? `
    <hr style="margin:12px 0">
    <div style="display:flex;flex-direction:column;gap:8px">
      <input id="ann_new_title" placeholder="Title (optional)" style="padding:8px;border-radius:6px;border:1px solid #e6e6e6">
      <textarea id="ann_new_text" placeholder="Write announcement..." style="min-height:100px;padding:8px;border-radius:6px;border:1px solid #e6e6e6;white-space:pre-wrap"></textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end">
        <button id="ann_new_cancel" class="btn-ghost">Cancel</button>
        <button id="ann_new_create" class="btn-primary">Create</button>
      </div>
    </div>` : '';

  const listHTML = buildAnnouncementsListHTML(ann);

  const html = `
    <h3 style="display:flex;justify-content:space-between;align-items:center;margin:0">
      <span>Announcements</span>
      <small style="color:#6b7280">${ann.length} total</small>
    </h3>
    <div style="margin-top:10px;max-height:50vh;overflow:auto;padding:8px;background:#fff;border:1px solid #f3f5f7;border-radius:8px">
      ${listHTML}
    </div>
    ${adminCreateHtml}
    <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px">
      <button id="bell_close_btn" class="btn-ghost">Close</button>
      <button id="bell_mark_read_btn" class="btn-ghost">Mark all read</button>
    </div>
  `;
  showModal(html);

  // attach handlers
  document.getElementById('bell_close_btn').onclick = closeModal;

  document.getElementById('bell_mark_read_btn').onclick = async () => {
    if (!getToken()) return alert('Please login to mark announcements read.');
    const rr = await fetchJson('/api/help/mark-read', { method: 'POST', headers: authHeaders(true) });
    if (!rr.ok) return alert('Failed to mark read: ' + (rr.error || ''));
    // server marked all ‚Äî clear local opened set
    try { localStorage.removeItem(OPENED_KEY); } catch(e) {}
    await fetchHelpUnreadCount(ann);
    alert('Marked announcements as read');
    closeModal();
  };

  // admin create
  if (is_admin) {
    document.getElementById('ann_new_cancel').onclick = () => {
      document.getElementById('ann_new_title').value = '';
      document.getElementById('ann_new_text').value = '';
    };
    document.getElementById('ann_new_create').onclick = async () => {
      const title = document.getElementById('ann_new_title').value.trim();
      const text = document.getElementById('ann_new_text').value;
      if (!text.trim()) return alert('Text required');
      // send raw multiline text (no trimming internal newlines)
      const res = await fetchJson('/api/help/announcements', {
        method: 'POST',
        headers: authHeaders(true),
        body: JSON.stringify({ title, text })
      });
      if (!res.ok) return alert('Create failed: ' + (res.error || ''));
      alert('Created');
      closeModal();
      await fetchHelpUnreadCount();
      openBellModal();
    };
  }

  // event delegation inside modal for open/edit/delete buttons
  const modalRoot = document.getElementById('modalRoot') || document.getElementById('modal-root') || document;
  modalRoot.querySelectorAll('.ann-open').forEach(b => b.onclick = async (e) => {
    const id = e.currentTarget.dataset.id;
    if (!id) return;
    // find announcement in current list
    const a = (ann || []).find(x => String(x._id) === String(id));
    if (!a) {
      // fallback: re-fetch single announcement list then open
      const rr = await fetchJson('/api/help/announcements?limit=200', { method: 'GET' });
      if (!rr.ok) return alert('Failed to load announcement: ' + (rr.error || ''));
      const a2 = (rr.data.announcements || []).find(x => String(x._id) === String(id));
      if (!a2) return alert('Announcement not found');
      return openAnnouncementDetail(a2, rr.data.announcements || []);
    }
    return openAnnouncementDetail(a, ann);
  });

  modalRoot.querySelectorAll('.ann-delete-btn').forEach(b => b.onclick = async (e) => {
    const id = e.currentTarget.dataset.id;
    if (!id) return;
    if (!confirm('Delete this announcement?')) return;
    const res = await fetchJson('/api/help/announcements/' + encodeURIComponent(id), { method: 'DELETE', headers: authHeaders(true) });
    if (!res.ok) return alert('Delete failed: ' + (res.error || ''));
    alert('Deleted');
    closeModal();
    await fetchHelpUnreadCount();
    openBellModal();
  });

  modalRoot.querySelectorAll('.ann-edit-btn').forEach(b => b.onclick = async (e) => {
    const id = e.currentTarget.dataset.id;
    if (!id) return;
    const a = (ann || []).find(x => String(x._id) === String(id));
    if (!a) return alert('Announcement not found');
    // open edit modal (same UI as detail edit)
    openAnnouncementDetail(a, ann); // open detail -> admin can press edit inside
  });

  // update badge taking into account announcements list (so local opened items show correctly)
  fetchHelpUnreadCount(ann);
}

  // attach bell button event (btn-help)
  const helpBtn = document.getElementById('btn-help');
  if (helpBtn) helpBtn.onclick = openBellModal;

/* patch applyNavUI if present to start polling + set up badge */
(function initBellPolling(){
  if (typeof applyNavUI === 'function') {
    const orig = applyNavUI;
    window.applyNavUI = function(...args) {
      try { orig(...args); } catch(e) { console.warn('applyNavUI err', e); }
      try { fetchHelpUnreadCount(); } catch(e) {}
      if (window.helpPollTimer) clearInterval(window.helpPollTimer);
      window.helpPollTimer = setInterval(() => fetchHelpUnreadCount(), 20000);
    };
    // call once
    try { applyNavUI(); } catch(e) { fetchHelpUnreadCount(); }
  } else {
    fetchHelpUnreadCount();
    if (window.helpPollTimer) clearInterval(window.helpPollTimer);
    window.helpPollTimer = setInterval(() => fetchHelpUnreadCount(), 20000);
  }
})();

  // initial run
  if (typeof applyNavUI === 'function') applyNavUI();
  else fetchHelpUnreadCount();

  // Expose small API for debug if needed
  window.BellModule = { open: openBellModal, refreshBadge: fetchHelpUnreadCount, markOpened: addOpened };



  /* ---------- AUTH HELPERS (drop-in) ---------- */
/* Ensure getToken/getUser/isAdmin are defined (safe re-definitions if not present) */
function getToken(){ return localStorage.getItem('token'); }
function getUser(){ try { const s = localStorage.getItem('user'); return s ? JSON.parse(s) : null;} catch(e){ return null; } }
function isAdmin(){ const u = getUser(); return !!(u && (u.role === 'admin' || u.isAdmin)); }



/******************* AUTH & NAV PATCH (DROP-IN REPLACEMENT) *******************/
/* Replace existing doLogin, doLogout, applyNavUI, attachAuthButtons, and
   mobile/settings update logic with these. They rely on: fetchJson(), showModal(),
   closeModal(), getToken(), getUser(), authHeaders(), isAdmin(), escapeHtml(). */

   /* ---------- Countries + cities ---------- */
/* Minimal countries list: you can extend with more codes/names.
   Flags are computed from ISO codes (Android/iOS render emoji).
   Custom codes (e.g. XS-SL) can be mapped in CUSTOM_FLAG_MAP. */
   const COUNTRIES = [
  { code: 'AF', name: 'Afghanistan' },
  { code: 'AL', name: 'Albania' },
  { code: 'DZ', name: 'Algeria' },
  { code: 'AD', name: 'Andorra' },
  { code: 'AO', name: 'Angola' },
  { code: 'AG', name: 'Antigua and Barbuda' },
  { code: 'AR', name: 'Argentina' },
  { code: 'AM', name: 'Armenia' },
  { code: 'AU', name: 'Australia' },
  { code: 'AT', name: 'Austria' },
  { code: 'AZ', name: 'Azerbaijan' },
  { code: 'BS', name: 'Bahamas' },
  { code: 'BH', name: 'Bahrain' },
  { code: 'BD', name: 'Bangladesh' },
  { code: 'BB', name: 'Barbados' },
  { code: 'BY', name: 'Belarus' },
  { code: 'BE', name: 'Belgium' },
  { code: 'BZ', name: 'Belize' },
  { code: 'BJ', name: 'Benin' },
  { code: 'BT', name: 'Bhutan' },
  { code: 'BO', name: 'Bolivia (Plurinational State of)' },
  { code: 'BA', name: 'Bosnia and Herzegovina' },
  { code: 'BW', name: 'Botswana' },
  { code: 'BR', name: 'Brazil' },
  { code: 'BN', name: 'Brunei Darussalam' },
  { code: 'BG', name: 'Bulgaria' },
  { code: 'BF', name: 'Burkina Faso' },
  { code: 'BI', name: 'Burundi' },
  { code: 'CV', name: 'Cabo Verde' },
  { code: 'KH', name: 'Cambodia' },
  { code: 'CM', name: 'Cameroon' },
  { code: 'CA', name: 'Canada' },
  { code: 'CF', name: 'Central African Republic' },
  { code: 'TD', name: 'Chad' },
  { code: 'CL', name: 'Chile' },
  { code: 'CN', name: 'China' },
  { code: 'CO', name: 'Colombia' },
  { code: 'KM', name: 'Comoros' },
  { code: 'CG', name: 'Congo' },
  { code: 'CD', name: 'Congo, Democratic Republic of the' },
  { code: 'CR', name: 'Costa Rica' },
  { code: 'CI', name: "C√¥te d'Ivoire" },
  { code: 'HR', name: 'Croatia' },
  { code: 'CU', name: 'Cuba' },
  { code: 'CY', name: 'Cyprus' },
  { code: 'CZ', name: 'Czechia' },
  { code: 'DK', name: 'Denmark' },
  { code: 'DJ', name: 'Djibouti' },
  { code: 'DM', name: 'Dominica' },
  { code: 'DO', name: 'Dominican Republic' },
  { code: 'EC', name: 'Ecuador' },
  { code: 'EG', name: 'Egypt' },
  { code: 'SV', name: 'El Salvador' },
  { code: 'GQ', name: 'Equatorial Guinea' },
  { code: 'ER', name: 'Eritrea' },
  { code: 'EE', name: 'Estonia' },
  { code: 'SZ', name: 'Eswatini' },
  { code: 'ET', name: 'Ethiopia' },
  { code: 'FJ', name: 'Fiji' },
  { code: 'FI', name: 'Finland' },
  { code: 'FR', name: 'France' },
  { code: 'GA', name: 'Gabon' },
  { code: 'GM', name: 'Gambia' },
  { code: 'GE', name: 'Georgia' },
  { code: 'DE', name: 'Germany' },
  { code: 'GH', name: 'Ghana' },
  { code: 'GR', name: 'Greece' },
  { code: 'GD', name: 'Grenada' },
  { code: 'GT', name: 'Guatemala' },
  { code: 'GN', name: 'Guinea' },
  { code: 'GW', name: 'Guinea-Bissau' },
  { code: 'GY', name: 'Guyana' },
  { code: 'HT', name: 'Haiti' },
  { code: 'HN', name: 'Honduras' },
  { code: 'HU', name: 'Hungary' },
  { code: 'IS', name: 'Iceland' },
  { code: 'IN', name: 'India' },
  { code: 'ID', name: 'Indonesia' },
  { code: 'IR', name: 'Iran (Islamic Republic of)' },
  { code: 'IQ', name: 'Iraq' },
  { code: 'IE', name: 'Ireland' },
  { code: 'IL', name: 'Israel' },
  { code: 'IT', name: 'Italy' },
  { code: 'JM', name: 'Jamaica' },
  { code: 'JP', name: 'Japan' },
  { code: 'JO', name: 'Jordan' },
  { code: 'KZ', name: 'Kazakhstan' },
  { code: 'KE', name: 'Kenya' },
  { code: 'KI', name: 'Kiribati' },
  { code: 'KW', name: 'Kuwait' },
  { code: 'KG', name: 'Kyrgyzstan' },
  { code: 'LA', name: "Lao People's Democratic Republic" },
  { code: 'LV', name: 'Latvia' },
  { code: 'LB', name: 'Lebanon' },
  { code: 'LS', name: 'Lesotho' },
  { code: 'LR', name: 'Liberia' },
  { code: 'LY', name: 'Libya' },
  { code: 'LI', name: 'Liechtenstein' },
  { code: 'LT', name: 'Lithuania' },
  { code: 'LU', name: 'Luxembourg' },
  { code: 'MG', name: 'Madagascar' },
  { code: 'MW', name: 'Malawi' },
  { code: 'MY', name: 'Malaysia' },
  { code: 'MV', name: 'Maldives' },
  { code: 'ML', name: 'Mali' },
  { code: 'MT', name: 'Malta' },
  { code: 'MH', name: 'Marshall Islands' },
  { code: 'MR', name: 'Mauritania' },
  { code: 'MU', name: 'Mauritius' },
  { code: 'MX', name: 'Mexico' },
  { code: 'MC', name: 'Monaco' },
  { code: 'MN', name: 'Mongolia' },
  { code: 'ME', name: 'Montenegro' },
  { code: 'MA', name: 'Morocco' },
  { code: 'MZ', name: 'Mozambique' },
  { code: 'MM', name: 'Myanmar' },
  { code: 'NA', name: 'Namibia' },
  { code: 'NR', name: 'Nauru' },
  { code: 'NP', name: 'Nepal' },
  { code: 'NL', name: 'Netherlands' },
  { code: 'NZ', name: 'New Zealand' },
  { code: 'NI', name: 'Nicaragua' },
  { code: 'NE', name: 'Niger' },
  { code: 'NG', name: 'Nigeria' },
  { code: 'KP', name: "Korea (Democratic People's Republic of)" },
  { code: 'KR', name: 'Korea (Republic of)' },
  { code: 'MK', name: 'North Macedonia' },
  { code: 'NO', name: 'Norway' },
  { code: 'OM', name: 'Oman' },
  { code: 'PK', name: 'Pakistan' },
  { code: 'PW', name: 'Palau' },
  { code: 'PA', name: 'Panama' },
  { code: 'PG', name: 'Papua New Guinea' },
  { code: 'PY', name: 'Paraguay' },
  { code: 'PE', name: 'Peru' },
  { code: 'PH', name: 'Philippines' },
  { code: 'PL', name: 'Poland' },
  { code: 'PT', name: 'Portugal' },
  { code: 'QA', name: 'Qatar' },
  { code: 'RO', name: 'Romania' },
  { code: 'RU', name: 'Russian Federation' },
  { code: 'RW', name: 'Rwanda' },
  { code: 'KN', name: 'Saint Kitts and Nevis' },
  { code: 'LC', name: 'Saint Lucia' },
  { code: 'VC', name: 'Saint Vincent and the Grenadines' },
  { code: 'WS', name: 'Samoa' },
  { code: 'SM', name: 'San Marino' },
  { code: 'ST', name: 'Sao Tome and Principe' },
  { code: 'SA', name: 'Saudi Arabia' },
  { code: 'SN', name: 'Senegal' },
  { code: 'RS', name: 'Serbia' },
  { code: 'SC', name: 'Seychelles' },
  { code: 'SL', name: 'Sierra Leone' },
  { code: 'SG', name: 'Singapore' },
  { code: 'SK', name: 'Slovakia' },
  { code: 'SI', name: 'Slovenia' },
  { code: 'SB', name: 'Solomon Islands' },
  { code: 'SO', name: 'Somalia' },
  { code: 'ZA', name: 'South Africa' },
  { code: 'SS', name: 'South Sudan' },
  { code: 'ES', name: 'Spain' },
  { code: 'LK', name: 'Sri Lanka' },
  { code: 'SD', name: 'Sudan' },
  { code: 'SR', name: 'Suriname' },
  { code: 'SE', name: 'Sweden' },
  { code: 'CH', name: 'Switzerland' },
  { code: 'SY', name: 'Syrian Arab Republic' },
  { code: 'TJ', name: 'Tajikistan' },
  { code: 'TZ', name: 'Tanzania, United Republic of' },
  { code: 'TH', name: 'Thailand' },
  { code: 'TL', name: 'Timor-Leste' },
  { code: 'TG', name: 'Togo' },
  { code: 'TO', name: 'Tonga' },
  { code: 'TT', name: 'Trinidad and Tobago' },
  { code: 'TN', name: 'Tunisia' },
  { code: 'TR', name: 'T√ºrkiye' },
  { code: 'TM', name: 'Turkmenistan' },
  { code: 'TV', name: 'Tuvalu' },
  { code: 'UG', name: 'Uganda' },
  { code: 'UA', name: 'Ukraine' },
  { code: 'AE', name: 'United Arab Emirates' },
  { code: 'GB', name: 'United Kingdom' },
  { code: 'US', name: 'United States' },
  { code: 'UY', name: 'Uruguay' },
  { code: 'UZ', name: 'Uzbekistan' },
  { code: 'VU', name: 'Vanuatu' },
  { code: 'VE', name: 'Venezuela (Bolivarian Republic of)' },
  { code: 'VN', name: 'Viet Nam' },
  { code: 'YE', name: 'Yemen' },
  { code: 'ZM', name: 'Zambia' },
  { code: 'ZW', name: 'Zimbabwe' }
];


// custom flag overrides for non-standard codes
const CUSTOM_FLAG_MAP = {
  'XS-SL': 'üè≥Ô∏è', // Somaliland fallback
  'XN-SL': 'üè≥Ô∏è',
  'XK': 'üáΩüá∞'
};

// convert ISO alpha-2 to flag emoji e.g. 'US' -> üá∫üá∏
// fallback to CUSTOM_FLAG_MAP for custom codes
function codeToFlagEmoji(code) {
  if (!code) return '';
  if (CUSTOM_FLAG_MAP[code]) return CUSTOM_FLAG_MAP[code];
  const c = String(code).trim().toUpperCase();
  if (c.length !== 2) return '';
  const A = 0x1F1E6;
  const first = c.charCodeAt(0) - 65;
  const second = c.charCodeAt(1) - 65;
  if (first < 0 || first > 25 || second < 0 || second > 25) return '';
  return String.fromCodePoint(A + first) + String.fromCodePoint(A + second);
}

/* Cities mapping (country code -> array of cities) */
/* I expanded Somalia list per your request. Add more countries as needed. */


const CITIES_BY_COUNTRY = {
  "AF": ["Kabul", "Kandahar", "Mazar-i-Sharif", "Herat"],
  "AL": ["Tirana", "Durr√´s", "Vlor√´", "Shkod√´r"],
  "DZ": ["Algiers", "Oran", "Constantine", "Annaba"],
  "AD": ["Andorra la Vella", "Encamp", "Sant Juli√† de L√≤ria", "La Massana"],
  "AO": ["Luanda", "N'dalatando", "Huambo", "Lobito"],
  "AG": ["St. John's", "All Saints", "Liberta", "Potters Village"],
  "AR": ["Buenos Aires", "C√≥rdoba", "Rosario", "Mendoza"],
  "AM": ["Yerevan", "Gyumri", "Vanadzor", "Vagharshapat"],
  "AU": ["Canberra", "Sydney", "Melbourne", "Brisbane"],
  "AT": ["Vienna", "Graz", "Linz", "Salzburg"],
  "AZ": ["Baku", "Ganja", "Sumqayit", "Lankaran"],
  "BS": ["Nassau", "Freeport", "West End", "Marsh Harbour"],
  "BH": ["Manama", "Riffa", "Muharraq", "Hamad Town"],
  "BD": ["Dhaka", "Chittagong", "Khulna", "Rajshahi"],
  "BB": ["Bridgetown", "Speightstown", "Oistins", "Holetown"],
  "BY": ["Minsk", "Gomel", "Mogilev", "Vitebsk"],
  "BE": ["Brussels", "Antwerp", "Ghent", "Charleroi"],
  "BZ": ["Belmopan", "Belize City", "San Ignacio", "Dangriga"],
  "BJ": ["Porto-Novo", "Cotonou", "Parakou", "Abomey-Calavi"],
  "BT": ["Thimphu", "Phuntsholing", "Punakha", "Trashigang"],
  "BO": ["Sucre", "La Paz", "Santa Cruz de la Sierra", "Cochabamba"],
  "BA": ["Sarajevo", "Banja Luka", "Mostar", "Tuzla"],
  "BW": ["Gaborone", "Francistown", "Maun", "Molepolole"],
  "BR": ["Bras√≠lia", "S√£o Paulo", "Rio de Janeiro", "Salvador"],
  "BN": ["Bandar Seri Begawan", "Kuala Belait", "Seria", "Tutong"],
  "BG": ["Sofia", "Plovdiv", "Varna", "Burgas"],
  "BF": ["Ouagadougou", "Bobo-Dioulasso", "Koudougou", "Banfora"],
  "BI": ["Gitega", "Bujumbura", "Ngozi", "Muyinga"],
  "CV": ["Praia", "Mindelo", "Santa Maria", "S√£o Filipe"],
  "KH": ["Phnom Penh", "Siem Reap", "Battambang", "Kampong Cham"],
  "CM": ["Yaound√©", "Douala", "Garoua", "Bamenda"],
  "CA": ["Ottawa", "Toronto", "Montreal", "Vancouver"],
  "CF": ["Bangui", "Bambari", "Berb√©rati", "Bossangoa"],
  "TD": ["N'Djamena", "Moundou", "Sarh", "Ab√©ch√©"],
  "CL": ["Santiago", "Concepci√≥n", "Valpara√≠so", "Antofagasta"],
  "CN": ["Beijing", "Shanghai", "Guangzhou", "Shenzhen"],
  "CO": ["Bogot√°", "Medell√≠n", "Cali", "Barranquilla"],
  "KM": ["Moroni", "Mitsamiouli", "Fomboni", "Mbeni"],
  "CG": ["Brazzaville", "Pointe-Noire", "Dolisie", "Nkayi"],
  "CD": ["Kinshasa", "Lubumbashi", "Mbuji-Mayi", "Kananga"],
  "CR": ["San Jos√©", "Cartago", "Alajuela", "Liberia"],
  "CI": ["Yamoussoukro", "Abidjan", "Bouak√©", "Daloa"],
  "HR": ["Zagreb", "Split", "Rijeka", "Osijek"],
  "CU": ["Havana", "Santiago de Cuba", "Camag√ºey", "Holgu√≠n"],
  "CY": ["Nicosia", "Limassol", "Larnaca", "Famagusta"],
  "CZ": ["Prague", "Brno", "Ostrava", "Plze≈à"],
  "DK": ["Copenhagen", "Aarhus", "Odense", "Aalborg"],
  "DJ": ["Djibouti", "Tadjoura", "Ali Sabieh", "Obock"],
  "DM": ["Roseau", "Dominica (Roseau area)", "Portsmouth", "Mahaut"],
  "DO": ["Santo Domingo", "Santiago de los Caballeros", "La Romana", "San Pedro de Macor√≠s"],
  "EC": ["Quito", "Guayaquil", "Cuenca", "Santo Domingo de los Ts√°chilas"],
  "EG": ["Cairo", "Alexandria", "Giza", "Shubra El-Kheima"],
  "SV": ["San Salvador", "Santa Ana", "San Miguel", "Soyapango"],
  "GQ": ["Malabo", "Bata", "Ebebiy√≠n", "Aconibe"],
  "ER": ["Asmara", "Keren", "Massawa", "Mendefera"],
  "EE": ["Tallinn", "Tartu", "Narva", "P√§rnu"],
  "SZ": ["Mbabane", "Lobamba", "Manzini", "Nhlangano"],
  "ET": ["Addis Ababa", "Dire Dawa", "Mekelle", "Bahir Dar"],
  "FJ": ["Suva", "Nadi", "Lautoka", "Labasa"],
  "FI": ["Helsinki", "Espoo", "Tampere", "Vantaa"],
  "FR": ["Paris", "Marseille", "Lyon", "Toulouse"],
  "GA": ["Libreville", "Port-Gentil", "Franceville", "Oyem"],
  "GM": ["Banjul", "Serekunda", "Brikama", "Bakau"],
  "GE": ["Tbilisi", "Batumi", "Kutaisi", "Rustavi"],
  "DE": ["Berlin", "Hamburg", "Munich", "Cologne"],
  "GH": ["Accra", "Kumasi", "Tamale", "Takoradi"],
  "GR": ["Athens", "Thessaloniki", "Patras", "Heraklion"],
  "GD": ["St. George's", "Gouyave", "Victoria", "Sauteurs"],
  "GT": ["Guatemala City", "Quetzaltenango", "Escuintla", "Huehuetenango"],
  "GN": ["Conakry", "Kankan", "Nz√©r√©kor√©", "Kindia"],
  "GW": ["Bissau", "Bafata", "Gab√∫", "Cacheu"],
  "GY": ["Georgetown", "Linden", "New Amsterdam", "Bartica"],
  "HT": ["Port-au-Prince", "Cap-Ha√Øtien", "Gona√Øves", "Jacmel"],
  "HN": ["Tegucigalpa", "San Pedro Sula", "Choloma", "La Ceiba"],
  "HU": ["Budapest", "Debrecen", "Szeged", "Miskolc"],
  "IS": ["Reykjav√≠k", "K√≥pavogur", "Hafnarfj√∂r√∞ur", "Akureyri"],
  "IN": ["New Delhi", "Mumbai", "Kolkata", "Bengaluru"],
  "ID": ["Jakarta", "Surabaya", "Bandung", "Medan"],
  "IR": ["Tehran", "Mashhad", "Isfahan", "Karaj"],
  "IQ": ["Baghdad", "Basra", "Mosul", "Erbil"],
  "IE": ["Dublin", "Cork", "Limerick", "Galway"],
  "IL": ["Jerusalem", "Tel Aviv-Yafo", "Haifa", "Rishon LeZion"],
  "IT": ["Rome", "Milan", "Naples", "Turin"],
  "JM": ["Kingston", "Montego Bay", "Spanish Town", "Mandeville"],
  "JP": ["Tokyo", "Yokohama", "Osaka", "Nagoya"],
  "JO": ["Amman", "Zarqa", "Irbid", "Russeifa"],
  "KZ": ["Astana (Nur-Sultan)", "Almaty", "Shymkent", "Karagandy"],
  "KE": ["Nairobi", "Mombasa", "Kisumu", "Nakuru"],
  "KI": ["South Tarawa", "Betio", "Bikenibeu", "Nanikai"],
  "KW": ["Kuwait City", "Al Ahmadi", "Hawalli", "Salmiya"],
  "KG": ["Bishkek", "Osh", "Jalal-Abad", "Karakol"],
  "LA": ["Vientiane", "Luang Prabang", "Savannakhet", "Pakse"],
  "LV": ["Riga", "Daugavpils", "LiepƒÅja", "Jelgava"],
  "LB": ["Beirut", "Tripoli", "Sidon", "Tyre"],
  "LS": ["Maseru", "Teyateyaneng", "Leribe", "Mafeteng"],
  "LR": ["Monrovia", "Gbarnga", "Buchanan", "Zwedru"],
  "LY": ["Tripoli", "Benghazi", "Misrata", "Zawiya"],
  "LI": ["Vaduz", "Schaan", "Balzers", "Triesen"],
  "LT": ["Vilnius", "Kaunas", "Klaipƒóda", "≈†iauliai"],
  "LU": ["Luxembourg", "Esch-sur-Alzette", "Differdange", "Dudelange"],
  "MG": ["Antananarivo", "Toamasina", "Fianarantsoa", "Mahajanga"],
  "MW": ["Lilongwe", "Blantyre", "Mzuzu", "Zomba"],
  "MY": ["Kuala Lumpur", "George Town", "Johor Bahru", "Kota Kinabalu"],
  "MV": ["Mal√©", "Addu City", "Fuvahmulah", "Hulhumal√©"],
  "ML": ["Bamako", "Sikasso", "Kayes", "Mopti"],
  "MT": ["Valletta", "Birkirkara", "Sliema", "Mdina"],
  "MH": ["Majuro", "Ebeye", "Laura", "Jaluit"],
  "MR": ["Nouakchott", "Nouadhibou", "Zou√©rat", "Rosso"],
  "MU": ["Port Louis", "Beau Bassin-Rose Hill", "Curepipe", "Quatre Bornes"],
  "MX": ["Mexico City", "Guadalajara", "Monterrey", "Puebla"],
  "MC": ["Monaco", "Monte Carlo", "La Condamine", "Fontvieille"],
  "MN": ["Ulaanbaatar", "Erdenet", "Darkhan", "Choibalsan"],
  "ME": ["Podgorica", "Nik≈°iƒá", "Herceg Novi", "Bar"],
  "MA": ["Rabat", "Casablanca", "Fes", "Marrakesh"],
  "MZ": ["Maputo", "Matola", "Nampula", "Beira"],
  "MM": ["Naypyidaw", "Yangon", "Mandalay", "Mawlamyine"],
  "NA": ["Windhoek", "Walvis Bay", "Swakopmund", "Rundu"],
  "NR": ["Yaren (de facto)", "Nauru (district)", "Denigomodu", "Buada"],
  "NP": ["Kathmandu", "Pokhara", "Lalitpur", "Biratnagar"],
  "NL": ["Amsterdam", "Rotterdam", "The Hague", "Utrecht"],
  "NZ": ["Wellington", "Auckland", "Christchurch", "Hamilton"],
  "NI": ["Managua", "Le√≥n", "Masaya", "Chinandega"],
  "NE": ["Niamey", "Zinder", "Maradi", "Dosso"],
  "NG": ["Abuja", "Lagos", "Kano", "Port Harcourt"],
  "KP": ["Pyongyang", "Hamhung", "Chongjin", "Nampo"],
  "KR": ["Seoul", "Busan", "Incheon", "Daegu"],
  "MK": ["Skopje", "Bitola", "Kumanovo", "Prilep"],
  "NO": ["Oslo", "Bergen", "Trondheim", "Stavanger"],
  "OM": ["Muscat", "Salalah", "Sohar", "Nizwa"],
  "PK": ["Islamabad", "Karachi", "Lahore", "Faisalabad"],
  "PW": ["Ngerulmud", "Koror", "Melekeok", "Airai"],
  "PA": ["Panama City", "Col√≥n", "David", "Santiago"],
  "PG": ["Port Moresby", "Lae", "Mount Hagen", "Goroka"],
  "PY": ["Asunci√≥n", "Ciudad del Este", "Encarnaci√≥n", "San Lorenzo"],
  "PE": ["Lima", "Arequipa", "Trujillo", "Chiclayo"],
  "PH": ["Manila", "Quezon City", "Cebu City", "Davao City"],
  "PL": ["Warsaw", "Krak√≥w", "≈Å√≥d≈∫", "Wroc≈Çaw"],
  "PT": ["Lisbon", "Porto", "Funchal", "Coimbra"],
  "QA": ["Doha", "Al Rayyan", "Umm Salal", "Al Wakrah"],
  "RO": ["Bucharest", "Cluj-Napoca", "Timi»ôoara", "Ia»ôi"],
  "RU": ["Moscow", "Saint Petersburg", "Novosibirsk", "Yekaterinburg"],
  "RW": ["Kigali", "Butare (Huye)", "Gisenyi (Rubavu)", "Kigoma"],
  "KN": ["Basseterre", "Charlestown", "Cayon", "Dieppe Bay Town"],
  "LC": ["Castries", "Gros Islet", "Vieux Fort", "Soufri√®re"],
  "VC": ["Kingstown", "Georgetown", "Barrouallie", "Chateaubelair"],
  "WS": ["Apia", "Vaitele", "Leulumoega", "Faleasi'u"],
  "SM": ["San Marino", "City of San Marino", "Borgo Maggiore", "Serravalle"],
  "ST": ["S√£o Tom√©", "Santo Ant√≥nio", "Neves", "Guadalupe"],
  "SA": ["Riyadh", "Jeddah", "Mecca", "Medina"],
  "SN": ["Dakar", "Touba", "Thi√®s", "Ziguinchor"],
  "RS": ["Belgrade", "Novi Sad", "Ni≈°", "Kragujevac"],
  "SC": ["Victoria (Mah√©)", "Anse Boileau", "Beau Vallon", "Glacis"],
  "SL": ["Freetown", "Bo", "Kenema", "Koidu"],
  "SG": ["Singapore", "Jurong East", "Woodlands", "Tampines"],
  "SK": ["Bratislava", "Ko≈°ice", "Pre≈°ov", "≈Ωilina"],
  "SI": ["Ljubljana", "Maribor", "Celje", "Kranj"],
  "SB": ["Honiara", "Auki", "Gizo", "Kirakira"],
'SO': [
    'Mogadishu',
    'Hargeisa',
    'Bosaso',
    'Galkayo',
    'Kismayo',
    'Garowe',
    'Burao',
    'Berbera',
    'Baidoa',
    'Beledweyne',
    'Bardhere',
    'Laascaanood',
    'Jowhar',
    'Luuq',
    'Afmadow',
    'Afgooye',
    'El Wak',
    'Borama',
    'Eyl',
    'Jilib',
   'Hargeisa', 
   'Burao', 
   'Berbera', 
   'Gabiley' ],
    "ZA": ["Pretoria", "Johannesburg", "Cape Town", "Durban"],
  "SS": ["Juba", "Malakal", "Wau", "Bor"],
  "ES": ["Madrid", "Barcelona", "Valencia", "Seville"],
  "LK": ["Sri Jayawardenepura Kotte", "Colombo", "Kandy", "Galle"],
  "SD": ["Khartoum", "Omdurman", "Port Sudan", "Kassala"],
  "SR": ["Paramaribo", "Lelydorp", "Nieuw Nickerie", "Moengo"],
  "SE": ["Stockholm", "Gothenburg", "Malm√∂", "Uppsala"],
  "CH": ["Bern", "Zurich", "Geneva", "Basel"],
  "SY": ["Damascus", "Aleppo", "Homs", "Hama"],
  "TJ": ["Dushanbe", "Khujand", "Kulob", "Istaravshan"],
  "TZ": ["Dodoma", "Dar es Salaam", "Mwanza", "Arusha"],
  "TH": ["Bangkok", "Chiang Mai", "Phuket", "Hat Yai"],
  "TL": ["Dili", "Baucau", "Dili District (Asumanu)", "Suai"],
  "TG": ["Lom√©", "Sokod√©", "Kara", "Atakpam√©"],
  "TO": ["Nuku'alofa", "Neiafu", "Havelu", "Vaini"],
  "TT": ["Port of Spain", "San Fernando", "Chaguanas", "Arima"],
  "TN": ["Tunis", "Sfax", "Sousse", "Kairouan"],
  "TR": ["Ankara", "Istanbul", "ƒ∞zmir", "Bursa"],
  "TM": ["Ashgabat", "Turkmenabat", "Mary", "Dashoguz"],
  "TV": ["Funafuti", "Vaiaku", "Fongafale", "Vaitupu"],
  "UG": ["Kampala", "Gulu", "Lira", "Mbarara"],
  "UA": ["Kyiv", "Kharkiv", "Odesa", "Dnipro"],
  "AE": ["Abu Dhabi", "Dubai", "Sharjah", "Al Ain"],
  "GB": ["London", "Birmingham", "Leeds", "Glasgow"],
  "US": ["Washington, D.C.", "New York", "Los Angeles", "Chicago"],
  "UY": ["Montevideo", "Salto", "Punta del Este", "Paysand√∫"],
  "UZ": ["Tashkent", "Samarkand", "Bukhara", "Namangan"],
  "VU": ["Port Vila", "Luganville", "Norsup", "Lenakel"],
  "VE": ["Caracas", "Maracaibo", "Valencia", "Barquisimeto"],
  "VN": ["Hanoi", "Ho Chi Minh City", "Da Nang", "Hai Phong"],
  "YE": ["Sana'a", "Aden", "Taiz", "Al Hudaydah"],
  "ZM": ["Lusaka", "Ndola", "Kitwe", "Livingstone"],
  "ZW": ["Harare", "Bulawayo", "Mutare", "Gweru"]
};





   /* ---------- COUNTRIES: code, name, flag (emoji or short label) ---------- */











   function buildCountrySelectHtml(selectedCode = '') {
  const opts = COUNTRIES.map(c => {
    const code = c.code || '';
    const emoji = codeToFlagEmoji(code);
    const sel = code === selectedCode ? 'selected' : '';
    return `<option value="${escapeHtml(code)}" ${sel}>${escapeHtml(emoji ? emoji + ' ' + c.name : c.name)}</option>`;
  }).join('');
  return `<select id="profile_country" aria-label="Country" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">${opts}</select>`;
}

function buildCitySelectHtml(countryCode = '', selectedCity = '') {
  const cities = (CITIES_BY_COUNTRY[countryCode] || []);
  if (!cities.length) {
    // fallback to a free input if there is no predefined list
    return `<input id="profile_city" placeholder="City" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff" value="${escapeHtml(selectedCity||'')}">`;
  }
  const opts = cities.map(c => {
    const sel = String(c) === String(selectedCity) ? 'selected' : '';
    return `<option value="${escapeHtml(c)}" ${sel}>${escapeHtml(c)}</option>`;
  }).join('');
  return `<select id="profile_city" style="width:100%; padding:8px; border-radius:8px; border:1px solid #eef2ff">${opts}</select>`;
}


// fetchRESTCountries builds a list, merges extras and returns an array: { name, code, flag, emoji, callingCode }
async function fetchRESTCountries() {
  try {
    const res = await fetch('https://restcountries.com/v3.1/all?fields=name,cca2,flags,idd');
    const arr = await res.json();
    const mapped = arr.map(c => {
      const code = (c.cca2 || '').toUpperCase();
      const name = (c.name && (c.name.common || c.name.official)) ? (c.name.common || c.name.official) : '';
      const flag = (c.flags && (c.flags.svg || c.flags.png)) ? (c.flags.svg || c.flags.png) : null;
      // idd.root and idd.suffixes to build calling code (best effort)
      let calling = null;
      try {
        if (c.idd && c.idd.root) {
          calling = c.idd.root + ((c.idd && Array.isArray(c.idd.suffixes) && c.idd.suffixes[0]) ? c.idd.suffixes[0] : '');
        }
      } catch(e){}
      return { name, code, flag, callingCode: calling };
    }).sort((a,b)=> a.name.localeCompare(b.name));
    // add de-facto entries manually
    const extras = [
      { name: 'Somaliland (de-facto)', code: 'XS-SL', flag: 'https://upload.wikimedia.org/wikipedia/commons/0/0c/Flag_of_Somaliland.svg', callingCode: '+252 (use local)' },
      { name: 'Taiwan (Republic of China)', code: 'TW', flag: 'https://upload.wikimedia.org/wikipedia/commons/7/72/Flag_of_the_Republic_of_China.svg', callingCode: '+886' },
      { name: 'Kosovo', code: 'XK', flag: 'https://upload.wikimedia.org/wikipedia/commons/1/1f/Flag_of_Kosovo.svg', callingCode: '+383' },
      { name: 'Palestine', code: 'PS', flag: 'https://upload.wikimedia.org/wikipedia/commons/0/00/Flag_of_Palestine.svg', callingCode: '+970' }
    ];
    // merge, avoid duplicates (by code)
    const have = new Set(mapped.map(m => m.code));
    extras.forEach(e => { if (!have.has(e.code)) mapped.push(e); });
    return mapped.sort((a,b)=> a.name.localeCompare(b.name));
  } catch (err) {
    console.error('fetchRESTCountries failed', err);
    // fallback: small set
    return [
      { name:'Somalia', code:'SO', flag: 'https://restcountries.com/data/som.svg', callingCode: '+252' },
      { name:'Somaliland (de-facto)', code:'XS-SL', flag:'https://upload.wikimedia.org/wikipedia/commons/0/0c/Flag_of_Somaliland.svg', callingCode: '+252' },
      { name:'Taiwan', code:'TW', flag:'https://upload.wikimedia.org/wikipedia/commons/7/72/Flag_of_the_Republic_of_China.svg', callingCode:'+886' },
      { name:'United States', code:'US', flag:'https://restcountries.com/data/usa.svg', callingCode:'+1' }
    ];
  }
}

// populate select example
async function populateCountrySelect(selectEl) {
  const countries = await fetchRESTCountries();
  selectEl.innerHTML = '<option value="">Select country</option>' + countries.map(c => {
    const optFlag = c.flag ? ` data-flag="${c.flag}"` : '';
    const code = c.code || '';
    return `<option value="${escapeHtml(code)}"${optFlag}>${escapeHtml(c.name)} ${code ? '('+escapeHtml(code)+')' : ''}</option>`;
  }).join('');
}


function debouncePromise(fn, wait = 420) {
  let timer = null;
  let lastReject = null;
  return (...args) => {
    // cancel previous if pending
    if (timer) clearTimeout(timer);
    if (lastReject) {
      try { lastReject({ cancelled: true }); } catch(e){}
      lastReject = null;
    }
    return new Promise((resolve, reject) => {
      lastReject = reject;
      timer = setTimeout(async () => {
        lastReject = null;
        timer = null;
        try {
          const out = await fn(...args);
          resolve(out);
        } catch (err) {
          reject(err);
        }
      }, wait);
    });
  };
}

/* password eye - robust wrapper: wraps input in .pw-wrapper and adds animated eye icon */
function attachPasswordEye(inputElem) {
  if (!inputElem) return null;
  if (inputElem._hasEye) return inputElem._eyeBtn;

  // create wrapper if not already
  let wrapper = inputElem.closest('.pw-wrapper');
  if (!wrapper) {
    wrapper = document.createElement('div');
    wrapper.className = 'pw-wrapper';
    inputElem.parentNode.replaceChild(wrapper, inputElem);
    wrapper.appendChild(inputElem);
  }

  // ensure input styling
  inputElem.style.width = '100%';
  inputElem.style.boxSizing = 'border-box';

  // create button
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'field-eye-btn';
  btn.setAttribute('aria-pressed', 'false');
  btn.title = 'Show / hide password';
  btn.innerHTML = `
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <g class="eye-open visible">
        <path d="M2 12s4-7 10-7 10 7 10 7-4 7-10 7S2 12 2 12z" stroke="#475569" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="12" cy="12" r="3" stroke="#475569" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
      </g>
      <g class="eye-closed hidden">
        <path d="M3 3l18 18" stroke="#475569" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M17.94 17.94C16.12 19.11 14.1 19.8 12 19.8 6 19.8 2 12 2 12c.9-1.53 2.19-2.98 3.7-4.25" stroke="#475569" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
      </g>
    </svg>`;

  // helper to set visible/hidden inside svg
  function setEyeVisible(open) {
    const gOpen = btn.querySelector('.eye-open');
    const gClosed = btn.querySelector('.eye-closed');
    if (open) {
      if (gOpen) { gOpen.classList.remove('hidden'); gOpen.classList.add('visible'); }
      if (gClosed) { gClosed.classList.remove('visible'); gClosed.classList.add('hidden'); }
      btn.setAttribute('aria-pressed', 'true');
    } else {
      if (gOpen) { gOpen.classList.remove('visible'); gOpen.classList.add('hidden'); }
      if (gClosed) { gClosed.classList.remove('hidden'); gClosed.classList.add('visible'); }
      btn.setAttribute('aria-pressed', 'false');
    }
  }

  setEyeVisible(false);

  btn.addEventListener('click', (e) => {
    e.preventDefault();
    const wasPassword = inputElem.type === 'password';
    inputElem.type = wasPassword ? 'text' : 'password';
    setEyeVisible(wasPassword);
    inputElem.focus();
    const v = inputElem.value || '';
    try { inputElem.setSelectionRange(v.length, v.length); } catch (err) {}
  });

  wrapper.appendChild(btn);
  inputElem._hasEye = true;
  inputElem._eyeBtn = btn;
  return btn;
}

/* small password strength - returns score 0..5 and text label */
function passwordStrength(pw) {
  if (!pw) return { score: 0, label: 'Too short' };
  let score = 0;
  if (pw.length >= 6) score += 1;
  if (pw.length >= 10) score += 1;
  if (/[A-Z]/.test(pw)) score += 1;
  if (/[0-9]/.test(pw)) score += 1;
  if (/[^A-Za-z0-9]/.test(pw)) score += 1;
  const labels = ['Very weak','Weak','Okay','Good','Strong','Excellent'];
  return { score, label: labels[Math.min(score, labels.length-1)] };
}

/* ------------------ Login modal (modern + eye + centered) ------------------ */
async function openLoginModal() {
  const html = `
    <div class="login-modal">
      <h3>Login</h3>
      <label>Username or email</label>
      <input id="modal_login_username" placeholder="username or email" autocomplete="username">
      <label>Password</label>
      <div><input id="modal_login_password" type="password" placeholder="password" autocomplete="current-password"></div>

      <div style="display:flex;gap:8px;margin-top:16px;justify-content:flex-end">
        <button id="modal_login_cancel" class="btn-ghost">Cancel</button>
        <button id="modal_login_btn" class="btn">Login</button>
      </div>
    </div>
  `;
  // showModal should place the HTML inside .modal (backdrop handled by your showModal)
  showModal(html);

  // If showModal wraps in .modal, make sure modal is centered (most implementations already do)
  const modalRoot = document.querySelector('.modal');
  if (modalRoot) modalRoot.style.display = 'block';

  // elements
  const userEl = document.getElementById('modal_login_username');
  const pwEl = document.getElementById('modal_login_password');
  const btn = document.getElementById('modal_login_btn');

  // attach eye
  attachPasswordEye(pwEl);

  // disable login button until fields present
  function updateLoginBtn() { btn.disabled = !((userEl.value||'').trim() && (pwEl.value||'')); }
  userEl.addEventListener('input', updateLoginBtn);
  pwEl.addEventListener('input', updateLoginBtn);
  updateLoginBtn();

  document.getElementById('modal_login_cancel').onclick = closeModal;
  btn.onclick = async () => {
    const username = (userEl.value || '').trim();
    const password = (pwEl.value || '');
    if (!username || !password) return alert('Username and password required');

    try {
      const r = await fetchJson('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });
      if (!r.ok) return alert('Login failed: ' + (r.error || 'Server error'));
      // Persist token & user, close modal, update nav
      localStorage.setItem('token', (r.data && r.data.token) || r.token || '');
      localStorage.setItem('user', JSON.stringify((r.data && r.data.user) || r.user || r.data || {}));
      closeModal();
      if (typeof applyNavUI === 'function') applyNavUI();
      if (typeof attachAuthButtons === 'function') attachAuthButtons();
      try { await loadTree(); } catch(e){}
      alert('Logged in');
    } catch (err) {
      console.error('login error', err);
      alert('Login error: ' + (err && err.message ? err.message : 'Unknown'));
    }
  };
}

/* ------------------ Register modal (modern + eye + checks + inline messages) ------------------ */
async function openRegisterModal() {
  const countrySelectHtml = (typeof buildCountrySelectHtml === 'function') ? buildCountrySelectHtml('') : `<select id="profile_country"><option value="">Select country</option></select>`;
  const cityHtml = (typeof buildCitySelectHtml === 'function') ? buildCitySelectHtml('', '') : `<input id="reg_city" placeholder="City">`;

  const html = `
    <div class="register-modal">
      <h3>Register</h3>

      <label>Full name</label>
      <input id="reg_fullName" placeholder="Full name" autocomplete="name">

      <label>Username (or email)</label>
      <input id="reg_username" placeholder="username or email" autocomplete="username">

      <label>Country</label>
      ${countrySelectHtml}

      <label>City</label>
      <div id="reg_city_container">${cityHtml}</div>

      <label>Phone (eg. +252...)</label>
      <input id="reg_phone" placeholder="+2519xxxxxxxx" autocomplete="tel">

      <label>Password</label>
      <div><input id="reg_password" type="password" placeholder="Password" autocomplete="new-password"></div>

      <label>Confirm password</label>
      <div><input id="reg_password_confirm" type="password" placeholder="Confirm password" autocomplete="new-password"></div>

      <div style="display:flex;gap:8px;margin-top:14px;justify-content:flex-end;">
        <button id="reg_cancel" class="btn-ghost">Cancel</button>
        <button id="reg_submit" class="btn">Register</button>
      </div>
    </div>
  `;
  showModal(html);
  const modalRoot = document.querySelector('.modal');
  if (modalRoot) modalRoot.style.display = 'block';

  // elements
  const usernameEl = document.getElementById('reg_username');
  const fullNameEl = document.getElementById('reg_fullName');
  const phoneEl = document.getElementById('reg_phone');
  const pwEl = document.getElementById('reg_password');
  const pwcEl = document.getElementById('reg_password_confirm');
  const submitBtn = document.getElementById('reg_submit');

  // inline message helper
  function ensureMsg(el) {
    let msg = el.nextElementSibling;
    if (!msg || !msg.classList || !msg.classList.contains('inline-msg')) {
      msg = document.createElement('div');
      msg.className = 'inline-msg';
      el.parentNode.insertBefore(msg, el.nextSibling);
    }
    return msg;
  }
  const usernameMsg = ensureMsg(usernameEl);
  const fullNameMsg = ensureMsg(fullNameEl);
  const phoneMsg = ensureMsg(phoneEl);
  const pwMsg = ensureMsg(pwEl);
  const pwcMsg = ensureMsg(pwcEl);

  // password strength (use your existing passwordStrength)
  const strengthBar = document.createElement('div');
  strengthBar.className = 'pw-strength';
  const strengthFill = document.createElement('div');
  strengthFill.className = 'fill';
  strengthBar.appendChild(strengthFill);
  pwEl.parentNode.insertBefore(strengthBar, pwEl.nextSibling);

  function updatePasswordUI() {
    const p = pwEl.value || '';
    const s = passwordStrength(p);
    const pct = Math.min(100, (s.score / 5) * 100);
    strengthFill.style.width = pct + '%';
    pwMsg.innerText = s.label + (p.length < 6 ? ' ‚Äî min 6 chars' : '');
    if (pwcEl.value && p !== pwcEl.value) pwcMsg.innerText = 'Passwords do not match';
    else pwcMsg.innerText = '';
  }
  pwEl.addEventListener('input', updatePasswordUI);
  pwcEl.addEventListener('input', updatePasswordUI);
  updatePasswordUI();

  // availability check (debounced)
  async function checkUsernameRaw(nameRaw) {
    const name = String(nameRaw || '').trim();
    if (!name || name.length < 3) {
      usernameMsg.innerText = 'Choose a username (min 3 characters)';
      return false;
    }
    usernameMsg.innerText = 'Checking availability...';
    try {
      // send raw (server handles email-like input)
      const r = await fetchJson('/api/auth/check-username?username=' + encodeURIComponent(name));
      if (!r || !r.ok) {
        usernameMsg.innerText = 'Could not check username';
        return false;
      }
      // server returns { ok:true, available: true/false } as data
      const avail = (r.data && r.data.available) === true;
      usernameMsg.innerText = avail ? 'Available ‚úÖ' : 'Not available ‚Äî try another';
      return avail;
    } catch (e) {
      usernameMsg.innerText = 'Check failed';
      return false;
    }
  }
  const debouncedCheck = debouncePromise(checkUsernameRaw, 420);
  let lastUsernameAvailable = false;

  usernameEl.addEventListener('input', (ev) => {
    const v = (ev.target.value || '').trim();
    if (!v || v.length < 3) {
      usernameMsg.innerText = 'Choose a username (min 3 characters)';
      lastUsernameAvailable = false;
      return;
    }
    usernameMsg.innerText = 'Checking availability...';
    debouncedCheck(v)
      .then(avail => { lastUsernameAvailable = Boolean(avail); })
      .catch(err => { if (err && err.cancelled) return; usernameMsg.innerText = 'Check failed'; lastUsernameAvailable = false; });
  });

  // attach eye (if you have attachPasswordEye)
  try { attachPasswordEye(pwEl); attachPasswordEye(pwcEl); } catch(e){}

  // country -> city wiring
  const profileCountry = document.getElementById('profile_country');
  if (profileCountry) {
    profileCountry.addEventListener('change', (ev) => {
      const code = ev.target.value;
      const cityContainer = document.getElementById('reg_city_container');
      if (typeof buildCitySelectHtml === 'function') cityContainer.innerHTML = buildCitySelectHtml(code, '');
      else cityContainer.innerHTML = `<input id="reg_city" placeholder="City">`;
    });
  }

  document.getElementById('reg_cancel').onclick = closeModal;

  document.getElementById('reg_submit').onclick = async () => {
    const fullName = (fullNameEl.value || '').trim();
    const usernameRaw = (usernameEl.value || '').trim();
    const country = (document.getElementById('profile_country') ? document.getElementById('profile_country').value : '') || '';
    const cityEl = document.getElementById('profile_city') || document.getElementById('reg_city') || document.querySelector('#reg_city_container input');
    const city = cityEl ? (cityEl.value || '').trim() : '';
    const phoneNumber = (phoneEl.value || '').trim();
    const password = (pwEl.value || '');
    const confirm = (pwcEl.value || '');

    if (!fullName || !usernameRaw || !password) return alert('Full name, username and password are required');
    if (password.length < 6) return alert('Password must be at least 6 characters');
    if (password !== confirm) return alert('Passwords do not match');

    if (!lastUsernameAvailable) {
      const ok = await checkUsernameRaw(usernameRaw);
      if (!ok) return alert('Username not available ‚Äî choose another');
    }

    if (phoneNumber && !/^\+?[0-9\-\s()]{7,20}$/.test(phoneNumber)) return alert('Enter a valid phone number with country code');

    const payload = {
      username: usernameRaw,
      fullName,
      password,
      phoneNumber: phoneNumber || undefined,
      country: country || undefined,
      countryName: (typeof COUNTRIES !== 'undefined' && Array.isArray(COUNTRIES) && country) ? ((COUNTRIES.find(c => c.code === country) || {}).name || country) : undefined,
      city: city || undefined
    };

    // if username is email-like, also set email field (lowercased)
    if (String(usernameRaw).indexOf('@') !== -1) {
      payload.email = usernameRaw.toLowerCase();
    }

    submitBtn.disabled = true;
    try {
      const r = await fetchJson('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!r || !r.ok) {
        // r.error or r.data.error
        const errMsg = (r && (r.error || (r.data && (r.data.error || r.data.message)))) ? (r.error || r.data.error || r.data.message) : 'Registration failed';
        return alert(errMsg);
      }

      if (r.data && r.data.token) localStorage.setItem('token', r.data.token);
      if (r.data && r.data.user) localStorage.setItem('user', JSON.stringify(r.data.user));

      alert('Registered successfully');
      closeModal();
      if (typeof applyNavUI === 'function') applyNavUI();
    } catch (err) {
      console.error('register error', err);
      alert('Registration failed: ' + (err && err.message ? err.message : 'Unknown'));
    } finally {
      submitBtn.disabled = false;
    }
  };
}

/* doLogout: clears session & refreshes UI */
function doLogout(){
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  // optional: clear opened announcements to reset badge state
  // localStorage.removeItem(OPENED_KEY);
  applyNavUI();
  attachAuthButtons();
  // refresh tree to hide protected content
  try { loadTree(); } catch(e){}
  // close any open settings dropdown/modal
  try { closeModal(); } catch(e){}
  alert('Logged out');
}

/* updateSettingsDropdown: ensures mobile settings reflect login/admin state */
/* updateSettingsDropdown: ensures mobile settings reflect login/admin state
   ‚Äî Fix: always include ENG / SOM language buttons and attach handlers here
*/
function updateSettingsDropdown(){
  const dd = document.getElementById('settingsDropdown');
  if (!dd) return;
  const token = !!getToken();
  const admin = isAdmin();

  // Build inner content so it remains consistent across nav updates
  const innerParts = [];

  if (token) {
    innerParts.push(`<button id="sLogout" class="settings-item"><span class="icon">üö™</span> Logout</button>`);
    innerParts.push(`<button id="sBalance" class="settings-item"><span class="icon">üí∞</span> Balance</button>`);
    innerParts.push(`<button id="sConvert" class="settings-item"><span class="icon">üîÅ</span> Convert Points</button>`);
    if (admin) innerParts.push(`<button id="sChecking" class="settings-item"><span class="icon">‚úÖ</span> Checking</button>`);
    innerParts.push(`<div class="divider"></div>`);
    innerParts.push(`<button id="sEditProfile" class="settings-item"><span class="icon">‚úèÔ∏è</span> Edit Profile</button>`);
  } else {
    // guest UI: show Login / Register only
    innerParts.push(`<button id="sLogin" class="settings-item"><span class="icon">üîê</span> Login</button>`);
    innerParts.push(`<button id="sRegister" class="settings-item"><span class="icon">üßæ</span> Register</button>`);
  }

  innerParts.push(`<div class="divider"></div>`);

  // Language selector (always present)
  innerParts.push(`
    <div style="display:flex;gap:8px;padding:4px 4px;align-items:center">
      <button id="langEng" class="small-btn" style="flex:1">ENG</button>
      <button id="langSom" class="small-btn" style="flex:1">SOM</button>
    </div>
  `);

  innerParts.push(`<div class="divider"></div>`);

  // admin actions (visible only if admin)
  if (admin) {
    innerParts.push(`<button id="sAddFolder" class="settings-item"><span class="icon">‚ûï</span> + Add Folder</button>`);
    innerParts.push(`<button id="sRecycle" class="settings-item"><span class="icon">üóëÔ∏è</span> Recycle Bin</button>`);
  }

  // set inner HTML
  dd.querySelector('.inner').innerHTML = innerParts.join('');

  // Attach the new handlers (safe attaching)
  const tryBind = (id, fn) => { const el = document.getElementById(id); if (el) { el.onclick = fn; } };

  tryBind('sLogin', async (e) => { e.preventDefault(); closeSettingsDropdownSilently(); await openLoginModal(); });
  tryBind('sRegister', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openRegisterModal(); });
  tryBind('sLogout', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); doLogout(); });
  tryBind('sBalance', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openBalanceModal(); });
  tryBind('sConvert', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openConvertModal(); });
  tryBind('sChecking', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openAdminWithdrawals(); });
  tryBind('sEditProfile', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openEditProfile(); });
  tryBind('sAddFolder', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openAddFolderModal(null); });
  tryBind('sRecycle', (e) => { e.preventDefault(); closeSettingsDropdownSilently(); openRecycleModal(); });

  // Language handlers (attach here so they exist even after rebuild)
  tryBind('langEng', (e) => {
    e.preventDefault();
    // setLang expects 'en' or 'som' (your setLang will normalize)
    if (typeof setLang === 'function') setLang('en');
    else localStorage.setItem('lang','en');
    if (typeof applyNavUI === 'function') applyNavUI();
    if (typeof renderAfterLangChange === 'function') renderAfterLangChange();
    closeSettingsDropdownSilently();
  });
  tryBind('langSom', (e) => {
    e.preventDefault();
    if (typeof setLang === 'function') setLang('som');
    else localStorage.setItem('lang','som');
    if (typeof applyNavUI === 'function') applyNavUI();
    if (typeof renderAfterLangChange === 'function') renderAfterLangChange();
    closeSettingsDropdownSilently();
  });

  // small helper to close settings dropdown if present
  function closeSettingsDropdownSilently(){
    const settingsDrop = document.getElementById('settingsDropdown');
    if (settingsDrop) settingsDrop.classList.remove('open');
  }
}

/* setDisplay helper (safe) */
function setDisplay(id, show){
  const el = document.getElementById(id);
  if (!el) return;
  el.style.display = show ? '' : 'none';
}

/* applyNavUI: show/hide header buttons + admin links; call updateSettingsDropdown to sync mobile settings */
function applyNavUI(){
  const token = !!getToken();
  const admin = isAdmin();
  const user = getUser();

  // desktop auth buttons
  setDisplay('btn-login', !token);
  setDisplay('btn-register', !token);
  setDisplay('btn-logout', token);
  setDisplay('btn-edit-profile', token);
  setDisplay('btn-balance', token);
  setDisplay('btn-convert', token);
  setDisplay('btn-check-withdrawals', token && admin);

  // admin desktop buttons
  setDisplay('btn-add-folder', token && admin);
  setDisplay('btn-recycle', token && admin);

  // nav admin-only anchors
  document.querySelectorAll('.admin-link').forEach(a => {
    a.style.display = (token && admin) ? '' : 'none';
  });

  // settings dropdown mobile: show/hide admin items inside dropdown (we rebuild its inner HTML)
  updateSettingsDropdown();

  // update bell button visibility (we always show it if there is a btnBell)
  const bell = document.getElementById('btnBell');
  if (bell) bell.style.display = '';

  // update header user full name (if present)
  const headerNameEl = document.getElementById('headerUserFull');
  if (headerNameEl) {
    if (user) headerNameEl.innerText = user.fullName || user.username || '';
    else headerNameEl.innerText = '';
  }

  // ensure mobile panel admin links are hidden for non-admins
  document.querySelectorAll('#mobileMenu .admin-link').forEach(node => { node.style.display = (token && admin) ? '' : 'none'; });

  // make sure settings & hamburger ARIA states are consistent
  const btnHamburger = document.getElementById('btnHamburger');
  const mobileMenu = document.getElementById('mobileMenu');
  if (btnHamburger && mobileMenu) {
    btnHamburger.setAttribute('aria-expanded', mobileMenu.classList.contains('open') ? 'true' : 'false');
  }
}

/* attachAuthButtons: bind header buttons (login/register/logout/edit profile) */
function attachAuthButtons(){
  // Desktop: login
  const bLogin = document.getElementById('btn-login');
  if (bLogin) {
    bLogin.onclick = async (e) => { e.preventDefault(); await openLoginModal(); };
  }
  // desktop register
  const bReg = document.getElementById('btn-register');
  if (bReg) bReg.onclick = (e) => { e.preventDefault(); openRegisterModal(); };

  // logout
  const bOut = document.getElementById('btn-logout');
  if (bOut) bOut.onclick = (e) => { e.preventDefault(); doLogout(); };

  // edit profile
  const bEdit = document.getElementById('btn-edit-profile');
  if (bEdit) bEdit.onclick = (e) => { e.preventDefault(); openEditProfile(); };

  // recycle & add folder desktop shortcuts (admin only)
  const bRecycle = document.getElementById('btn-recycle');
  if (bRecycle) bRecycle.onclick = (e) => { e.preventDefault(); openRecycleModal(); };
  const bAddFolder = document.getElementById('btn-add-folder');
  if (bAddFolder) bAddFolder.onclick = (e) => { e.preventDefault(); openAddFolderModal(null); };

  // ensure settings dropdown content is up-to-date
  updateSettingsDropdown();
}

/* run initializers at DOMContentLoaded (replace any older in-file initial call) */
document.addEventListener('DOMContentLoaded', () => {
  // ensure header user full name element exists
  if (!document.getElementById('headerUserFull')) {
    const brand = document.querySelector('.sh-brand');
    if (brand) {
      const span = document.createElement('span');
      span.id = 'headerUserFull';
      span.style.marginLeft = '8px';
      span.style.fontWeight = '600';
      span.style.fontSize = '14px';
      brand.appendChild(span);
    }
  }

  applyNavUI();
  attachAuthButtons();
  // refresh bell badge when nav UI is applied
  try { if (typeof fetchHelpUnreadCount === 'function') fetchHelpUnreadCount(); } catch(e){}
});
/******************* END AUTH & NAV PATCH ******************************/

/* run on startup */
document.addEventListener('DOMContentLoaded', () => {
  // ensure header user full name element exists, if not create it
  if (!document.getElementById('headerUserFull')) {
    const brand = document.querySelector('.sh-brand');
    if (brand) {
      const span = document.createElement('span');
      span.id = 'headerUserFull';
      span.style.marginLeft = '8px';
      span.style.fontWeight = '600';
      span.style.fontSize = '14px';
      brand.appendChild(span);
    }
  }

  // attach handlers and make initial UI adjustments
  attachAuthButtons();

  // call applyNavUI at boot
  try { applyNavUI(); } catch(e){ console.warn('applyNavUI error', e); }

  // Re-create mobile dropdown login/logout entry immediately
  try { const dd = document.getElementById('navDropdown'); if (dd) { /* reset built in mobile content if needed */ applyNavUI(); } } catch(e){}
});

/* If your app has its own login/logout flows elsewhere, call applyNavUI() after they finish.
   Example: after successful login elsewhere -> localStorage.setItem(...), then applyNavUI(); renderNav();
*/
  function renderAfterLangChange(){ if (!treeCache) treeCache = []; if (!currentFolderId) { renderRootFolders(treeCache); pathStack = []; updateHeaderForFolder(null); } else { const node = findNodeById(currentFolderId, treeCache); if (!node) { currentFolderId = null; pathStack=[]; renderRootFolders(treeCache); updateHeaderForFolder(null); return; } pathStack = buildPathToNode(node._id, treeCache); updateHeaderForFolder(node); renderFolderView(node); } const lang=getLang();  }




  (function(){
  const $ = id => document.getElementById(id);
  const hasFn = (n) => typeof window[n] === 'function';

  // DOM refs
  const btnHamburger = $('btnHamburger');
  const mobileMenu    = $('mobileMenu');
  const btnSettings   = $('btnSettings');
  const settingsDrop  = $('settingsDropdown');
  const btnBell       = $('btnBell') || $('btn-help') || $('btnHelp');
  const modalRoot     = $('modalRoot');

  // open/close mobile nav
  function openMobile(){ if (!mobileMenu) return; mobileMenu.classList.add('open'); if (btnHamburger) btnHamburger.setAttribute('aria-expanded','true'); mobileMenu.setAttribute('aria-hidden','false'); }
  function closeMobile(){ if (!mobileMenu) return; mobileMenu.classList.remove('open'); if (btnHamburger) btnHamburger.setAttribute('aria-expanded','false'); mobileMenu.setAttribute('aria-hidden','true'); }
  function toggleMobile(){ if (!mobileMenu) return; mobileMenu.classList.contains('open') ? closeMobile() : openMobile(); }

  // settings dropdown
  function openSettings(){ if (!settingsDrop) return; settingsDrop.classList.add('open'); if (btnSettings) btnSettings.setAttribute('aria-expanded','true'); settingsDrop.setAttribute('aria-hidden','false'); }
  function closeSettings(){ if (!settingsDrop) return; settingsDrop.classList.remove('open'); if (btnSettings) btnSettings.setAttribute('aria-expanded','false'); settingsDrop.setAttribute('aria-hidden','true'); }
  function toggleSettings(){ if (!settingsDrop) return; settingsDrop.classList.contains('open') ? closeSettings() : openSettings(); }

  function on(id, fn){ const el = $(id); if (!el) return false; el.addEventListener('click', fn); return true; }

  // patch applyNavUI so it doesn't hide gear/bell on mobile
  (function patchApplyNavUI(){
    const orig = window.applyNavUI;
    window.applyNavUI = function(...args){
      try { if (typeof orig === 'function') orig(...args); } catch(e){ console.warn('applyNavUI original failed', e); }
      if (btnBell) btnBell.style.display = '';
      // don't force-hide btnSettings here because CSS controls desktop/mobile visibility
      try { if (typeof fetchHelpUnreadCount === 'function') fetchHelpUnreadCount(); } catch(e){ /*ignore*/ }
    };
  })();

  // attach handlers
  function attach(){
    // hamburger toggles mobile menu
    if (btnHamburger && mobileMenu) {
      btnHamburger.addEventListener('click', (e) => { e.stopPropagation(); toggleMobile(); });

      // close only when a nav link (mobile-nav-link) is clicked
      mobileMenu.addEventListener('click', (ev) => {
        const a = ev.target.closest('a');
        if (a && a.classList.contains('mobile-nav-link')) {
          // allow default navigation then close
          closeMobile();
        }
      });
    }

    // settings gear toggles settings dropdown (gear visible on mobile/tablet)
    if (btnSettings && settingsDrop) {
      btnSettings.addEventListener('click', (e) => { e.stopPropagation(); toggleSettings(); });
    }

    // bell button (announcements)
    if (btnBell) {
      btnBell.addEventListener('click', (e) => {
        e.stopPropagation();
        if (hasFn('openBellModal')) return openBellModal();
        if (modalRoot) {
          modalRoot.innerHTML = '<div class="modal-backdrop"><div class="modal"><h3>Announcements</h3><div style="padding:12px;color:#666">No announcements (demo)</div><div style="display:flex;justify-content:flex-end"><button id="closeAnn" class="small-btn">Close</button></div></div></div>';
          modalRoot.style.display = 'block';
          const cb = $('closeAnn'); if (cb) cb.onclick = () => { modalRoot.style.display='none'; modalRoot.innerHTML=''; };
        } else alert('Announcements (demo)');
      });
    }

    // global outside-click close
    document.addEventListener('click', (ev) => {
      if (mobileMenu && !mobileMenu.contains(ev.target) && btnHamburger && !btnHamburger.contains(ev.target)) closeMobile();
      if (settingsDrop && !settingsDrop.contains(ev.target) && btnSettings && !btnSettings.contains(ev.target)) closeSettings();
    });

    // Escape closes menus
    document.addEventListener('keydown', (ev) => { if (ev.key === 'Escape') { closeMobile(); closeSettings(); } });

    // Settings actions
    on('sLogout', async (e) => { e.preventDefault(); localStorage.removeItem('token'); localStorage.removeItem('user'); if (hasFn('applyNavUI')) applyNavUI(); closeSettings(); alert('Logged out (demo)'); });
    on('sBalance', async (e) => { e.preventDefault(); closeSettings(); if (hasFn('openBalanceModal')) return openBalanceModal(); alert('Balance (demo)'); });
    on('sConvert', async (e) => { e.preventDefault(); closeSettings(); if (hasFn('openConvertModal')) return openConvertModal(); alert('Convert Points (demo)'); });
    on('sChecking', async (e) => { e.preventDefault(); closeSettings(); if (hasFn('openAdminWithdrawals')) return openAdminWithdrawals(); alert('Checking (demo)'); });
    on('sEditProfile', (e) => { e.preventDefault(); closeSettings(); if (hasFn('openEditProfile')) return openEditProfile(); alert('Edit profile (demo)'); });
    on('sAddFolder', (e) => { e.preventDefault(); closeSettings(); if (hasFn('openAddFolderModal')) return openAddFolderModal(null); alert('Add Folder (demo)'); });
    on('sRecycle', (e) => { e.preventDefault(); closeSettings(); if (hasFn('openRecycleModal')) return openRecycleModal(); alert('Recycle (demo)'); });

    // Desktop quick buttons
    on('btn-add-folder', (e) => { e.preventDefault(); if (hasFn('openAddFolderModal')) return openAddFolderModal(null); alert('Add Folder (demo)'); });
    on('btn-recycle', (e) => { e.preventDefault(); if (hasFn('openRecycleModal')) return openRecycleModal(); alert('Recycle (demo)'); });

    // Language buttons inside settings
    const langEnEl = $('langEng') || $('lang-en');
    const langSomEl = $('langSom') || $('lang-som');
    if (langEnEl) langEnEl.addEventListener('click', () => { if (hasFn('setLang')) setLang('en'); else localStorage.setItem('lang','en'); if (hasFn('applyNavUI')) applyNavUI(); if (hasFn('renderAfterLangChange')) renderAfterLangChange(); });
    if (langSomEl) langSomEl.addEventListener('click', () => { if (hasFn('setLang')) setLang('som'); else localStorage.setItem('lang','som'); if (hasFn('applyNavUI')) applyNavUI(); if (hasFn('renderAfterLangChange')) renderAfterLangChange(); });

    // ARIA defaults
    if (mobileMenu) mobileMenu.setAttribute('aria-hidden', mobileMenu.classList.contains('open') ? 'false' : 'true');
    if (settingsDrop) settingsDrop.setAttribute('aria-hidden', settingsDrop.classList.contains('open') ? 'false' : 'true');
    if (btnHamburger && !btnHamburger.hasAttribute('aria-expanded')) btnHamburger.setAttribute('aria-expanded','false');
    if (btnSettings && !btnSettings.hasAttribute('aria-expanded')) btnSettings.setAttribute('aria-expanded','false');

    // initial bell badge poll
    if (hasFn('fetchHelpUnreadCount')) try { fetchHelpUnreadCount(); } catch(e){ console.warn(e); }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();

  // debug helpers
  window._menuDebug = { openMobile: ()=> { const el = $('mobileMenu'); if(el) el.classList.add('open'); }, closeMobile: ()=> { const el = $('mobileMenu'); if(el) el.classList.remove('open'); }, toggleMobile, openSettings, closeSettings, toggleSettings };

})();

  
/* ===================== STARTUP ===================== */
// ensure applyNavUI runs at boot and after login/logout
applyNavUI();
renderAfterLangChange();
loadTree();

</script>
</body>
</html>
