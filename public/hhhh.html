<script>
  async function openBalanceModal(){
  // load balance + summary + withdrawals concurrently
  const [rawBal, rawSummary, rawList] = await Promise.all([
    safeFetchJson('/api/account/balance', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdraw/summary', { headers: authHeaders() }),
    safeFetchJson('/api/account/withdrawals', { headers: authHeaders() })
  ]);

  const balRes = normalizeApiResponse(rawBal);
  if (!balRes.ok) {
    if (!getToken()) return alert('No authorization token found — please log in.');
    return alert(balRes.error || 'Failed to load balance');
  }

  const b = (balRes.data && balRes.data.balance) ? balRes.data.balance : {};
  const user = (balRes.data && balRes.data.user) ? balRes.data.user : getUser() || {};
  const points = Number(b.pointsCurrent || 0);
  const balanceDollar = Number(b.balanceDollar || 0);

  const sumRes = normalizeApiResponse(rawSummary);
  // canonical list variable (client-side)
  const list = _normalizeWithdrawListShape(rawList);

  // compute totals from list client-side (reliable for UI)
  const capFromServer = (sumRes && sumRes.data && sumRes.data.cap) ? Number(sumRes.data.cap) : WITHDRAWAL_24H_CAP;
  const computedTotals = compute24WindowTotals(list || [], capFromServer, 5);

  // prefer computedTotals then server summary then safe defaults
  const capVal = capFromServer;
  const spent24 = (typeof computedTotals.spent24 === 'number') ? computedTotals.spent24 :
                  ((sumRes && sumRes.data && typeof sumRes.data.spent24 === 'number') ? Number(sumRes.data.spent24) : 0);
  const pending24 = (typeof computedTotals.pending24 === 'number') ? computedTotals.pending24 :
                    ((sumRes && sumRes.data && typeof sumRes.data.pending24 === 'number') ? Number(sumRes.data.pending24) : 0);

  const remainingVerified = (typeof computedTotals.remainingVerified === 'number') ? computedTotals.remainingVerified :
                            ((sumRes && sumRes.data && sumRes.data.remainingVerified !== undefined) ? Number(sumRes.data.remainingVerified) : Math.max(0, capVal - spent24));
  const remainingIncludingPending = (typeof computedTotals.remainingIncludingPending === 'number') ? computedTotals.remainingIncludingPending :
                                     ((sumRes && sumRes.data && sumRes.data.remainingIncludingPending !== undefined) ? Number(sumRes.data.remainingIncludingPending) : Math.max(0, capVal - (spent24 + pending24)));

  // count (requests) — prefer server summary.requestCount24 when present, otherwise use computedTotals.requestCount24 or fallback computeWithdrawCount24(list)
  const serverRequestCount = (sumRes && sumRes.data && typeof sumRes.data.requestCount24 === 'number') ? Number(sumRes.data.requestCount24) : null;
  const serverNextRequestAllowed = (sumRes && sumRes.data && sumRes.data.nextRequestAllowedAt) ? sumRes.data.nextRequestAllowedAt : null;
  const localCountInfo = computeWithdrawCount24(list || [], 5);
  const count24 = (serverRequestCount !== null) ? serverRequestCount : ((typeof computedTotals.requestCount24 === 'number') ? computedTotals.requestCount24 : localCountInfo.count);
  const nextAllowedAtIsoCount = serverNextRequestAllowed || computedTotals.nextRequestAllowedAt || localCountInfo.nextAllowedAtIso || null;

  // nextAllowedAt for money cap (prefer computedTotals then server)
  const nextAllowedAtIsoMoney = computedTotals.nextAllowedAt || (sumRes && sumRes.data && sumRes.data.nextAllowedAt) || null;

  // withdraw disabled if money cap exhausted OR count cap reached
  const withdrawDisabled = (remainingIncludingPending <= 0 && !(safeNum(spent24) === 0 && safeNum(pending24) === 0)) || (count24 >= 5);

  const html = `
    <div class="balance-modal" role="dialog" aria-modal="true" aria-labelledby="bal_title">
      <h3 id="bal_title">Your Balance</h3>
      <div class="balance-user">
        <div class="balance-avatar">${escapeHtml((user.fullName||user.username||'U').slice(0,2)).toUpperCase()}</div>
        <div style="flex:1">
          <div style="font-weight:700">${escapeHtml(user.fullName || user.username || '')}</div>
          <div class="small-muted">${escapeHtml(user.email || '')}</div>
        </div>
      </div>

      <div class="balance-row" style="margin-top:14px">
        <div class="balance-col">
          <div class="small-muted">Points</div>
          <div class="counter" id="bal_points">0</div>
          <div class="counter-sub">Current points</div>
        </div>
        <div style="width:14px"></div>
        <div class="balance-col" style="text-align:right">
          <div class="small-muted">Dollar Balance</div>
          <div class="counter" id="bal_dollars">0.000</div>
          <div class="counter-sub">Available dollars</div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div id="bal_remaining_box" class="small-muted"></div>
      </div>

      <div class="btn-row" style="margin-top:8px">
        <button id="bal_convert" class="btn-ghost small-cta">Convert Points → $</button>
        <button id="bal_withdraw" class="btn small-cta btn-withdraw" style="background:#2563eb;color:#fff;border-color:#2563eb" ${withdrawDisabled ? 'disabled' : ''}>Withdraw</button>
        <button id="bal_requests" class="btn-ghost small-cta">My Requests</button>
        <button id="bal_close" class="btn-ghost small-cta">Close</button>
      </div>
      <div class="small-muted" style="margin-top:6px">
        Tip: convert only if you have at least 100 points. Withdrawals require at least $${MIN_WITHDRAW} available and max $${WITHDRAWAL_24H_CAP} verified per 24 hours.
      </div>
    </div>
  `;
  showModal(html);

  // render remaining box with both money and count information + live countdowns
  const remBox = document.getElementById('bal_remaining_box');
  let balCountdown = null;
  function clearBalCountdown(){ if (balCountdown) { clearInterval(balCountdown); balCountdown = null; } }

  const renderRemainingBox = () => {
    let out = `<div style="margin-bottom:6px">Withdrawals in last 24h: <strong>${count24}/5</strong></div>`;

    if ((safeNum(spent24) + safeNum(pending24)) <= 0) {
      out += `<div style="color:#15803d;font-weight:700">Remaining verified allowance in last 24h: <strong>$${Number(capVal).toFixed(3)}</strong></div>`;
    } else if (remainingIncludingPending > 0) {
      out += `<div>24h used: <strong>${moneyFmt(spent24)}</strong> • pending: <strong>${moneyFmt(pending24)}</strong></div>
              <div>Remaining (including pending): <strong>$${Number(remainingIncludingPending).toFixed(3)}</strong></div>`;
    } else {
      out += `<div style="color:#b91c1c;font-weight:700">Remaining (including pending): $0.000 (cap reached)</div>`;
    }

    remBox.innerHTML = out;

    if (count24 >= 5) {
      const box = document.createElement('div');
      box.style.marginTop = '6px';
      box.style.color = '#b91c1c';
      box.style.fontWeight = '700';
      remBox.appendChild(box);

      if (nextAllowedAtIsoCount) {
        const target = new Date(nextAllowedAtIsoCount).getTime();
        const update = () => {
          const left = target - Date.now();
          if (left <= 0) {
            clearBalCountdown();
            box.textContent = 'You can make withdrawals again (count reset).';
            const bw = document.getElementById('bal_withdraw'); if (bw) bw.disabled = false;
            return;
          }
          const total = Math.floor(left/1000);
          const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
          const pad = v => String(v).padStart(2,'0');
          box.textContent = `Next withdrawal allowed in: ${pad(h)}:${pad(m)}:${pad(s)} (count limit reached)`;
        };
        update(); balCountdown = setInterval(update, 1000);
      } else {
        box.textContent = 'Withdraw count limit reached — next allowed in 24h from earliest recent request.';
      }
    } else if (remainingIncludingPending <= 0 && nextAllowedAtIsoMoney) {
      const box = document.createElement('div');
      box.style.marginTop = '6px';
      box.style.color = '#b91c1c';
      box.style.fontWeight = '700';
      remBox.appendChild(box);
      const target = new Date(nextAllowedAtIsoMoney).getTime();
      const updateMoney = () => {
        const left = target - Date.now();
        if (left <= 0) {
          clearBalCountdown();
          box.textContent = '24h money cap reset — you can make a verified withdrawal now.';
          const bw = document.getElementById('bal_withdraw'); if (bw) bw.disabled = false;
          return;
        }
        const total = Math.floor(left/1000);
        const h = Math.floor(total/3600); const m = Math.floor((total%3600)/60); const s = total%60;
        const pad = v => String(v).padStart(2,'0');
        box.textContent = `Next money-allowance reset in: ${pad(h)}:${pad(m)}:${pad(s)}`;
      };
      updateMoney(); balCountdown = setInterval(updateMoney, 1000);
    }
  };
  renderRemainingBox();

  // wire buttons
  document.getElementById('bal_close').onclick = () => { clearBalCountdown(); closeModal(); };
  document.getElementById('bal_requests').onclick = async () => { clearBalCountdown(); closeModal(); await openMyRequests(); };
  document.getElementById('bal_convert').onclick = async () => { clearBalCountdown(); closeModal(); await openConvertModal(); };
  document.getElementById('bal_withdraw').onclick = async () => { clearBalCountdown(); closeModal(); await openWithdrawModal(); };

  // animate numbers
  try {
    const pointsEl = document.getElementById('bal_points');
    const dollarsEl = document.getElementById('bal_dollars');
    await Promise.all([
      animateNumber({ el: pointsEl, start: 0, end: Math.round(points), duration: 900, decimals:0, onFrame: v=>{pointsEl.textContent=numFmt(Math.round(v));} }),
      animateNumber({ el: dollarsEl, start: 0, end: balanceDollar, duration: 1200, decimals:3, onFrame: v=>{dollarsEl.textContent=Number(v).toFixed(3);} })
    ]);
    try{ playTick(); }catch(e){}
  } catch(e){
    const pointsEl = document.getElementById('bal_points'); const dollarsEl = document.getElementById('bal_dollars');
    if (pointsEl) pointsEl.textContent = numFmt(Math.round(points));
    if (dollarsEl) dollarsEl.textContent = Number(balanceDollar).toFixed(3);
  }
}

</script>